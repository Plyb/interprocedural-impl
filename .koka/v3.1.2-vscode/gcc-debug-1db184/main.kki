module interface main
 
//------------------------------
//#kki: import declarations
 
import std/core/types = std/core/types pub = "";
import std/core/hnd = std/core/hnd pub = "";
import std/core/exn = std/core/exn pub = "";
import std/core/bool = std/core/bool pub = "";
import std/core/order = std/core/order pub = "";
import std/core/char = std/core/char pub = "";
import std/core/int = std/core/int pub = "";
import std/core/vector = std/core/vector pub = "";
import std/core/string = std/core/string pub = "";
import std/core/sslice = std/core/sslice pub = "";
import std/core/list = std/core/list pub = "";
import std/core/maybe = std/core/maybe pub = "";
import std/core/either = std/core/either pub = "";
import std/core/tuple = std/core/tuple pub = "";
import std/core/show = std/core/show pub = "";
import std/core/debug = std/core/debug pub = "";
import std/core/delayed = std/core/delayed pub = "";
import std/core/console = std/core/console pub = "";
import std/core = std/core = "";
import std/data/hashmap = std/data/hashmap = "";
import std/data/hashset = std/data/hashset = "";
import std/data/hash = std/data/hash = "";
import std/core/undiv = std/core/undiv = "";
import std/core/unsafe = std/core/unsafe = "";
 
//------------------------------
//#kki: external imports
 
 
//------------------------------
//#kki: fixity declarations
 
 
//------------------------------
//#kki: local imported aliases
 
// An alias for pure effects: a pure function always returns the same result
// when called with the same arguments but may not terminate or raise an exception.
local alias std/core/pure[52,1,52,26] :: E = <(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/div :: X)> = 1;
 
//------------------------------
//#kki: type declarations
 
pub value{0,2,8} type literal[88,7,91,1] {
  pub con StringLit[89,3,89,11](str: std/core/types/string){0,2,8} : (str : std/core/types/string) -> literal;
  pub con NumberLit[90,3,90,11](num: std/core/types/int){0,2,8} : (num : std/core/types/int) -> literal;
};
pub value{0,2,8} type fieldName[45,7,48,1] {
  pub con FNNamed[46,3,46,9](name: std/core/types/string){0,2,8} : (name : std/core/types/string) -> fieldName;
  pub con FNL[47,3,47,5]{0,1,8} : fieldName;
};
pub value{1,0,1} type op[115,1,121,1] {
  pub con AndOp[116,3,116,7]{0,0,0} : op;
  pub con NotOp[117,3,117,7]{0,0,0} : op;
  pub con EqOp[118,3,118,6]{0,0,0} : op;
  pub con GtOp[119,3,119,6]{0,0,0} : op;
  pub con PlusOp[120,3,120,8]{0,0,0} : op;
};
pub recursive type absOp[184,1,187,1] {
  pub con AOTrue[185,3,185,8]{0,0,0} : absOp;
  // This is different than the paper
  pub con AOOp[186,3,186,6](op: op, values: (std/core/types/list :: V -> V)<absValue>){1,1,8} : (op : op, values : (std/core/types/list :: V -> V)<absValue>) -> absOp;
};
pub recursive type absValue[225,1,230,1] {
  pub con AVBot[226,3,226,7]{0,0,0} : absValue;
  pub con AVLit[227,3,227,7](lits: (std/data/hashset/hash-set :: V -> V)<literal>){0,1,8} : (lits : (std/data/hashset/hash-set :: V -> V)<literal>) -> absValue;
  pub con AVOp[228,3,228,6](ops: (std/data/hashset/hash-set :: V -> V)<absOp>){0,1,8} : (ops : (std/data/hashset/hash-set :: V -> V)<absOp>) -> absValue;
  pub con AVPath[229,3,229,8](paths: (std/data/hashset/hash-set :: V -> V)<path>){0,1,8} : (paths : (std/data/hashset/hash-set :: V -> V)<path>) -> absValue;
};
pub recursive type path[154,1,158,1] {
  pub con Path[154,8,154,11](names: (std/core/types/list :: V -> V)<fieldName>, absOp: absOp, dependence: std/core/types/bool){1,2,8} : (names : (std/core/types/list :: V -> V)<fieldName>, absOp : absOp, dependence : std/core/types/bool) -> path;
};
pub value{0,1,8} type varName[72,1,74,1] {
  pub con VarName[72,8,72,14](name: std/core/types/string){0,1,8} : (name : std/core/types/string) -> varName;
};
pub recursive type exp[278,1,290,1] {
  pub con NullE[279,3,279,7](id: std/core/types/int){0,1,8} : (id : std/core/types/int) -> exp;
  pub con LitE[280,3,280,6](lit: literal, id: std/core/types/int){0,3,8} : (lit : literal, id : std/core/types/int) -> exp;
  pub con RootE[281,3,281,7](id: std/core/types/int){0,1,8} : (id : std/core/types/int) -> exp;
  pub con DotE[282,3,282,6](e: exp, f: fieldName, id: std/core/types/int){0,4,8} : (e : exp, f : fieldName, id : std/core/types/int) -> exp;
  pub con OpE[283,3,283,5](op: op, lhs: exp, rhs: exp, id: std/core/types/int){1,3,8} : (op : op, lhs : exp, rhs : exp, id : std/core/types/int) -> exp;
  pub con VarE[284,3,284,6](v: varName, id: std/core/types/int){0,2,8} : (v : varName, id : std/core/types/int) -> exp;
  pub con AsgnE[285,3,285,7](v: varName, rhs: exp, id: std/core/types/int){0,3,8} : (v : varName, rhs : exp, id : std/core/types/int) -> exp;
  pub con IfE[286,3,286,5](cont: exp, thn: exp, els: exp, id: std/core/types/int){0,4,8} : (cont : exp, thn : exp, els : exp, id : std/core/types/int) -> exp;
  pub con ForE[287,3,287,6](v: varName, from: exp, body: exp, id: std/core/types/int){0,4,8} : (v : varName, from : exp, body : exp, id : std/core/types/int) -> exp;
  pub con SeqE[288,3,288,6](first: exp, second: exp, id: std/core/types/int){0,3,8} : (first : exp, second : exp, id : std/core/types/int) -> exp;
  pub con PrintE[289,3,289,8](e: exp, id: std/core/types/int){0,2,8} : (e : exp, id : std/core/types/int) -> exp;
};
pub alias store[272,1,272,41] = (std/data/hashmap/hash-map :: (V, V) -> V)<varName,absValue> = 1;

// Operations:
// ```koka
// fun getAbstractValue
// fun setAbstractValue
// fun getPaths
// fun setPaths
// fun getOutputStore
// fun setOutputStore
// fun getInputStore
// fun setInputStore
// fun getQueryCondition
// fun setQueryCondition
// fun getDataDependence
// fun setDataDependence
// fun getIteratorContext
// fun setIteratorContext
// fun getTraversalSummary
// fun setTraversalSummary
// ```
pub recursive effect type attrGrammar[361,1,361,18] <(e :: E),a> :: (E, V) -> V {
  pub con @Hnd-attrGrammar[361,1,361,18](@cfc: std/core/types/int, @fun-getAbstractValue: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(attrGrammar :: (E, V) -> V),(e :: E),a>, @fun-getDataDependence: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(attrGrammar :: (E, V) -> V),(e :: E),a>, @fun-getInputStore: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(store == 1 (std/data/hashmap/hash-map :: (V, V) -> V)<varName,absValue>),(attrGrammar :: (E, V) -> V),(e :: E),a>, @fun-getIteratorContext: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>, @fun-getOutputStore: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(store == 1 (std/data/hashmap/hash-map :: (V, V) -> V)<varName,absValue>),(attrGrammar :: (E, V) -> V),(e :: E),a>, @fun-getPaths: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>, @fun-getQueryCondition: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(attrGrammar :: (E, V) -> V),(e :: E),a>, @fun-getTraversalSummary: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>, @fun-setAbstractValue: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, @fun-setDataDependence: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, @fun-setInputStore: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(store == 1 (std/data/hashmap/hash-map :: (V, V) -> V)<varName,absValue>),(),(attrGrammar :: (E, V) -> V),(e :: E),a>, @fun-setIteratorContext: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, @fun-setOutputStore: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(store == 1 (std/data/hashmap/hash-map :: (V, V) -> V)<varName,absValue>),(),(attrGrammar :: (E, V) -> V),(e :: E),a>, @fun-setPaths: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, @fun-setQueryCondition: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, @fun-setTraversalSummary: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>){0,17,8} : forall<(e :: E),a> (std/core/types/int, (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(attrGrammar :: (E, V) -> V),(e :: E),a>, (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(attrGrammar :: (E, V) -> V),(e :: E),a>, (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(store == 1 (std/data/hashmap/hash-map :: (V, V) -> V)<varName,absValue>),(attrGrammar :: (E, V) -> V),(e :: E),a>, (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>, (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(store == 1 (std/data/hashmap/hash-map :: (V, V) -> V)<varName,absValue>),(attrGrammar :: (E, V) -> V),(e :: E),a>, (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>, (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(attrGrammar :: (E, V) -> V),(e :: E),a>, (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>, (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(store == 1 (std/data/hashmap/hash-map :: (V, V) -> V)<varName,absValue>),(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(store == 1 (std/data/hashmap/hash-map :: (V, V) -> V)<varName,absValue>),(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) -> (attrGrammar :: (E, V) -> V)<(e :: E),a>;
};

// Operations:
// ```koka
// fun modified
// ```
pub recursive effect type fixpoint[753,1,753,15] <(e :: E),a> :: (E, V) -> V {
  pub con @Hnd-fixpoint[753,1,753,15](@cfc: std/core/types/int, @fun-modified: (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<(),(fixpoint :: (E, V) -> V),(e :: E),a>){0,2,8} : forall<(e :: E),a> (std/core/types/int, (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<(),(fixpoint :: (E, V) -> V),(e :: E),a>) -> (fixpoint :: (E, V) -> V)<(e :: E),a>;
};

// Operations:
// ```koka
// ctl choose
// final ctl fail
// ```
pub recursive effect type nondet[381,1,381,13] <(e :: E),a> :: (E, V) -> V {
  pub con @Hnd-nondet[381,1,381,13](@cfc: std/core/types/int, @ctl-choose: forall<b> (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<b,b,b,(nondet :: (E, V) -> V),(e :: E),a>, @brk-fail: forall<b> (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<b,(nondet :: (E, V) -> V),(e :: E),a>){0,3,8} : forall<(e :: E),a> (std/core/types/int, forall<b> (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<b,b,b,(nondet :: (E, V) -> V),(e :: E),a>, forall<b> (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<b,(nondet :: (E, V) -> V),(e :: E),a>) -> (nondet :: (E, V) -> V)<(e :: E),a>;
};
 
//------------------------------
//#kki: declarations
 
// Automatically generated. Tests for the `StringLit` constructor of the `:literal` type.
pub fip fun is-stringLit[89,3,89,11] : (^ literal : literal) -> std/core/types/bool;
// Automatically generated. Tests for the `NumberLit` constructor of the `:literal` type.
pub fip fun is-numberLit[90,3,90,11] : (^ literal : literal) -> std/core/types/bool;
// Automatically generated. Tests for the `FNNamed` constructor of the `:fieldName` type.
pub fip fun is-fnnamed[46,3,46,9] : (^ fieldName : fieldName) -> std/core/types/bool;
// Automatically generated. Tests for the `FNL` constructor of the `:fieldName` type.
pub fip fun is-fnl[47,3,47,5] : (^ fieldName : fieldName) -> std/core/types/bool;
// Automatically generated. Tests for the `AndOp` constructor of the `:op` type.
pub fip fun is-andOp[116,3,116,7] : (^ op : op) -> std/core/types/bool;
// Automatically generated. Tests for the `NotOp` constructor of the `:op` type.
pub fip fun is-notOp[117,3,117,7] : (^ op : op) -> std/core/types/bool;
// Automatically generated. Tests for the `EqOp` constructor of the `:op` type.
pub fip fun is-eqOp[118,3,118,6] : (^ op : op) -> std/core/types/bool;
// Automatically generated. Tests for the `GtOp` constructor of the `:op` type.
pub fip fun is-gtOp[119,3,119,6] : (^ op : op) -> std/core/types/bool;
// Automatically generated. Tests for the `PlusOp` constructor of the `:op` type.
pub fip fun is-plusOp[120,3,120,8] : (^ op : op) -> std/core/types/bool;
// Automatically generated. Tests for the `AOTrue` constructor of the `:absOp` type.
pub fip fun is-aotrue[185,3,185,8] : (^ absOp : absOp) -> std/core/types/bool;
// Automatically generated. Tests for the `AOOp` constructor of the `:absOp` type.
pub fip fun is-aoop[186,3,186,6] : (^ absOp : absOp) -> std/core/types/bool;
// Automatically generated. Tests for the `AVBot` constructor of the `:absValue` type.
pub fip fun is-avbot[226,3,226,7] : (^ absValue : absValue) -> std/core/types/bool;
// Automatically generated. Tests for the `AVLit` constructor of the `:absValue` type.
pub fip fun is-avlit[227,3,227,7] : (^ absValue : absValue) -> std/core/types/bool;
// Automatically generated. Tests for the `AVOp` constructor of the `:absValue` type.
pub fip fun is-avop[228,3,228,6] : (^ absValue : absValue) -> std/core/types/bool;
// Automatically generated. Tests for the `AVPath` constructor of the `:absValue` type.
pub fip fun is-avpath[229,3,229,8] : (^ absValue : absValue) -> std/core/types/bool;
// Automatically generated. Retrieves the `names` constructor field of the `:path` type.
pub  fun path/names[155,3,155,7] : (^ path : path) -> (std/core/types/list :: V -> V)<fieldName>;
// Automatically generated. Retrieves the `absOp` constructor field of the `:path` type.
pub  fun path/absOp[156,3,156,7] : (^ path : path) -> absOp;
// Automatically generated. Retrieves the `dependence` constructor field of the `:path` type.
pub  fun path/dependence[157,3,157,12] : (^ path : path) -> std/core/types/bool;
pub  fun path/@copy[154,8,154,11] : (@this : path, names : (std/core/types/@optional :: V -> V)<(std/core/types/list :: V -> V)<fieldName>>, absOp : (std/core/types/@optional :: V -> V)<absOp>, dependence : (std/core/types/@optional :: V -> V)<std/core/types/bool>) -> path;
// Automatically generated. Retrieves the `name` constructor field of the `:varName` type.
pub  fun varName/name[73,3,73,6] : (^ varName : varName) -> std/core/types/string;
pub  fun varName/@copy[72,8,72,14] : (@this : varName, name : (std/core/types/@optional :: V -> V)<std/core/types/string>) -> varName;
// Automatically generated. Retrieves the `id` constructor field of the `:exp` type.
pub  fun exp/id[279,9,279,10] : (^ exp : exp) -> std/core/types/int;
// Automatically generated. Tests for the `NullE` constructor of the `:exp` type.
pub fip fun is-nullE[279,3,279,7] : (^ exp : exp) -> std/core/types/bool;
// Automatically generated. Tests for the `LitE` constructor of the `:exp` type.
pub fip fun is-litE[280,3,280,6] : (^ exp : exp) -> std/core/types/bool;
// Automatically generated. Tests for the `RootE` constructor of the `:exp` type.
pub fip fun is-rootE[281,3,281,7] : (^ exp : exp) -> std/core/types/bool;
// Automatically generated. Tests for the `DotE` constructor of the `:exp` type.
pub fip fun is-dotE[282,3,282,6] : (^ exp : exp) -> std/core/types/bool;
// Automatically generated. Tests for the `OpE` constructor of the `:exp` type.
pub fip fun is-opE[283,3,283,5] : (^ exp : exp) -> std/core/types/bool;
// Automatically generated. Tests for the `VarE` constructor of the `:exp` type.
pub fip fun is-varE[284,3,284,6] : (^ exp : exp) -> std/core/types/bool;
// Automatically generated. Tests for the `AsgnE` constructor of the `:exp` type.
pub fip fun is-asgnE[285,3,285,7] : (^ exp : exp) -> std/core/types/bool;
// Automatically generated. Tests for the `IfE` constructor of the `:exp` type.
pub fip fun is-ifE[286,3,286,5] : (^ exp : exp) -> std/core/types/bool;
// Automatically generated. Tests for the `ForE` constructor of the `:exp` type.
pub fip fun is-forE[287,3,287,6] : (^ exp : exp) -> std/core/types/bool;
// Automatically generated. Tests for the `SeqE` constructor of the `:exp` type.
pub fip fun is-seqE[288,3,288,6] : (^ exp : exp) -> std/core/types/bool;
// Automatically generated. Tests for the `PrintE` constructor of the `:exp` type.
pub fip fun is-printE[289,3,289,8] : (^ exp : exp) -> std/core/types/bool;
// Automatically generated. Retrieves the `@cfc` constructor field of the `:attrGrammar` type.
 fun attrGrammar/@cfc[361,1,361,18] : forall<(e :: E),a> (^ attrGrammar : (attrGrammar :: (E, V) -> V)<(e :: E),a>) -> std/core/types/int;
// Automatically generated. Retrieves the `@fun-getAbstractValue` constructor field of the `:attrGrammar` type.
 fun attrGrammar/@fun-getAbstractValue[362,7,362,42] : forall<(e :: E),a> (^ attrGrammar : (attrGrammar :: (E, V) -> V)<(e :: E),a>) -> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(attrGrammar :: (E, V) -> V),(e :: E),a>;
// Automatically generated. Retrieves the `@fun-getDataDependence` constructor field of the `:attrGrammar` type.
 fun attrGrammar/@fun-getDataDependence[372,7,372,39] : forall<(e :: E),a> (^ attrGrammar : (attrGrammar :: (E, V) -> V)<(e :: E),a>) -> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(attrGrammar :: (E, V) -> V),(e :: E),a>;
// Automatically generated. Retrieves the `@fun-getInputStore` constructor field of the `:attrGrammar` type.
 fun attrGrammar/@fun-getInputStore[368,7,368,36] : forall<(e :: E),a> (^ attrGrammar : (attrGrammar :: (E, V) -> V)<(e :: E),a>) -> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>;
// Automatically generated. Retrieves the `@fun-getIteratorContext` constructor field of the `:attrGrammar` type.
 fun attrGrammar/@fun-getIteratorContext[374,7,374,46] : forall<(e :: E),a> (^ attrGrammar : (attrGrammar :: (E, V) -> V)<(e :: E),a>) -> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>;
// Automatically generated. Retrieves the `@fun-getOutputStore` constructor field of the `:attrGrammar` type.
 fun attrGrammar/@fun-getOutputStore[366,7,366,37] : forall<(e :: E),a> (^ attrGrammar : (attrGrammar :: (E, V) -> V)<(e :: E),a>) -> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>;
// Automatically generated. Retrieves the `@fun-getPaths` constructor field of the `:attrGrammar` type.
 fun attrGrammar/@fun-getPaths[364,7,364,40] : forall<(e :: E),a> (^ attrGrammar : (attrGrammar :: (E, V) -> V)<(e :: E),a>) -> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>;
// Automatically generated. Retrieves the `@fun-getQueryCondition` constructor field of the `:attrGrammar` type.
 fun attrGrammar/@fun-getQueryCondition[370,7,370,40] : forall<(e :: E),a> (^ attrGrammar : (attrGrammar :: (E, V) -> V)<(e :: E),a>) -> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(attrGrammar :: (E, V) -> V),(e :: E),a>;
// Automatically generated. Retrieves the `@fun-getTraversalSummary` constructor field of the `:attrGrammar` type.
 fun attrGrammar/@fun-getTraversalSummary[376,7,376,51] : forall<(e :: E),a> (^ attrGrammar : (attrGrammar :: (E, V) -> V)<(e :: E),a>) -> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>;
// Automatically generated. Retrieves the `@fun-setAbstractValue` constructor field of the `:attrGrammar` type.
 fun attrGrammar/@fun-setAbstractValue[363,7,363,56] : forall<(e :: E),a> (^ attrGrammar : (attrGrammar :: (E, V) -> V)<(e :: E),a>) -> (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(),(attrGrammar :: (E, V) -> V),(e :: E),a>;
// Automatically generated. Retrieves the `@fun-setDataDependence` constructor field of the `:attrGrammar` type.
 fun attrGrammar/@fun-setDataDependence[373,7,373,55] : forall<(e :: E),a> (^ attrGrammar : (attrGrammar :: (E, V) -> V)<(e :: E),a>) -> (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(),(attrGrammar :: (E, V) -> V),(e :: E),a>;
// Automatically generated. Retrieves the `@fun-setInputStore` constructor field of the `:attrGrammar` type.
 fun attrGrammar/@fun-setInputStore[369,7,369,47] : forall<(e :: E),a> (^ attrGrammar : (attrGrammar :: (E, V) -> V)<(e :: E),a>) -> (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>;
// Automatically generated. Retrieves the `@fun-setIteratorContext` constructor field of the `:attrGrammar` type.
 fun attrGrammar/@fun-setIteratorContext[375,7,375,57] : forall<(e :: E),a> (^ attrGrammar : (attrGrammar :: (E, V) -> V)<(e :: E),a>) -> (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>;
// Automatically generated. Retrieves the `@fun-setOutputStore` constructor field of the `:attrGrammar` type.
 fun attrGrammar/@fun-setOutputStore[367,7,367,48] : forall<(e :: E),a> (^ attrGrammar : (attrGrammar :: (E, V) -> V)<(e :: E),a>) -> (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>;
// Automatically generated. Retrieves the `@fun-setPaths` constructor field of the `:attrGrammar` type.
 fun attrGrammar/@fun-setPaths[365,7,365,51] : forall<(e :: E),a> (^ attrGrammar : (attrGrammar :: (E, V) -> V)<(e :: E),a>) -> (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>;
// Automatically generated. Retrieves the `@fun-setQueryCondition` constructor field of the `:attrGrammar` type.
 fun attrGrammar/@fun-setQueryCondition[371,7,371,51] : forall<(e :: E),a> (^ attrGrammar : (attrGrammar :: (E, V) -> V)<(e :: E),a>) -> (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(),(attrGrammar :: (E, V) -> V),(e :: E),a>;
// Automatically generated. Retrieves the `@fun-setTraversalSummary` constructor field of the `:attrGrammar` type.
 fun attrGrammar/@fun-setTraversalSummary[377,7,377,64] : forall<(e :: E),a> (^ attrGrammar : (attrGrammar :: (E, V) -> V)<(e :: E),a>) -> (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>;
// Automatically generated. Retrieves the `@cfc` constructor field of the `:fixpoint` type.
 fun fixpoint/@cfc[753,1,753,15] : forall<(e :: E),a> (^ fixpoint : (fixpoint :: (E, V) -> V)<(e :: E),a>) -> std/core/types/int;
// Automatically generated. Retrieves the `@fun-modified` constructor field of the `:fixpoint` type.
 fun fixpoint/@fun-modified[754,7,754,20] : forall<(e :: E),a> (^ fixpoint : (fixpoint :: (E, V) -> V)<(e :: E),a>) -> (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<(),(fixpoint :: (E, V) -> V),(e :: E),a>;
// Automatically generated. Retrieves the `@cfc` constructor field of the `:nondet` type.
 fun nondet/@cfc[381,1,381,13] : forall<(e :: E),a> (^ nondet : (nondet :: (E, V) -> V)<(e :: E),a>) -> std/core/types/int;
// Automatically generated. Retrieves the `@ctl-choose` constructor field of the `:nondet` type.
 fun nondet/@ctl-choose[382,7,382,27] : forall<(e :: E),a,b> (^ nondet : (nondet :: (E, V) -> V)<(e :: E),a>) -> (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<b,b,b,(nondet :: (E, V) -> V),(e :: E),a>;
// Automatically generated. Retrieves the `@brk-fail` constructor field of the `:nondet` type.
 fun nondet/@brk-fail[383,13,383,21] : forall<(e :: E),a,b> (^ nondet : (nondet :: (E, V) -> V)<(e :: E),a>) -> (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<b,(nondet :: (E, V) -> V),(e :: E),a>;
pub  fun hashset/list[7,5,7,16] : forall<a> (set : (std/data/hashset/hash-set :: V -> V)<a>) -> (std/core/types/list :: V -> V)<a>;
pub  fun fieldName/show[58,5,58,18] : (fieldName : fieldName) -> std/core/types/string;
pub  fun varName/show[80,5,80,16] : (varName : varName) -> std/core/types/string;
pub  fun op/show[134,5,134,11] : (op : op) -> std/core/types/string;
pub  fun hashset/show[19,5,19,16] : forall<a> (set : (std/data/hashset/hash-set :: V -> V)<a>, ?show : (a) -> std/core/types/string) -> std/core/types/string;
pub  fun literal/show[101,5,101,16] : (lit : literal) -> std/core/types/string;
pub  fun absOp/showDiv[202,5,202,17] : (absOp : absOp) -> <(std/core/types/div :: X)> std/core/types/string;
pub  fun absValue/showDiv[246,5,246,20] : (absValue : absValue) -> <(std/core/types/div :: X)> std/core/types/string;
pub  fun path/showDiv[168,5,168,16] : (path : path) -> <(std/core/types/div :: X)> std/core/types/string;
pub  fun absOp/show[209,5,209,14] : (absOp : absOp) -> std/core/types/string;
pub  fun absValue/show[255,5,255,17] : (absValue : absValue) -> std/core/types/string;
pub  fun exp/show[292,5,292,12] : (exp : exp) -> std/core/types/string;
pub  fun hashmap/show[39,5,39,16] : forall<a,b> (map : (std/data/hashmap/hash-map :: (V, V) -> V)<a,b>, ?key/show : (a) -> std/core/types/string, ?value/show : (b) -> std/core/types/string) -> std/core/types/string;
pub  fun path/show[172,5,172,13] : (path : path) -> std/core/types/string;
pub  fun store/show[274,5,274,14] : (store : store) -> std/core/types/string;
pub  fun op/(==)[123,5,123,11] : (a : op, b : op) -> std/core/types/bool;
pub  fun hashset/(==)[15,5,15,16] : forall<a> (a : (std/data/hashset/hash-set :: V -> V)<a>, b : (std/data/hashset/hash-set :: V -> V)<a>, ?(==) : (a, a) -> std/core/types/bool) -> std/core/types/bool;
pub  fun literal/(==)[93,5,93,16] : (a : literal, b : literal) -> std/core/types/bool;
pub  fun fieldName/(==)[50,5,50,18] : (a : fieldName, b : fieldName) -> std/core/types/bool;
pub  fun absOp/eqDiv[189,5,189,15] : (a : absOp, b : absOp) -> <(std/core/types/div :: X)> std/core/types/bool;
pub  fun absValue/eqDiv[232,5,232,18] : (a : absValue, b : absValue) -> <(std/core/types/div :: X)> std/core/types/bool;
pub  fun path/eqDiv[160,5,160,14] : (a : path, b : path) -> <(std/core/types/div :: X)> std/core/types/bool;
pub  fun absOp/(==)[198,5,198,14] : (a : absOp, b : absOp) -> std/core/types/bool;
pub  fun absValue/(==)[242,5,242,17] : (a : absValue, b : absValue) -> std/core/types/bool;
pub  fun varName/(==)[76,5,76,16] : (a : varName, b : varName) -> std/core/types/bool;
pub  fun exp/eqDiv[324,5,324,13] : (a : exp, b : exp) -> <(std/core/types/div :: X)> std/core/types/bool;
pub  fun exp/(==)[356,5,356,12] : (a : exp, b : exp) -> std/core/types/bool;
pub  fun hashmap/(==)[27,5,27,16] : forall<a,b> (a : (std/data/hashmap/hash-map :: (V, V) -> V)<a,b>, b : (std/data/hashmap/hash-map :: (V, V) -> V)<a,b>, ?(==) : (a, a) -> std/core/types/bool, ?hash : (a, std/core/types/int64) -> std/core/types/int, ?value/(==) : (b, b) -> std/core/types/bool) -> std/core/types/bool;
pub  fun path/(==)[164,5,164,13] : (a : path, b : path) -> std/core/types/bool;
pub  fun hashset/union[23,5,23,17] : forall<a> (a : (std/data/hashset/hash-set :: V -> V)<a>, b : (std/data/hashset/hash-set :: V -> V)<a>, ?(==) : (a, a) -> std/core/types/bool, ?hash : (a, std/core/types/int64) -> std/core/types/int) -> (std/data/hashset/hash-set :: V -> V)<a>;
pub  fun op/hash[144,5,144,11] : (op : op, x : std/core/types/int64) -> std/core/types/int;
pub  fun literal/hash[108,5,108,16] : (a : literal, x : std/core/types/int64) -> std/core/types/int;
pub  fun fieldName/hash[65,5,65,18] : (fieldName : fieldName, x : std/core/types/int64) -> std/core/types/int;
pub  fun absOp/divHash[213,5,213,17] : (absOp : absOp, x : std/core/types/int64) -> <(std/core/types/div :: X)> std/core/types/int;
pub  fun absValue/divHash[259,5,259,20] : (absValue : absValue, x : std/core/types/int64) -> <(std/core/types/div :: X)> std/core/types/int;
pub  fun path/divHash[176,5,176,16] : (path : path, x : std/core/types/int64) -> <(std/core/types/div :: X)> std/core/types/int;
pub  fun absOp/hash[221,5,221,14] : (absOp : absOp, x : std/core/types/int64) -> std/core/types/int;
pub  fun absValue/hash[268,5,268,17] : (absValue : absValue, x : std/core/types/int64) -> std/core/types/int;
pub  fun varName/hash[84,5,84,16] : (varName : varName, x : std/core/types/int64) -> std/core/types/int;
pub  fun exp/hash[308,5,308,12] : (exp : exp, x : std/core/types/int64) -> std/core/types/int;
pub  fun path/hash[180,5,180,13] : (path : path, x : std/core/types/int64) -> std/core/types/int;
// runtime tag for the effect `:attrGrammar`
pub val @tag-attrGrammar[361,1,361,18] : (std/core/hnd/htag :: ((E, V) -> V) -> V)<(attrGrammar :: (E, V) -> V)>;
// handler for the effect `:attrGrammar`
pub  fun @handle-attrGrammar[361,8,361,18] : forall<a,(e :: E),b> (hnd : (attrGrammar :: (E, V) -> V)<(e :: E),b>, ret : (res : a) -> (e :: E) b, action : () -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>|(e :: E)> a) -> (e :: E) b;
// select `getAbstractValue` operation out of effect `:attrGrammar`
pub  fun @select-getAbstractValue[362,7,362,42] : forall<(e :: E),a> (^ hnd : (attrGrammar :: (E, V) -> V)<(e :: E),a>) -> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(attrGrammar :: (E, V) -> V),(e :: E),a>;
// Call the `fun getAbstractValue` operation of the effect `:attrGrammar`
pub  fun getAbstractValue[362,7,362,22] : (exp : exp) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>> absValue;
// select `setAbstractValue` operation out of effect `:attrGrammar`
pub  fun @select-setAbstractValue[363,7,363,56] : forall<(e :: E),a> (^ hnd : (attrGrammar :: (E, V) -> V)<(e :: E),a>) -> (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(),(attrGrammar :: (E, V) -> V),(e :: E),a>;
// Call the `fun setAbstractValue` operation of the effect `:attrGrammar`
pub  fun setAbstractValue[363,7,363,22] : (exp : exp, absValue : absValue) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>> ();
// select `getPaths` operation out of effect `:attrGrammar`
pub  fun @select-getPaths[364,7,364,40] : forall<(e :: E),a> (^ hnd : (attrGrammar :: (E, V) -> V)<(e :: E),a>) -> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>;
// Call the `fun getPaths` operation of the effect `:attrGrammar`
pub  fun getPaths[364,7,364,14] : (exp : exp) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>> (std/data/hashset/hash-set :: V -> V)<path>;
// select `setPaths` operation out of effect `:attrGrammar`
pub  fun @select-setPaths[365,7,365,51] : forall<(e :: E),a> (^ hnd : (attrGrammar :: (E, V) -> V)<(e :: E),a>) -> (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>;
// Call the `fun setPaths` operation of the effect `:attrGrammar`
pub  fun setPaths[365,7,365,14] : (exp : exp, paths : (std/data/hashset/hash-set :: V -> V)<path>) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>> ();
// select `getOutputStore` operation out of effect `:attrGrammar`
pub  fun @select-getOutputStore[366,7,366,37] : forall<(e :: E),a> (^ hnd : (attrGrammar :: (E, V) -> V)<(e :: E),a>) -> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>;
// Call the `fun getOutputStore` operation of the effect `:attrGrammar`
pub  fun getOutputStore[366,7,366,20] : (exp : exp) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>> store;
// select `setOutputStore` operation out of effect `:attrGrammar`
pub  fun @select-setOutputStore[367,7,367,48] : forall<(e :: E),a> (^ hnd : (attrGrammar :: (E, V) -> V)<(e :: E),a>) -> (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>;
// Call the `fun setOutputStore` operation of the effect `:attrGrammar`
pub  fun setOutputStore[367,7,367,20] : (exp : exp, store : store) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>> ();
// select `getInputStore` operation out of effect `:attrGrammar`
pub  fun @select-getInputStore[368,7,368,36] : forall<(e :: E),a> (^ hnd : (attrGrammar :: (E, V) -> V)<(e :: E),a>) -> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>;
// Call the `fun getInputStore` operation of the effect `:attrGrammar`
pub  fun getInputStore[368,7,368,19] : (exp : exp) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>> store;
// select `setInputStore` operation out of effect `:attrGrammar`
pub  fun @select-setInputStore[369,7,369,47] : forall<(e :: E),a> (^ hnd : (attrGrammar :: (E, V) -> V)<(e :: E),a>) -> (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>;
// Call the `fun setInputStore` operation of the effect `:attrGrammar`
pub  fun setInputStore[369,7,369,19] : (exp : exp, store : store) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>> ();
// select `getQueryCondition` operation out of effect `:attrGrammar`
pub  fun @select-getQueryCondition[370,7,370,40] : forall<(e :: E),a> (^ hnd : (attrGrammar :: (E, V) -> V)<(e :: E),a>) -> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(attrGrammar :: (E, V) -> V),(e :: E),a>;
// Call the `fun getQueryCondition` operation of the effect `:attrGrammar`
pub  fun getQueryCondition[370,7,370,23] : (exp : exp) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>> absOp;
// select `setQueryCondition` operation out of effect `:attrGrammar`
pub  fun @select-setQueryCondition[371,7,371,51] : forall<(e :: E),a> (^ hnd : (attrGrammar :: (E, V) -> V)<(e :: E),a>) -> (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(),(attrGrammar :: (E, V) -> V),(e :: E),a>;
// Call the `fun setQueryCondition` operation of the effect `:attrGrammar`
pub  fun setQueryCondition[371,7,371,23] : (exp : exp, absOp : absOp) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>> ();
// select `getDataDependence` operation out of effect `:attrGrammar`
pub  fun @select-getDataDependence[372,7,372,39] : forall<(e :: E),a> (^ hnd : (attrGrammar :: (E, V) -> V)<(e :: E),a>) -> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(attrGrammar :: (E, V) -> V),(e :: E),a>;
// Call the `fun getDataDependence` operation of the effect `:attrGrammar`
pub  fun getDataDependence[372,7,372,23] : (exp : exp) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>> std/core/types/bool;
// select `setDataDependence` operation out of effect `:attrGrammar`
pub  fun @select-setDataDependence[373,7,373,55] : forall<(e :: E),a> (^ hnd : (attrGrammar :: (E, V) -> V)<(e :: E),a>) -> (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(),(attrGrammar :: (E, V) -> V),(e :: E),a>;
// Call the `fun setDataDependence` operation of the effect `:attrGrammar`
pub  fun setDataDependence[373,7,373,23] : (exp : exp, dependence : std/core/types/bool) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>> ();
// select `getIteratorContext` operation out of effect `:attrGrammar`
pub  fun @select-getIteratorContext[374,7,374,46] : forall<(e :: E),a> (^ hnd : (attrGrammar :: (E, V) -> V)<(e :: E),a>) -> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>;
// Call the `fun getIteratorContext` operation of the effect `:attrGrammar`
pub  fun getIteratorContext[374,7,374,24] : (exp : exp) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>> (std/core/types/list :: V -> V)<path>;
// select `setIteratorContext` operation out of effect `:attrGrammar`
pub  fun @select-setIteratorContext[375,7,375,57] : forall<(e :: E),a> (^ hnd : (attrGrammar :: (E, V) -> V)<(e :: E),a>) -> (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>;
// Call the `fun setIteratorContext` operation of the effect `:attrGrammar`
pub  fun setIteratorContext[375,7,375,24] : (exp : exp, paths : (std/core/types/list :: V -> V)<path>) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>> ();
// select `getTraversalSummary` operation out of effect `:attrGrammar`
pub  fun @select-getTraversalSummary[376,7,376,51] : forall<(e :: E),a> (^ hnd : (attrGrammar :: (E, V) -> V)<(e :: E),a>) -> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>;
// Call the `fun getTraversalSummary` operation of the effect `:attrGrammar`
pub  fun getTraversalSummary[376,7,376,25] : (exp : exp) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>> (std/data/hashset/hash-set :: V -> V)<path>;
// select `setTraversalSummary` operation out of effect `:attrGrammar`
pub  fun @select-setTraversalSummary[377,7,377,64] : forall<(e :: E),a> (^ hnd : (attrGrammar :: (E, V) -> V)<(e :: E),a>) -> (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>;
// Call the `fun setTraversalSummary` operation of the effect `:attrGrammar`
pub  fun setTraversalSummary[377,7,377,25] : (exp : exp, summary : (std/data/hashset/hash-set :: V -> V)<path>) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>> ();
// runtime tag for the effect `:nondet`
pub val @tag-nondet[381,1,381,13] : (std/core/hnd/htag :: ((E, V) -> V) -> V)<(nondet :: (E, V) -> V)>;
// handler for the effect `:nondet`
pub  fun @handle-nondet[381,8,381,13] : forall<a,(e :: E),b> (hnd : (nondet :: (E, V) -> V)<(e :: E),b>, ret : (res : a) -> (e :: E) b, action : () -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(nondet :: (E, V) -> V)>|(e :: E)> a) -> (e :: E) b;
// select `choose` operation out of effect `:nondet`
pub  fun @select-choose[382,7,382,27] : forall<a,(e :: E),b> (^ hnd : (nondet :: (E, V) -> V)<(e :: E),b>) -> (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<a,a,a,(nondet :: (E, V) -> V),(e :: E),b>;
// Call the `ctl choose` operation of the effect `:nondet`
pub  fun choose[382,7,382,12] : forall<a> (x : a, y : a) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(nondet :: (E, V) -> V)>> a;
// select `fail` operation out of effect `:nondet`
pub  fun @select-fail[383,13,383,21] : forall<a,(e :: E),b> (^ hnd : (nondet :: (E, V) -> V)<(e :: E),b>) -> (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<a,(nondet :: (E, V) -> V),(e :: E),b>;
// Call the `final ctl fail` operation of the effect `:nondet`
pub  fun fail[383,13,383,16] : forall<a> () -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(nondet :: (E, V) -> V)>> a;
pub  fun (..)[386,5,386,8] : (value : absValue, fieldName : fieldName) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> absValue;
pub  fun getOrThrow[398,5,398,14] : forall<a,b> (map : (std/data/hashmap/hash-map :: (V, V) -> V)<a,b>, key : a, ?(==) : (a, a) -> std/core/types/bool, ?hash : (a, std/core/types/int64) -> std/core/types/int) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> b;
pub  fun hash-map/insert[405,5,405,19] : forall<a,b> (map : (std/data/hashmap/hash-map :: (V, V) -> V)<a,b>, key : a, value : b, ?(==) : (a, a) -> std/core/types/bool, ?hash : (a, std/core/types/int64) -> std/core/types/int) -> (std/data/hashmap/hash-map :: (V, V) -> V)<a,b>;
pub  fun hash-set/insert[420,5,420,19] : forall<a> (set : (std/data/hashset/hash-set :: V -> V)<a>, x : a, ?(==) : (a, a) -> std/core/types/bool, ?hash : (a, std/core/types/int64) -> std/core/types/int) -> (std/data/hashset/hash-set :: V -> V)<a>;
// monadic lift
 fun hashmap/@mlift-insertAll@11133[1,0,1,0] : forall<(h :: H),a,b> (@y-x10311 : (std/data/hashmap/hash-map :: (V, V) -> V)<a,b>, key : a, result : (std/core/types/local-var :: (H, V) -> V)<(h :: H),(std/data/hashmap/hash-map :: (V, V) -> V)<a,b>>, ?(==) : (a, a) -> std/core/types/bool, ?hash : (a, std/core/types/int64) -> std/core/types/int, @c-x10313 : b) -> ();
// monadic lift
 fun hashmap/@mlift-insertAll@11134[1,0,1,0] : forall<(h :: H),a,b> (b : (std/data/hashmap/hash-map :: (V, V) -> V)<a,b>, key : a, result : (std/core/types/local-var :: (H, V) -> V)<(h :: H),(std/data/hashmap/hash-map :: (V, V) -> V)<a,b>>, ?(==) : (a, a) -> std/core/types/bool, ?hash : (a, std/core/types/int64) -> std/core/types/int, @y-x10311 : (std/data/hashmap/hash-map :: (V, V) -> V)<a,b>) -> <(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/div :: X)> ();
// monadic lift
 fun hashmap/@mlift-insertAll@11135[1,0,1,0] : forall<(h :: H),a,b> (result : (std/core/types/local-var :: (H, V) -> V)<(h :: H),(std/data/hashmap/hash-map :: (V, V) -> V)<a,b>>, wild_ : ()) -> <(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>> (std/data/hashmap/hash-map :: (V, V) -> V)<a,b>;
pub  fun hashmap/insertAll[409,5,409,21] : forall<a,b> (a : (std/data/hashmap/hash-map :: (V, V) -> V)<a,b>, b : (std/data/hashmap/hash-map :: (V, V) -> V)<a,b>, ?(==) : (a, a) -> std/core/types/bool, ?hash : (a, std/core/types/int64) -> std/core/types/int) -> (std/core/pure :: E) (std/data/hashmap/hash-map :: (V, V) -> V)<a,b>;
pub  fun hashset/singleton[424,5,424,21] : forall<a> (x : a, ?(==) : (a, a) -> std/core/types/bool, ?hash : (a, std/core/types/int64) -> std/core/types/int) -> (std/data/hashset/hash-set :: V -> V)<a>;
pub  fun applyOp[394,5,394,11] : (op : op, a : absValue, b : absValue) -> absValue;
pub  fun extractPaths[442,5,442,16] : (absValue : absValue) -> (std/data/hashset/hash-set :: V -> V)<path>;
// monadic lift
 fun @mlift-updateInputStore@11136[1,0,1,0] : (s : exp, @y-x10327 : (std/data/hashmap/hash-map :: (V, V) -> V)<varName,absValue>) -> <(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>> ();
// monadic lift
 fun @mlift-updateInputStore@11137[1,0,1,0] : (inputStorePlusV : (std/data/hashmap/hash-map :: (V, V) -> V)<varName,absValue>, s : exp, @y-x10326 : store) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> ();
// monadic lift
 fun @mlift-updateInputStore@11138[1,0,1,0] : (inputStore : store, s : exp, v : varName, @y-x10324 : absValue) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>,(std/core/types/div :: X)> ();
// monadic lift
 fun @mlift-updateInputStore@11139[1,0,1,0] : (inputStore : store, s : exp, v : varName, @y-x10323 : absValue) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/div :: X)> ();
// monadic lift
 fun @mlift-updateInputStore@11140[1,0,1,0] : (e : exp, inputStore : store, s : exp, v : varName, wild_@0 : ()) -> <(std/core/pure :: E),(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>> ();
// monadic lift
 fun @mlift-updateInputStore@11141[1,0,1,0] : (s2 : exp, @y-x10331 : store) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> ();
// monadic lift
 fun @mlift-updateInputStore@11142[1,0,1,0] : (s1 : exp, s2 : exp, wild_@1 : ()) -> <(std/core/pure :: E),(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>> ();
// monadic lift
 fun @mlift-updateInputStore@11143[1,0,1,0] : (e2 : exp, inputStore : store, wild_@2 : ()) -> <(std/core/pure :: E),(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>> ();
// monadic lift
 fun @mlift-updateInputStore@11144[1,0,1,0] : (inputStore : store, s2@0 : exp, wild_@4 : ()) -> <(std/core/pure :: E),(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>> ();
// monadic lift
 fun @mlift-updateInputStore@11145[1,0,1,0] : (inputStore : store, s1@0 : exp, s2@0 : exp, wild_@3 : ()) -> <(std/core/pure :: E),(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>> ();
// monadic lift
 fun @mlift-updateInputStore@11146[1,0,1,0] : (exp : exp, inputStore : store, wild_ : ()) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> ();
pub  fun updateInputStore[484,5,484,20] : (exp : exp, inputStore : store) -> <(std/core/pure :: E),(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>> ();
pub  fun isValidQueryCondition[512,5,512,25] : (exp : exp) -> std/core/types/bool;
// not entirely sure if this is what the notation means
pub  fun absOp/(&)[531,5,531,13] : (absOp : absOp, absValue : absValue) -> absOp;
pub  fun absValue/not[534,5,534,16] : (absValue : absValue) -> absValue;
// monadic lift
 fun @mlift-updateQueryCondition@11147[1,0,1,0] : (queryCondition : absOp, s2 : exp, @y-x10346 : absValue) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>> ();
// monadic lift
 fun @mlift-updateQueryCondition@11148[1,0,1,0] : (e : exp, queryCondition : absOp, s2 : exp, wild_@1 : ()) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>> ();
// monadic lift
 fun @mlift-updateQueryCondition@11149[1,0,1,0] : (e : exp, queryCondition : absOp, s1 : exp, s2 : exp, @y-x10344 : absValue) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>> ();
// monadic lift
 fun @mlift-updateQueryCondition@11150[1,0,1,0] : (queryCondition : absOp, s2 : exp, wild_@2 : ()) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>> ();
// monadic lift
 fun @mlift-updateQueryCondition@11151[1,0,1,0] : (e : exp, queryCondition : absOp, s1 : exp, s2 : exp, wild_@0 : ()) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>> ();
// monadic lift
 fun @mlift-updateQueryCondition@11152[1,0,1,0] : (e2 : exp, queryCondition : absOp, wild_@3 : ()) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>> ();
// monadic lift
 fun @mlift-updateQueryCondition@11153[1,0,1,0] : (queryCondition : absOp, s : exp, wild_@4 : ()) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>> ();
// monadic lift
 fun @mlift-updateQueryCondition@11154[1,0,1,0] : (queryCondition : absOp, s2@0 : exp, wild_@5 : ()) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>> ();
// monadic lift
 fun @mlift-updateQueryCondition@11155[1,0,1,0] : (exp : exp, queryCondition : absOp, wild_ : ()) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>> ();
pub  fun updateQueryCondition[538,5,538,24] : (exp : exp, queryCondition : absOp) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>> ();
// monadic lift
 fun @mlift-updateDataDependence@11156[1,0,1,0] : (dependence : std/core/types/bool, e2 : exp, wild_@0 : ()) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>> ();
// monadic lift
 fun @mlift-updateDataDependence@11157[1,0,1,0] : (dependence : std/core/types/bool, s2 : exp, wild_@2 : ()) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>> ();
// monadic lift
 fun @mlift-updateDataDependence@11158[1,0,1,0] : (dependence : std/core/types/bool, s1 : exp, s2 : exp, wild_@1 : ()) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>> ();
// monadic lift
 fun @mlift-updateDataDependence@11159[1,0,1,0] : (dependence : std/core/types/bool, s : exp, wild_@3 : ()) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>> ();
// monadic lift
 fun @mlift-updateDataDependence@11160[1,0,1,0] : (dependence : std/core/types/bool, s2@0 : exp, wild_@4 : ()) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>> ();
// monadic lift
 fun @mlift-updateDataDependence@11161[1,0,1,0] : (dependence : std/core/types/bool, exp : exp, wild_ : ()) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>> ();
pub  fun updateDataDependence[570,5,570,24] : (exp : exp, parentDependence : std/core/types/bool) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>> ();
pub  fun extends[601,5,601,11] : (absValue : absValue, paths : (std/core/types/list :: V -> V)<path>) -> std/core/types/bool;
// monadic lift
 fun @mlift-updateIteratorContext@11162[1,0,1,0] : (paths : (std/core/types/list :: V -> V)<path>, s : exp, @y-x10383 : absValue) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>> ();
// monadic lift
 fun @mlift-updateIteratorContext@11163[1,0,1,0] : (paths : (std/core/types/list :: V -> V)<path>, s : exp, @y-x10382 : absValue) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> ();
// monadic lift
 fun @mlift-updateIteratorContext@11164[1,0,1,0] : (e : exp, paths : (std/core/types/list :: V -> V)<path>, s : exp, @y-x10380 : absValue) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>> ();
// monadic lift
 fun @mlift-updateIteratorContext@11165[1,0,1,0] : (e : exp, paths : (std/core/types/list :: V -> V)<path>, s : exp, @y-x10379 : absValue) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> ();
// monadic lift
 fun @mlift-updateIteratorContext@11166[1,0,1,0] : (e : exp, paths : (std/core/types/list :: V -> V)<path>, s : exp, wild_@0 : ()) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>> ();
// monadic lift
 fun @mlift-updateIteratorContext@11167[1,0,1,0] : (paths : (std/core/types/list :: V -> V)<path>, s2 : exp, wild_@1 : ()) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>> ();
// monadic lift
 fun @mlift-updateIteratorContext@11168[1,0,1,0] : (e2 : exp, paths : (std/core/types/list :: V -> V)<path>, wild_@2 : ()) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>> ();
// monadic lift
 fun @mlift-updateIteratorContext@11169[1,0,1,0] : (paths : (std/core/types/list :: V -> V)<path>, s2@0 : exp, wild_@4 : ()) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>> ();
// monadic lift
 fun @mlift-updateIteratorContext@11170[1,0,1,0] : (paths : (std/core/types/list :: V -> V)<path>, s1@0 : exp, s2@0 : exp, wild_@3 : ()) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>> ();
// monadic lift
 fun @mlift-updateIteratorContext@11171[1,0,1,0] : (exp : exp, paths : (std/core/types/list :: V -> V)<path>, wild_ : ()) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> ();
pub  fun updateIteratorContext[610,5,610,25] : (exp : exp, paths : (std/core/types/list :: V -> V)<path>) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> ();
pub  fun getOrDefault[746,5,746,16] : forall<a,b> (map : (std/data/hashmap/hash-map :: (V, V) -> V)<a,b>, key : a, default : b, ?(==) : (a, a) -> std/core/types/bool, ?hash : (a, std/core/types/int64) -> std/core/types/int) -> b;
// monadic lift
 fun @mlift-updateAbstractValue@11172[1,0,1,0] : (f : fieldName, @y-x10399 : absValue) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> absValue;
// monadic lift
 fun @mlift-updateAbstractValue@11173[1,0,1,0] : (@y-x10402 : absValue, op : op, @y-x10404 : absValue) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> absValue;
// monadic lift
 fun @mlift-updateAbstractValue@11174[1,0,1,0] : (op : op, rhs : exp, @y-x10402 : absValue) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> absValue;
// monadic lift
 fun @mlift-updateAbstractValue@11175[1,0,1,0] : (v : varName, @y-x10406 : store) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> absValue;
// monadic lift
 fun @mlift-updateAbstractValue@11176[1,0,1,0] : (exp : exp, @c-x10407 : absValue) -> ();
pub  fun updateAbstractValue[428,5,428,23] : (exp : exp) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> ();
// monadic lift
 fun @mlift-updatePaths@11177[1,0,1,0] : (@y-x10411 : absValue) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> (std/data/hashset/hash-set :: V -> V)<path>;
// monadic lift
 fun @mlift-updatePaths@11178[1,0,1,0] : (@y-x10413 : absValue) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> (std/data/hashset/hash-set :: V -> V)<path>;
// monadic lift
 fun @mlift-updatePaths@11179[1,0,1,0] : (@y-x10415 : (std/data/hashset/hash-set :: V -> V)<path>, @y-x10417 : (std/data/hashset/hash-set :: V -> V)<path>) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> (std/data/hashset/hash-set :: V -> V)<path>;
// monadic lift
 fun @mlift-updatePaths@11180[1,0,1,0] : (rhs : exp, @y-x10415 : (std/data/hashset/hash-set :: V -> V)<path>) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> (std/data/hashset/hash-set :: V -> V)<path>;
// monadic lift
 fun @mlift-updatePaths@11181[1,0,1,0] : (@y-x10421 : (std/data/hashset/hash-set :: V -> V)<path>, @y-x10423 : (std/data/hashset/hash-set :: V -> V)<path>, @y-x10425 : (std/data/hashset/hash-set :: V -> V)<path>) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> (std/data/hashset/hash-set :: V -> V)<path>;
// monadic lift
 fun @mlift-updatePaths@11182[1,0,1,0] : (@y-x10421 : (std/data/hashset/hash-set :: V -> V)<path>, s2 : exp, @y-x10423 : (std/data/hashset/hash-set :: V -> V)<path>) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> (std/data/hashset/hash-set :: V -> V)<path>;
// monadic lift
 fun @mlift-updatePaths@11183[1,0,1,0] : (s1 : exp, s2 : exp, @y-x10421 : (std/data/hashset/hash-set :: V -> V)<path>) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> (std/data/hashset/hash-set :: V -> V)<path>;
// monadic lift
 fun @mlift-updatePaths@11184[1,0,1,0] : (@y-x10427 : (std/data/hashset/hash-set :: V -> V)<path>, @y-x10430 : absValue, @y-x10432 : (std/data/hashset/hash-set :: V -> V)<path>) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> (std/data/hashset/hash-set :: V -> V)<path>;
// monadic lift
 fun @mlift-updatePaths@11185[1,0,1,0] : (@y-x10427 : (std/data/hashset/hash-set :: V -> V)<path>, s : exp, @y-x10430 : absValue) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>> (std/data/hashset/hash-set :: V -> V)<path>;
// monadic lift
 fun @mlift-updatePaths@11186[1,0,1,0] : (@y-x10427 : (std/data/hashset/hash-set :: V -> V)<path>, s : exp, @y-x10429 : absValue) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> (std/data/hashset/hash-set :: V -> V)<path>;
// monadic lift
 fun @mlift-updatePaths@11187[1,0,1,0] : (e@1 : exp, s : exp, @y-x10427 : (std/data/hashset/hash-set :: V -> V)<path>) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> (std/data/hashset/hash-set :: V -> V)<path>;
// monadic lift
 fun @mlift-updatePaths@11188[1,0,1,0] : (@y-x10434 : (std/data/hashset/hash-set :: V -> V)<path>, @y-x10436 : (std/data/hashset/hash-set :: V -> V)<path>) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> (std/data/hashset/hash-set :: V -> V)<path>;
// monadic lift
 fun @mlift-updatePaths@11189[1,0,1,0] : (s2@0 : exp, @y-x10434 : (std/data/hashset/hash-set :: V -> V)<path>) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> (std/data/hashset/hash-set :: V -> V)<path>;
// monadic lift
 fun @mlift-updatePaths@11190[1,0,1,0] : (exp : exp, @c-x10439 : (std/data/hashset/hash-set :: V -> V)<path>) -> ();
pub  fun updatePaths[449,5,449,15] : (exp : exp) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> ();
pub  fun absValue/join[684,5,684,17] : (v1 : absValue, v2 : absValue) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> absValue;
// monadic lift
 fun @mlift-updateOutputStore@11191[1,0,1,0] : (@y-x10447 : store, v : varName, @y-x10450 : absValue) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>,(std/core/types/div :: X)> (std/data/hashmap/hash-map :: (V, V) -> V)<varName,absValue>;
// monadic lift
 fun @mlift-updateOutputStore@11192[1,0,1,0] : (@y-x10447 : store, previousV : absValue, v : varName, @y-x10449 : absValue) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/div :: X)> (std/data/hashmap/hash-map :: (V, V) -> V)<varName,absValue>;
// monadic lift
 fun @mlift-updateOutputStore@11193[1,0,1,0] : (e : exp, previousV : absValue, v : varName, @y-x10447 : store) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/div :: X)> (std/data/hashmap/hash-map :: (V, V) -> V)<varName,absValue>;
// monadic lift
 fun @mlift-updateOutputStore@11194[1,0,1,0] : (e : exp, exp : exp, v : varName, @y-x10445 : store) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/div :: X)> (std/data/hashmap/hash-map :: (V, V) -> V)<varName,absValue>;
// monadic lift
 fun @mlift-updateOutputStore@11195[1,0,1,0] : (@y-x10452 : store, @y-x10454 : store) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> (std/data/hashmap/hash-map :: (V, V) -> V)<varName,absValue>;
// monadic lift
 fun @mlift-updateOutputStore@11196[1,0,1,0] : (s2 : exp, @y-x10452 : store) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> (std/data/hashmap/hash-map :: (V, V) -> V)<varName,absValue>;
// monadic lift
 fun @mlift-updateOutputStore@11197[1,0,1,0] : (v@0 : varName, @y-x10457 : store) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> (std/data/hashmap/hash-map :: (V, V) -> V)<varName,absValue>;
// monadic lift
 fun @mlift-updateOutputStore@11198[1,0,1,0] : (exp : exp, @c-x10462 : (std/data/hashmap/hash-map :: (V, V) -> V)<varName,absValue>) -> ();
pub  fun updateOutputStore[469,5,469,21] : (exp : exp) -> <(std/core/pure :: E),(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>> ();
pub  fun firstOrThrow[641,5,641,16] : forall<a> (l : (std/core/types/list :: V -> V)<a>) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> a;
// monadic lift
 fun @mlift-iter@11199[1,0,1,0] : (latestIteratorContext : path, @y-x10468 : absOp) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>> (std/data/hashset/hash-set :: V -> V)<path>;
// monadic lift
 fun @mlift-iter@11200[1,0,1,0] : (exp : exp, @y-x10467 : (std/core/types/list :: V -> V)<path>) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>> (std/data/hashset/hash-set :: V -> V)<path>;
pub  fun iter[648,5,648,8] : (exp : exp) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>> (std/data/hashset/hash-set :: V -> V)<path>;
// monadic lift
 fun @mlift-updateTraversalSummary@11201[1,0,1,0] : (@y-x10476 : (std/core/types/list :: V -> V)<path>) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> (std/data/hashset/hash-set :: V -> V)<path>;
// monadic lift
 fun @mlift-updateTraversalSummary@11202[1,0,1,0] : (queryCondition : absOp, @y-x10475 : absValue) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> (std/data/hashset/hash-set :: V -> V)<path>;
// monadic lift
 fun @mlift-updateTraversalSummary@11203[1,0,1,0] : (@y-x10479 : (std/core/types/list :: V -> V)<path>) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> (std/data/hashset/hash-set :: V -> V)<path>;
// monadic lift
 fun @mlift-updateTraversalSummary@11204[1,0,1,0] : (queryCondition : absOp, @y-x10478 : (std/data/hashset/hash-set :: V -> V)<path>) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> (std/data/hashset/hash-set :: V -> V)<path>;
// monadic lift
 fun @mlift-updateTraversalSummary@11205[1,0,1,0] : (exp : exp, queryCondition : absOp, @y-x10473 : std/core/types/bool) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> (std/data/hashset/hash-set :: V -> V)<path>;
// monadic lift
 fun @mlift-updateTraversalSummary@11206[1,0,1,0] : (exp : exp, queryCondition : absOp) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> (std/data/hashset/hash-set :: V -> V)<path>;
// monadic lift
 fun @mlift-updateTraversalSummary@11207[1,0,1,0] : (@y-x10482 : (std/data/hashset/hash-set :: V -> V)<path>, @y-x10483 : (std/data/hashset/hash-set :: V -> V)<path>) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> (std/data/hashset/hash-set :: V -> V)<path>;
// monadic lift
 fun @mlift-updateTraversalSummary@11208[1,0,1,0] : (exp : exp, @y-x10482 : (std/data/hashset/hash-set :: V -> V)<path>) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> (std/data/hashset/hash-set :: V -> V)<path>;
// monadic lift
 fun @mlift-updateTraversalSummary@11209[1,0,1,0] : (@y-x10485 : (std/data/hashset/hash-set :: V -> V)<path>, @c-x10489 : (std/data/hashset/hash-set :: V -> V)<path>) -> (std/data/hashset/hash-set :: V -> V)<path>;
// monadic lift
 fun @mlift-updateTraversalSummary@11210[1,0,1,0] : (@y-x10485 : (std/data/hashset/hash-set :: V -> V)<path>, exp : exp, @y-x10487 : std/core/types/bool) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> (std/data/hashset/hash-set :: V -> V)<path>;
// monadic lift
 fun @mlift-updateTraversalSummary@11211[1,0,1,0] : (exp : exp, @y-x10485 : (std/data/hashset/hash-set :: V -> V)<path>) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> (std/data/hashset/hash-set :: V -> V)<path>;
// monadic lift
 fun @mlift-updateTraversalSummary@11212[1,0,1,0] : (exp : exp, @c-x10490 : (std/data/hashset/hash-set :: V -> V)<path>) -> ();
pub  fun updateTraversalSummary[660,5,660,26] : (exp : exp) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> ();
// monadic lift
 fun @mlift-updateSynthesizedAttrs@11213[1,0,1,0] : (exp : exp, wild_@1 : ()) -> <(std/core/pure :: E),(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>> ();
// monadic lift
 fun @mlift-updateSynthesizedAttrs@11214[1,0,1,0] : (exp : exp, wild_@0 : ()) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> ();
// monadic lift
 fun @mlift-updateSynthesizedAttrs@11215[1,0,1,0] : (exp : exp, wild_ : ()) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> ();
pub  fun updateSynthesizedAttrs[696,5,696,26] : (exp : exp) -> <(std/core/pure :: E),(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>> ();
// monadic lift
 fun @mlift-visit@11216[1,0,1,0] : forall<(e :: E)> (e2 : exp, f : (exp) -> (e :: E) (), wild_@0 : ()) -> (e :: E) ();
// monadic lift
 fun @mlift-visit@11217[1,0,1,0] : forall<(e :: E)> (f : (exp) -> (e :: E) (), s2 : exp, wild_@2 : ()) -> (e :: E) ();
// monadic lift
 fun @mlift-visit@11218[1,0,1,0] : forall<(e :: E)> (f : (exp) -> (e :: E) (), s1 : exp, s2 : exp, wild_@1 : ()) -> (e :: E) ();
// monadic lift
 fun @mlift-visit@11219[1,0,1,0] : forall<(e :: E)> (f : (exp) -> (e :: E) (), s : exp, wild_@3 : ()) -> (e :: E) ();
// monadic lift
 fun @mlift-visit@11220[1,0,1,0] : forall<(e :: E)> (f : (exp) -> (e :: E) (), s2@0 : exp, wild_@4 : ()) -> (e :: E) ();
// monadic lift
 fun @mlift-visit@11221[1,0,1,0] : forall<(e :: E)> (exp : exp, f : (exp) -> (e :: E) (), wild_ : ()) -> (e :: E) ();
pub  fun visit[708,5,708,9] : forall<(e :: E)> (exp : exp, f : (exp) -> (e :: E) ()) -> (e :: E) ();
// monadic lift
 fun @mlift-iterateAttributeGrammar@11222[1,0,1,0] : (exp : exp, wild_@2 : ()) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/div :: X)> ();
// monadic lift
 fun @mlift-iterateAttributeGrammar@11223[1,0,1,0] : (exp : exp, wild_@1 : ()) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/div :: X)> ();
// monadic lift
 fun @mlift-iterateAttributeGrammar@11224[1,0,1,0] : (exp : exp, wild_@0 : ()) -> <(std/core/pure :: E),(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>> ();
// monadic lift
 fun @mlift-iterateAttributeGrammar@11225[1,0,1,0] : (exp : exp, wild_ : ()) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> ();
pub  fun iterateAttributeGrammar[734,5,734,27] : (exp : exp) -> <(std/core/pure :: E),(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>> ();
// runtime tag for the effect `:fixpoint`
pub val @tag-fixpoint[753,1,753,15] : (std/core/hnd/htag :: ((E, V) -> V) -> V)<(fixpoint :: (E, V) -> V)>;
// handler for the effect `:fixpoint`
pub  fun @handle-fixpoint[753,8,753,15] : forall<a,(e :: E),b> (hnd : (fixpoint :: (E, V) -> V)<(e :: E),b>, ret : (res : a) -> (e :: E) b, action : () -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>|(e :: E)> a) -> (e :: E) b;
// select `modified` operation out of effect `:fixpoint`
pub  fun @select-modified[754,7,754,20] : forall<(e :: E),a> (^ hnd : (fixpoint :: (E, V) -> V)<(e :: E),a>) -> (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<(),(fixpoint :: (E, V) -> V),(e :: E),a>;
// Call the `fun modified` operation of the effect `:fixpoint`
pub  fun modified[754,7,754,14] : () -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>> ();
// monadic lift
 fun @mlift-update@11226[1,0,1,0] : forall<a,b> (key : a, map : (std/data/hashmap/hash-map :: (V, V) -> V)<a,b>, value : b, ?(==) : (a, a) -> std/core/types/bool, ?hash : (a, std/core/types/int64) -> std/core/types/int, wild_@1 : ()) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>> (std/data/hashmap/hash-map :: (V, V) -> V)<a,b>;
// monadic lift
 fun @mlift-update@11227[1,0,1,0] : forall<a,b> (key : a, map : (std/data/hashmap/hash-map :: (V, V) -> V)<a,b>, value : b, ?(==) : (a, a) -> std/core/types/bool, ?hash : (a, std/core/types/int64) -> std/core/types/int, ?show : (b) -> std/core/types/string, @y-x10518 : std/core/types/string) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>> (std/data/hashmap/hash-map :: (V, V) -> V)<a,b>;
// monadic lift
 fun @mlift-update@11228[1,0,1,0] : forall<a,b> (key : a, map : (std/data/hashmap/hash-map :: (V, V) -> V)<a,b>, value : b, ?(==) : (a, a) -> std/core/types/bool, ?hash : (a, std/core/types/int64) -> std/core/types/int, ?show : (b) -> std/core/types/string, @c-x10517 : std/core/types/bool) -> (std/data/hashmap/hash-map :: (V, V) -> V)<a,b>;
pub  fun update[757,5,757,10] : forall<a,b> (map : (std/data/hashmap/hash-map :: (V, V) -> V)<a,b>, key : a, value : b, ?(==) : (a, a) -> std/core/types/bool, ?hash : (a, std/core/types/int64) -> std/core/types/int, ?value/(==) : (b, b) -> std/core/types/bool, ?show : (b) -> std/core/types/string) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>> (std/data/hashmap/hash-map :: (V, V) -> V)<a,b>;
pub  fun mapShow[773,5,773,11] : forall<a,b> (map : (std/data/hashmap/hash-map :: (V, V) -> V)<a,b>, ?keyShow : (a) -> std/core/types/string, ?valueShow : (b) -> std/core/types/string) -> std/core/types/string;
// monadic lift
 fun @mlift-analyze@11229[1,0,1,0] : forall<(h :: H)> (exp : exp, @y-x10522 : (std/data/hashmap/hash-map :: (V, V) -> V)<exp,absValue>) -> <(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> absValue;
// monadic lift
 fun @mlift-analyze@11230[1,0,1,0] : forall<(h :: H)> (exp@0 : exp, @y-x10523 : (std/data/hashmap/hash-map :: (V, V) -> V)<exp,std/core/types/bool>) -> <(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> std/core/types/bool;
// monadic lift
 fun @mlift-analyze@11231[1,0,1,0] : forall<(h :: H)> (exp@1 : exp, @y-x10524 : (std/data/hashmap/hash-map :: (V, V) -> V)<exp,store>) -> <(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> store;
// monadic lift
 fun @mlift-analyze@11232[1,0,1,0] : forall<(h :: H)> (exp@2 : exp, @y-x10525 : (std/data/hashmap/hash-map :: (V, V) -> V)<exp,(std/core/types/list :: V -> V)<path>>) -> <(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> (std/core/types/list :: V -> V)<path>;
// monadic lift
 fun @mlift-analyze@11233[1,0,1,0] : forall<(h :: H)> (exp@3 : exp, @y-x10526 : (std/data/hashmap/hash-map :: (V, V) -> V)<exp,store>) -> <(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> store;
// monadic lift
 fun @mlift-analyze@11234[1,0,1,0] : forall<(h :: H)> (exp@4 : exp, @y-x10527 : (std/data/hashmap/hash-map :: (V, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>>) -> <(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> (std/data/hashset/hash-set :: V -> V)<path>;
// monadic lift
 fun @mlift-analyze@11235[1,0,1,0] : forall<(h :: H)> (exp@5 : exp, @y-x10528 : (std/data/hashmap/hash-map :: (V, V) -> V)<exp,absOp>) -> <(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> absOp;
// monadic lift
 fun @mlift-analyze@11236[1,0,1,0] : forall<(h :: H)> (exp@6 : exp, @y-x10529 : (std/data/hashmap/hash-map :: (V, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>>) -> <(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> (std/data/hashset/hash-set :: V -> V)<path>;
// monadic lift
 fun @mlift-analyze@11237[1,0,1,0] : forall<(h :: H)> (abstractValues : (std/core/types/local-var :: (H, V) -> V)<(h :: H),(std/data/hashmap/hash-map :: (V, V) -> V)<exp,absValue>>, @y-x10531 : (std/data/hashmap/hash-map :: (V, V) -> V)<exp,absValue>) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> ();
// monadic lift
 fun @mlift-analyze@11238[1,0,1,0] : forall<(h :: H)> (abstractValues : (std/core/types/local-var :: (H, V) -> V)<(h :: H),(std/data/hashmap/hash-map :: (V, V) -> V)<exp,absValue>>, absValue : absValue, exp@7 : exp, @y-x10530 : (std/data/hashmap/hash-map :: (V, V) -> V)<exp,absValue>) -> <(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> ();
// monadic lift
 fun @mlift-analyze@11239[1,0,1,0] : forall<(h :: H)> (dataDependences : (std/core/types/local-var :: (H, V) -> V)<(h :: H),(std/data/hashmap/hash-map :: (V, V) -> V)<exp,std/core/types/bool>>, @y-x10534 : (std/data/hashmap/hash-map :: (V, V) -> V)<exp,std/core/types/bool>) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> ();
// monadic lift
 fun @mlift-analyze@11240[1,0,1,0] : forall<(h :: H)> (dataDependences : (std/core/types/local-var :: (H, V) -> V)<(h :: H),(std/data/hashmap/hash-map :: (V, V) -> V)<exp,std/core/types/bool>>, dependence : std/core/types/bool, exp@8 : exp, @y-x10533 : (std/data/hashmap/hash-map :: (V, V) -> V)<exp,std/core/types/bool>) -> <(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> ();
// monadic lift
 fun @mlift-analyze@11241[1,0,1,0] : forall<(h :: H)> (inputStores : (std/core/types/local-var :: (H, V) -> V)<(h :: H),(std/data/hashmap/hash-map :: (V, V) -> V)<exp,store>>, @y-x10537 : (std/data/hashmap/hash-map :: (V, V) -> V)<exp,store>) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> ();
// monadic lift
 fun @mlift-analyze@11242[1,0,1,0] : forall<(h :: H)> (exp@9 : exp, inputStore : store, inputStores : (std/core/types/local-var :: (H, V) -> V)<(h :: H),(std/data/hashmap/hash-map :: (V, V) -> V)<exp,store>>, @y-x10536 : (std/data/hashmap/hash-map :: (V, V) -> V)<exp,store>) -> <(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> ();
// monadic lift
 fun @mlift-analyze@11243[1,0,1,0] : forall<(h :: H)> (iteratorContexts : (std/core/types/local-var :: (H, V) -> V)<(h :: H),(std/data/hashmap/hash-map :: (V, V) -> V)<exp,(std/core/types/list :: V -> V)<path>>>, @y-x10540 : (std/data/hashmap/hash-map :: (V, V) -> V)<exp,(std/core/types/list :: V -> V)<path>>) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> ();
// monadic lift
 fun @mlift-analyze@11244[1,0,1,0] : forall<(h :: H)> (exp@10 : exp, iteratorContext : (std/core/types/list :: V -> V)<path>, iteratorContexts : (std/core/types/local-var :: (H, V) -> V)<(h :: H),(std/data/hashmap/hash-map :: (V, V) -> V)<exp,(std/core/types/list :: V -> V)<path>>>, @y-x10539 : (std/data/hashmap/hash-map :: (V, V) -> V)<exp,(std/core/types/list :: V -> V)<path>>) -> <(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> ();
// monadic lift
 fun @mlift-analyze@11245[1,0,1,0] : forall<(h :: H)> (outputStores : (std/core/types/local-var :: (H, V) -> V)<(h :: H),(std/data/hashmap/hash-map :: (V, V) -> V)<exp,store>>, @y-x10543 : (std/data/hashmap/hash-map :: (V, V) -> V)<exp,store>) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> ();
// monadic lift
 fun @mlift-analyze@11246[1,0,1,0] : forall<(h :: H)> (exp@11 : exp, outputStore : store, outputStores : (std/core/types/local-var :: (H, V) -> V)<(h :: H),(std/data/hashmap/hash-map :: (V, V) -> V)<exp,store>>, @y-x10542 : (std/data/hashmap/hash-map :: (V, V) -> V)<exp,store>) -> <(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> ();
// monadic lift
 fun @mlift-analyze@11247[1,0,1,0] : forall<(h :: H)> (pathsByExp : (std/core/types/local-var :: (H, V) -> V)<(h :: H),(std/data/hashmap/hash-map :: (V, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>>>, @y-x10546 : (std/data/hashmap/hash-map :: (V, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>>) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> ();
// monadic lift
 fun @mlift-analyze@11248[1,0,1,0] : forall<(h :: H)> (exp@12 : exp, paths : (std/data/hashset/hash-set :: V -> V)<path>, pathsByExp : (std/core/types/local-var :: (H, V) -> V)<(h :: H),(std/data/hashmap/hash-map :: (V, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>>>, @y-x10545 : (std/data/hashmap/hash-map :: (V, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>>) -> <(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> ();
// monadic lift
 fun @mlift-analyze@11249[1,0,1,0] : forall<(h :: H)> (queryConditions : (std/core/types/local-var :: (H, V) -> V)<(h :: H),(std/data/hashmap/hash-map :: (V, V) -> V)<exp,absOp>>, @y-x10549 : (std/data/hashmap/hash-map :: (V, V) -> V)<exp,absOp>) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> ();
// monadic lift
 fun @mlift-analyze@11250[1,0,1,0] : forall<(h :: H)> (exp@13 : exp, queryCondition : absOp, queryConditions : (std/core/types/local-var :: (H, V) -> V)<(h :: H),(std/data/hashmap/hash-map :: (V, V) -> V)<exp,absOp>>, @y-x10548 : (std/data/hashmap/hash-map :: (V, V) -> V)<exp,absOp>) -> <(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> ();
// monadic lift
 fun @mlift-analyze@11251[1,0,1,0] : forall<(h :: H)> (traversalSummaries : (std/core/types/local-var :: (H, V) -> V)<(h :: H),(std/data/hashmap/hash-map :: (V, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>>>, @y-x10552 : (std/data/hashmap/hash-map :: (V, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>>) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> ();
// monadic lift
 fun @mlift-analyze@11252[1,0,1,0] : forall<(h :: H)> (exp@14 : exp, traversalSummaries : (std/core/types/local-var :: (H, V) -> V)<(h :: H),(std/data/hashmap/hash-map :: (V, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>>>, traversalSummary : (std/data/hashset/hash-set :: V -> V)<path>, @y-x10551 : (std/data/hashmap/hash-map :: (V, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>>) -> <(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> ();
// monadic lift
 fun @mlift-analyze@11253[1,0,1,0] : forall<(h :: H)> (root : exp, @c-x10563 : ()) -> (std/data/hashset/hash-set :: V -> V)<path>;
// monadic lift
 fun @mlift-analyze@11254[1,0,1,0] : forall<(h :: H)> (root : exp, @y-x10562 : std/core/types/int) -> <(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>> (std/data/hashset/hash-set :: V -> V)<path>;
// monadic lift
 fun @mlift-analyze@11255[1,0,1,0] : forall<(h :: H)> (@y-x10555 : std/core/types/int) -> <(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>> std/core/types/bool;
// monadic lift
 fun @mlift-analyze@11256[1,0,1,0] : forall<(h :: H)> (gas : (std/core/types/local-var :: (H, V) -> V)<(h :: H),std/core/types/int>, @y-x10554 : std/core/types/bool) -> <(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>> std/core/types/bool;
// monadic lift
 fun @mlift-analyze@11257[1,0,1,0] : forall<(h :: H)> (root : exp, wild_@0 : ()) -> <(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>> ();
// monadic lift
 fun @mlift-analyze@11258[1,0,1,0] : forall<(h :: H)> (gas : (std/core/types/local-var :: (H, V) -> V)<(h :: H),std/core/types/int>, root : exp, @y-x10558 : std/core/types/int) -> <(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>> ();
// monadic lift
 fun @mlift-analyze@11259[1,0,1,0] : forall<(h :: H)> (gas : (std/core/types/local-var :: (H, V) -> V)<(h :: H),std/core/types/int>, root : exp, wild_ : ()) -> <(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>> ();
// monadic lift
 fun @mlift-analyze@11260[1,0,1,0] : forall<(h :: H)> (gas : (std/core/types/local-var :: (H, V) -> V)<(h :: H),std/core/types/int>, root : exp, wild_@1 : ()) -> <(std/core/types/div :: X),(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>> (std/data/hashset/hash-set :: V -> V)<path>;
pub  fun analyze[777,5,777,11] : (root : exp) -> <(std/core/pure :: E)> (std/data/hashset/hash-set :: V -> V)<path>;
pub val line1[834,5,834,9] : exp;
pub val paperExample[835,5,835,16] : exp;
// monadic lift
 fun @mlift-check@11261[1,0,1,0] : forall<a,(e :: E)> (expected : a, ?(==) : (a, a) -> <(std/core/types/div :: X)> std/core/types/bool, ?show : (a) -> <(std/core/types/div :: X)> std/core/types/string, @y-x10579 : (std/core/exn/error :: V -> V)<a>) -> <(std/core/console/console :: X),(std/core/types/div :: X)|(e :: E)> ();
pub  fun check[860,5,860,9] : forall<a,(e :: E)> (expected : a, f : () -> <(std/core/console/console :: X),(std/core/pure :: E)|(e :: E)> a, ?(==) : (a, a) -> <(std/core/types/div :: X)> std/core/types/bool, ?kk-file-line : std/core/types/string, ?show : (a) -> <(std/core/types/div :: X)> std/core/types/string) -> <(std/core/console/console :: X),(std/core/types/div :: X)|(e :: E)> ();
// monadic lift
 fun @mlift-main@11262[1,0,1,0] : (@y-x10582 : (std/data/hashset/hash-set :: V -> V)<path>) -> <(std/core/pure :: E)> ();
pub  fun main[866,5,866,8] : () -> <(std/core/pure :: E),(std/core/console/console :: X)> ();
 
//------------------------------
//#kki: external declarations
 
 
//------------------------------
//#kki: inline definitions
 
//.inline-section
specialize "*"  fun analyze // inline size: 1
  = fn<(std/core/pure :: E)>(root: exp){
    std/core/types/@open<(std/core/types/total :: E),<(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(action : forall<(h :: H)> () -> <(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> (std/data/hashset/hash-set :: V -> V)<path>) -> (() -> <(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> (std/data/hashset/hash-set :: V -> V)<path>),(action : forall<(h :: H)> () -> <(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> (std/data/hashset/hash-set :: V -> V)<path>) -> <(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> (() -> <(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> (std/data/hashset/hash-set :: V -> V)<path>)>((std/core/types/unsafe-no-local-cast<(std/data/hashset/hash-set :: V -> V)<path>,<(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>>))((forall<(h :: H)> fn<<(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>>(){
      std/core/hnd/local-var<(std/data/hashmap/hash-map :: (V, V) -> V)<exp,absValue>,(std/data/hashset/hash-set :: V -> V)<path>,<(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(h :: H)>((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>>,(capacity : (std/core/types/@optional :: V -> V)<std/core/types/int>) -> (std/data/hashmap/hash-map :: (V, V) -> V)<exp,absValue>,(capacity : (std/core/types/@optional :: V -> V)<std/core/types/int>) -> <(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>> (std/data/hashmap/hash-map :: (V, V) -> V)<exp,absValue>>((std/data/hashmap/#thread/hash-map<exp,absValue>))((std/core/types/@None<std/core/types/int>))), (fn<<(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>>(abstractValues: (std/core/types/local-var :: (H, V) -> V)<(h :: H),(std/data/hashmap/hash-map :: (V, V) -> V)<exp,absValue>>){
          (std/core/hnd/local-var<(std/data/hashmap/hash-map :: (V, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>>,(std/data/hashset/hash-set :: V -> V)<path>,<(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(h :: H)>((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>>,(capacity : (std/core/types/@optional :: V -> V)<std/core/types/int>) -> (std/data/hashmap/hash-map :: (V, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>>,(capacity : (std/core/types/@optional :: V -> V)<std/core/types/int>) -> <(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>> (std/data/hashmap/hash-map :: (V, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>>>((std/data/hashmap/#thread/hash-map<exp,(std/data/hashset/hash-set :: V -> V)<path>>))((std/core/types/@None<std/core/types/int>))), (fn<<(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>>(pathsByExp: (std/core/types/local-var :: (H, V) -> V)<(h :: H),(std/data/hashmap/hash-map :: (V, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>>>){
              (std/core/hnd/local-var<(std/data/hashmap/hash-map :: (V, V) -> V)<exp,store>,(std/data/hashset/hash-set :: V -> V)<path>,<(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(h :: H)>((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>>,(capacity : (std/core/types/@optional :: V -> V)<std/core/types/int>) -> (std/data/hashmap/hash-map :: (V, V) -> V)<exp,store>,(capacity : (std/core/types/@optional :: V -> V)<std/core/types/int>) -> <(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>> (std/data/hashmap/hash-map :: (V, V) -> V)<exp,store>>((std/data/hashmap/#thread/hash-map<exp,store>))((std/core/types/@None<std/core/types/int>))), (fn<<(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>>(outputStores: (std/core/types/local-var :: (H, V) -> V)<(h :: H),(std/data/hashmap/hash-map :: (V, V) -> V)<exp,store>>){
                  (std/core/hnd/local-var<(std/data/hashmap/hash-map :: (V, V) -> V)<exp,store>,(std/data/hashset/hash-set :: V -> V)<path>,<(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(h :: H)>((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>>,(capacity : (std/core/types/@optional :: V -> V)<std/core/types/int>) -> (std/data/hashmap/hash-map :: (V, V) -> V)<exp,store>,(capacity : (std/core/types/@optional :: V -> V)<std/core/types/int>) -> <(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>> (std/data/hashmap/hash-map :: (V, V) -> V)<exp,store>>((std/data/hashmap/#thread/hash-map<exp,store>))((std/core/types/@None<std/core/types/int>))), (fn<<(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>>(inputStores: (std/core/types/local-var :: (H, V) -> V)<(h :: H),(std/data/hashmap/hash-map :: (V, V) -> V)<exp,store>>){
                      (std/core/hnd/local-var<(std/data/hashmap/hash-map :: (V, V) -> V)<exp,absOp>,(std/data/hashset/hash-set :: V -> V)<path>,<(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(h :: H)>((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>>,(capacity : (std/core/types/@optional :: V -> V)<std/core/types/int>) -> (std/data/hashmap/hash-map :: (V, V) -> V)<exp,absOp>,(capacity : (std/core/types/@optional :: V -> V)<std/core/types/int>) -> <(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>> (std/data/hashmap/hash-map :: (V, V) -> V)<exp,absOp>>((std/data/hashmap/#thread/hash-map<exp,absOp>))((std/core/types/@None<std/core/types/int>))), (fn<<(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>>(queryConditions: (std/core/types/local-var :: (H, V) -> V)<(h :: H),(std/data/hashmap/hash-map :: (V, V) -> V)<exp,absOp>>){
                          (std/core/hnd/local-var<(std/data/hashmap/hash-map :: (V, V) -> V)<exp,std/core/types/bool>,(std/data/hashset/hash-set :: V -> V)<path>,<(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(h :: H)>((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>>,(capacity : (std/core/types/@optional :: V -> V)<std/core/types/int>) -> (std/data/hashmap/hash-map :: (V, V) -> V)<exp,std/core/types/bool>,(capacity : (std/core/types/@optional :: V -> V)<std/core/types/int>) -> <(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>> (std/data/hashmap/hash-map :: (V, V) -> V)<exp,std/core/types/bool>>((std/data/hashmap/#thread/hash-map<exp,std/core/types/bool>))((std/core/types/@None<std/core/types/int>))), (fn<<(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>>(dataDependences: (std/core/types/local-var :: (H, V) -> V)<(h :: H),(std/data/hashmap/hash-map :: (V, V) -> V)<exp,std/core/types/bool>>){
                              (std/core/hnd/local-var<(std/data/hashmap/hash-map :: (V, V) -> V)<exp,(std/core/types/list :: V -> V)<path>>,(std/data/hashset/hash-set :: V -> V)<path>,<(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(h :: H)>((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>>,(capacity : (std/core/types/@optional :: V -> V)<std/core/types/int>) -> (std/data/hashmap/hash-map :: (V, V) -> V)<exp,(std/core/types/list :: V -> V)<path>>,(capacity : (std/core/types/@optional :: V -> V)<std/core/types/int>) -> <(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>> (std/data/hashmap/hash-map :: (V, V) -> V)<exp,(std/core/types/list :: V -> V)<path>>>((std/data/hashmap/#thread/hash-map<exp,(std/core/types/list :: V -> V)<path>>))((std/core/types/@None<std/core/types/int>))), (fn<<(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>>(iteratorContexts: (std/core/types/local-var :: (H, V) -> V)<(h :: H),(std/data/hashmap/hash-map :: (V, V) -> V)<exp,(std/core/types/list :: V -> V)<path>>>){
                                  (std/core/hnd/local-var<(std/data/hashmap/hash-map :: (V, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>>,(std/data/hashset/hash-set :: V -> V)<path>,<(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(h :: H)>((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>>,(capacity : (std/core/types/@optional :: V -> V)<std/core/types/int>) -> (std/data/hashmap/hash-map :: (V, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>>,(capacity : (std/core/types/@optional :: V -> V)<std/core/types/int>) -> <(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>> (std/data/hashmap/hash-map :: (V, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>>>((std/data/hashmap/#thread/hash-map<exp,(std/data/hashset/hash-set :: V -> V)<path>>))((std/core/types/@None<std/core/types/int>))), (fn<<(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>>(traversalSummaries: (std/core/types/local-var :: (H, V) -> V)<(h :: H),(std/data/hashmap/hash-map :: (V, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>>>){
                                      (std/core/hnd/local-var<std/core/types/bool,(std/data/hashset/hash-set :: V -> V)<path>,<(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(h :: H)>(std/core/types/True, (fn<<(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>>(updatedThisIteration: (std/core/types/local-var :: (H, V) -> V)<(h :: H),std/core/types/bool>){
                                          (main/@handle-fixpoint<(std/data/hashset/hash-set :: V -> V)<path>,<(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(std/data/hashset/hash-set :: V -> V)<path>>((main/@Hnd-fixpoint<<(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(std/data/hashset/hash-set :: V -> V)<path>>(1, (std/core/types/@open<(std/core/types/total :: E),<(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(op : () -> <(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> ()) -> (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<(),(fixpoint :: (E, V) -> V),<(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(std/data/hashset/hash-set :: V -> V)<path>>,(op : () -> <(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> ()) -> <(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<(),(fixpoint :: (E, V) -> V),<(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(std/data/hashset/hash-set :: V -> V)<path>>>((std/core/hnd/clause-tail0<<(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(std/data/hashset/hash-set :: V -> V)<path>,(fixpoint :: (E, V) -> V),()>))((fn<<(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>>(){
                                                (std/core/types/local-set<std/core/types/bool,<(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(h :: H)>(updatedThisIteration, std/core/types/True));
                                              }))))), (fn<<(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>>(@x: (std/data/hashset/hash-set :: V -> V)<path>){
                                              @x;
                                            }), (fn<<(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>>(){
                                              (main/@handle-attrGrammar<(std/data/hashset/hash-set :: V -> V)<path>,<(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(std/data/hashset/hash-set :: V -> V)<path>>((main/@Hnd-attrGrammar<<(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(std/data/hashset/hash-set :: V -> V)<path>>(1, (std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(op : (exp) -> <(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> absValue) -> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(attrGrammar :: (E, V) -> V),<(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(std/data/hashset/hash-set :: V -> V)<path>>,(op : (exp) -> <(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> absValue) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(attrGrammar :: (E, V) -> V),<(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(std/data/hashset/hash-set :: V -> V)<path>>>((std/core/hnd/clause-tail1<<(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),exp,absValue>))((fn<<(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>>(exp: exp){
                                                    (std/core/types/@open<(std/core/types/total :: E),<(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(map : (std/data/hashmap/hash-map :: (V, V) -> V)<exp,absValue>, key : exp, default : absValue, ?(==) : (exp, exp) -> std/core/types/bool, ?hash : (exp, std/core/types/int64) -> std/core/types/int) -> absValue,(map : (std/data/hashmap/hash-map :: (V, V) -> V)<exp,absValue>, key : exp, default : absValue, ?(==) : (exp, exp) -> std/core/types/bool, ?hash : (exp, std/core/types/int64) -> std/core/types/int) -> <(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> absValue>((fn(map: (std/data/hashmap/hash-map :: (V, V) -> V)<exp,absValue>, key: exp, default: absValue, @implicit/(==): (exp, exp) -> std/core/types/bool, @implicit/hash: (exp, std/core/types/int64) -> std/core/types/int){
                                                      (match ((std/data/hashmap/get<exp,absValue>(map, key, @implicit/hash, @implicit/(==)))) {
                                                        ((std/core/types/Just((value: absValue) : absValue) : (std/core/types/maybe :: V -> V)<absValue> ) as @pat: ((std/core/types/maybe :: V -> V)<absValue>))
                                                           -> value;
                                                        ((@skip std/core/types/Nothing() : (std/core/types/maybe :: V -> V)<absValue> ) as @pat@0: ((std/core/types/maybe :: V -> V)<absValue>))
                                                           -> default;
                                                      });
                                                    }))((std/core/types/local-get<(std/data/hashmap/hash-map :: (V, V) -> V)<exp,absValue>,(h :: H),<(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>>(abstractValues)), exp, main/AVBot, main/#exp/(==), main/#exp/hash));
                                                  }))), (std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(op : (exp) -> <(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> std/core/types/bool) -> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(attrGrammar :: (E, V) -> V),<(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(std/data/hashset/hash-set :: V -> V)<path>>,(op : (exp) -> <(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> std/core/types/bool) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(attrGrammar :: (E, V) -> V),<(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(std/data/hashset/hash-set :: V -> V)<path>>>((std/core/hnd/clause-tail1<<(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),exp,std/core/types/bool>))((fn<<(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>>(exp@0: exp){
                                                    (std/core/types/@open<(std/core/types/total :: E),<(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(map : (std/data/hashmap/hash-map :: (V, V) -> V)<exp,std/core/types/bool>, key : exp, default : std/core/types/bool, ?(==) : (exp, exp) -> std/core/types/bool, ?hash : (exp, std/core/types/int64) -> std/core/types/int) -> std/core/types/bool,(map : (std/data/hashmap/hash-map :: (V, V) -> V)<exp,std/core/types/bool>, key : exp, default : std/core/types/bool, ?(==) : (exp, exp) -> std/core/types/bool, ?hash : (exp, std/core/types/int64) -> std/core/types/int) -> <(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> std/core/types/bool>((fn(map@0: (std/data/hashmap/hash-map :: (V, V) -> V)<exp,std/core/types/bool>, key@0: exp, default@0: std/core/types/bool, @implicit/(@x@0==): (exp, exp) -> std/core/types/bool, @implicit/hash@0: (exp, std/core/types/int64) -> std/core/types/int){
                                                      (match ((std/data/hashmap/get<exp,std/core/types/bool>(map@0, key@0, @implicit/hash@0, @implicit/(@x@0==)))) {
                                                        ((std/core/types/Just((value@0: std/core/types/bool) : std/core/types/bool) : (std/core/types/maybe :: V -> V)<std/core/types/bool> ) as @pat@1: ((std/core/types/maybe :: V -> V)<std/core/types/bool>))
                                                           -> value@0;
                                                        ((@skip std/core/types/Nothing() : (std/core/types/maybe :: V -> V)<std/core/types/bool> ) as @pat@0@0: ((std/core/types/maybe :: V -> V)<std/core/types/bool>))
                                                           -> default@0;
                                                      });
                                                    }))((std/core/types/local-get<(std/data/hashmap/hash-map :: (V, V) -> V)<exp,std/core/types/bool>,(h :: H),<(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>>(dataDependences)), exp@0, std/core/types/False, main/#exp/(==), main/#exp/hash));
                                                  }))), (std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(op : (exp) -> <(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> store) -> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),<(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(std/data/hashset/hash-set :: V -> V)<path>>,(op : (exp) -> <(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> store) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),<(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(std/data/hashset/hash-set :: V -> V)<path>>>((std/core/hnd/clause-tail1<<(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),exp,store>))((fn<<(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>>(exp@1: exp){
                                                    (std/core/types/@open<(std/core/types/total :: E),<(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(map : (std/data/hashmap/hash-map :: (V, V) -> V)<exp,store>, key : exp, default : store, ?(==) : (exp, exp) -> std/core/types/bool, ?hash : (exp, std/core/types/int64) -> std/core/types/int) -> store,(map : (std/data/hashmap/hash-map :: (V, V) -> V)<exp,store>, key : exp, default : store, ?(==) : (exp, exp) -> std/core/types/bool, ?hash : (exp, std/core/types/int64) -> std/core/types/int) -> <(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> store>((fn(map@1: (std/data/hashmap/hash-map :: (V, V) -> V)<exp,store>, key@1: exp, default@1: store, @implicit/(@x@1==): (exp, exp) -> std/core/types/bool, @implicit/hash@1: (exp, std/core/types/int64) -> std/core/types/int){
                                                      (match ((std/data/hashmap/get<exp,store>(map@1, key@1, @implicit/hash@1, @implicit/(@x@1==)))) {
                                                        ((std/core/types/Just((value@1: store) : store) : (std/core/types/maybe :: V -> V)<store> ) as @pat@2: ((std/core/types/maybe :: V -> V)<store>))
                                                           -> value@1;
                                                        ((@skip std/core/types/Nothing() : (std/core/types/maybe :: V -> V)<store> ) as @pat@0@1: ((std/core/types/maybe :: V -> V)<store>))
                                                           -> default@1;
                                                      });
                                                    }))((std/core/types/local-get<(std/data/hashmap/hash-map :: (V, V) -> V)<exp,store>,(h :: H),<(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>>(inputStores)), exp@1, (std/core/types/@open<(std/core/types/total :: E),<(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(capacity : (std/core/types/@optional :: V -> V)<std/core/types/int>) -> (std/data/hashmap/hash-map :: (V, V) -> V)<varName,absValue>,(capacity : (std/core/types/@optional :: V -> V)<std/core/types/int>) -> <(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> (std/data/hashmap/hash-map :: (V, V) -> V)<varName,absValue>>((std/data/hashmap/#thread/hash-map<varName,absValue>))((std/core/types/@None<std/core/types/int>))), main/#exp/(==), main/#exp/hash));
                                                  }))), (std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(op : (exp) -> <(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> (std/core/types/list :: V -> V)<path>) -> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(attrGrammar :: (E, V) -> V),<(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(std/data/hashset/hash-set :: V -> V)<path>>,(op : (exp) -> <(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> (std/core/types/list :: V -> V)<path>) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(attrGrammar :: (E, V) -> V),<(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(std/data/hashset/hash-set :: V -> V)<path>>>((std/core/hnd/clause-tail1<<(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),exp,(std/core/types/list :: V -> V)<path>>))((fn<<(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>>(exp@2: exp){
                                                    (std/core/types/@open<(std/core/types/total :: E),<(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(map : (std/data/hashmap/hash-map :: (V, V) -> V)<exp,(std/core/types/list :: V -> V)<path>>, key : exp, default : (std/core/types/list :: V -> V)<path>, ?(==) : (exp, exp) -> std/core/types/bool, ?hash : (exp, std/core/types/int64) -> std/core/types/int) -> (std/core/types/list :: V -> V)<path>,(map : (std/data/hashmap/hash-map :: (V, V) -> V)<exp,(std/core/types/list :: V -> V)<path>>, key : exp, default : (std/core/types/list :: V -> V)<path>, ?(==) : (exp, exp) -> std/core/types/bool, ?hash : (exp, std/core/types/int64) -> std/core/types/int) -> <(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> (std/core/types/list :: V -> V)<path>>((fn(map@2: (std/data/hashmap/hash-map :: (V, V) -> V)<exp,(std/core/types/list :: V -> V)<path>>, key@2: exp, default@2: (std/core/types/list :: V -> V)<path>, @implicit/(@x@2==): (exp, exp) -> std/core/types/bool, @implicit/hash@2: (exp, std/core/types/int64) -> std/core/types/int){
                                                      (match ((std/data/hashmap/get<exp,(std/core/types/list :: V -> V)<path>>(map@2, key@2, @implicit/hash@2, @implicit/(@x@2==)))) {
                                                        ((std/core/types/Just((value@2: (std/core/types/list :: V -> V)<path>) : (std/core/types/list :: V -> V)<path>) : (std/core/types/maybe :: V -> V)<(std/core/types/list :: V -> V)<path>> ) as @pat@3: ((std/core/types/maybe :: V -> V)<(std/core/types/list :: V -> V)<path>>))
                                                           -> value@2;
                                                        ((@skip std/core/types/Nothing() : (std/core/types/maybe :: V -> V)<(std/core/types/list :: V -> V)<path>> ) as @pat@0@2: ((std/core/types/maybe :: V -> V)<(std/core/types/list :: V -> V)<path>>))
                                                           -> default@2;
                                                      });
                                                    }))((std/core/types/local-get<(std/data/hashmap/hash-map :: (V, V) -> V)<exp,(std/core/types/list :: V -> V)<path>>,(h :: H),<(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>>(iteratorContexts)), exp@2, (std/core/types/Nil<path>), main/#exp/(==), main/#exp/hash));
                                                  }))), (std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(op : (exp) -> <(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> store) -> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),<(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(std/data/hashset/hash-set :: V -> V)<path>>,(op : (exp) -> <(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> store) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),<(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(std/data/hashset/hash-set :: V -> V)<path>>>((std/core/hnd/clause-tail1<<(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),exp,store>))((fn<<(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>>(exp@3: exp){
                                                    (std/core/types/@open<(std/core/types/total :: E),<(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(map : (std/data/hashmap/hash-map :: (V, V) -> V)<exp,store>, key : exp, default : store, ?(==) : (exp, exp) -> std/core/types/bool, ?hash : (exp, std/core/types/int64) -> std/core/types/int) -> store,(map : (std/data/hashmap/hash-map :: (V, V) -> V)<exp,store>, key : exp, default : store, ?(==) : (exp, exp) -> std/core/types/bool, ?hash : (exp, std/core/types/int64) -> std/core/types/int) -> <(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> store>((fn(map@3: (std/data/hashmap/hash-map :: (V, V) -> V)<exp,store>, key@3: exp, default@3: store, @implicit/(@x@3==): (exp, exp) -> std/core/types/bool, @implicit/hash@3: (exp, std/core/types/int64) -> std/core/types/int){
                                                      (match ((std/data/hashmap/get<exp,store>(map@3, key@3, @implicit/hash@3, @implicit/(@x@3==)))) {
                                                        ((std/core/types/Just((value@3: store) : store) : (std/core/types/maybe :: V -> V)<store> ) as @pat@4: ((std/core/types/maybe :: V -> V)<store>))
                                                           -> value@3;
                                                        ((@skip std/core/types/Nothing() : (std/core/types/maybe :: V -> V)<store> ) as @pat@0@3: ((std/core/types/maybe :: V -> V)<store>))
                                                           -> default@3;
                                                      });
                                                    }))((std/core/types/local-get<(std/data/hashmap/hash-map :: (V, V) -> V)<exp,store>,(h :: H),<(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>>(outputStores)), exp@3, (std/core/types/@open<(std/core/types/total :: E),<(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(capacity : (std/core/types/@optional :: V -> V)<std/core/types/int>) -> (std/data/hashmap/hash-map :: (V, V) -> V)<varName,absValue>,(capacity : (std/core/types/@optional :: V -> V)<std/core/types/int>) -> <(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> (std/data/hashmap/hash-map :: (V, V) -> V)<varName,absValue>>((std/data/hashmap/#thread/hash-map<varName,absValue>))((std/core/types/@None<std/core/types/int>))), main/#exp/(==), main/#exp/hash));
                                                  }))), (std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(op : (exp) -> <(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> (std/data/hashset/hash-set :: V -> V)<path>) -> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),<(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(std/data/hashset/hash-set :: V -> V)<path>>,(op : (exp) -> <(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> (std/data/hashset/hash-set :: V -> V)<path>) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),<(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(std/data/hashset/hash-set :: V -> V)<path>>>((std/core/hnd/clause-tail1<<(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),exp,(std/data/hashset/hash-set :: V -> V)<path>>))((fn<<(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>>(exp@4: exp){
                                                    (std/core/types/@open<(std/core/types/total :: E),<(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(map : (std/data/hashmap/hash-map :: (V, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>>, key : exp, default : (std/data/hashset/hash-set :: V -> V)<path>, ?(==) : (exp, exp) -> std/core/types/bool, ?hash : (exp, std/core/types/int64) -> std/core/types/int) -> (std/data/hashset/hash-set :: V -> V)<path>,(map : (std/data/hashmap/hash-map :: (V, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>>, key : exp, default : (std/data/hashset/hash-set :: V -> V)<path>, ?(==) : (exp, exp) -> std/core/types/bool, ?hash : (exp, std/core/types/int64) -> std/core/types/int) -> <(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> (std/data/hashset/hash-set :: V -> V)<path>>((fn(map@4: (std/data/hashmap/hash-map :: (V, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>>, key@4: exp, default@4: (std/data/hashset/hash-set :: V -> V)<path>, @implicit/(@x@4==): (exp, exp) -> std/core/types/bool, @implicit/hash@4: (exp, std/core/types/int64) -> std/core/types/int){
                                                      (match ((std/data/hashmap/get<exp,(std/data/hashset/hash-set :: V -> V)<path>>(map@4, key@4, @implicit/hash@4, @implicit/(@x@4==)))) {
                                                        ((std/core/types/Just((value@4: (std/data/hashset/hash-set :: V -> V)<path>) : (std/data/hashset/hash-set :: V -> V)<path>) : (std/core/types/maybe :: V -> V)<(std/data/hashset/hash-set :: V -> V)<path>> ) as @pat@5: ((std/core/types/maybe :: V -> V)<(std/data/hashset/hash-set :: V -> V)<path>>))
                                                           -> value@4;
                                                        ((@skip std/core/types/Nothing() : (std/core/types/maybe :: V -> V)<(std/data/hashset/hash-set :: V -> V)<path>> ) as @pat@0@4: ((std/core/types/maybe :: V -> V)<(std/data/hashset/hash-set :: V -> V)<path>>))
                                                           -> default@4;
                                                      });
                                                    }))((std/core/types/local-get<(std/data/hashmap/hash-map :: (V, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>>,(h :: H),<(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>>(pathsByExp)), exp@4, (std/core/types/@open<(std/core/types/total :: E),<(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(capacity : (std/core/types/@optional :: V -> V)<std/core/types/int>) -> (std/data/hashset/hash-set :: V -> V)<path>,(capacity : (std/core/types/@optional :: V -> V)<std/core/types/int>) -> <(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> (std/data/hashset/hash-set :: V -> V)<path>>((std/data/hashset/#thread/hash-set<path>))((std/core/types/@None<std/core/types/int>))), main/#exp/(==), main/#exp/hash));
                                                  }))), (std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(op : (exp) -> <(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> absOp) -> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(attrGrammar :: (E, V) -> V),<(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(std/data/hashset/hash-set :: V -> V)<path>>,(op : (exp) -> <(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> absOp) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(attrGrammar :: (E, V) -> V),<(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(std/data/hashset/hash-set :: V -> V)<path>>>((std/core/hnd/clause-tail1<<(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),exp,absOp>))((fn<<(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>>(exp@5: exp){
                                                    (std/core/types/@open<(std/core/types/total :: E),<(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(map : (std/data/hashmap/hash-map :: (V, V) -> V)<exp,absOp>, key : exp, default : absOp, ?(==) : (exp, exp) -> std/core/types/bool, ?hash : (exp, std/core/types/int64) -> std/core/types/int) -> absOp,(map : (std/data/hashmap/hash-map :: (V, V) -> V)<exp,absOp>, key : exp, default : absOp, ?(==) : (exp, exp) -> std/core/types/bool, ?hash : (exp, std/core/types/int64) -> std/core/types/int) -> <(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> absOp>((fn(map@5: (std/data/hashmap/hash-map :: (V, V) -> V)<exp,absOp>, key@5: exp, default@5: absOp, @implicit/(@x@5==): (exp, exp) -> std/core/types/bool, @implicit/hash@5: (exp, std/core/types/int64) -> std/core/types/int){
                                                      (match ((std/data/hashmap/get<exp,absOp>(map@5, key@5, @implicit/hash@5, @implicit/(@x@5==)))) {
                                                        ((std/core/types/Just((value@5: absOp) : absOp) : (std/core/types/maybe :: V -> V)<absOp> ) as @pat@6: ((std/core/types/maybe :: V -> V)<absOp>))
                                                           -> value@5;
                                                        ((@skip std/core/types/Nothing() : (std/core/types/maybe :: V -> V)<absOp> ) as @pat@0@5: ((std/core/types/maybe :: V -> V)<absOp>))
                                                           -> default@5;
                                                      });
                                                    }))((std/core/types/local-get<(std/data/hashmap/hash-map :: (V, V) -> V)<exp,absOp>,(h :: H),<(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>>(queryConditions)), exp@5, main/AOTrue, main/#exp/(==), main/#exp/hash));
                                                  }))), (std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(op : (exp) -> <(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> (std/data/hashset/hash-set :: V -> V)<path>) -> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),<(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(std/data/hashset/hash-set :: V -> V)<path>>,(op : (exp) -> <(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> (std/data/hashset/hash-set :: V -> V)<path>) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),<(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(std/data/hashset/hash-set :: V -> V)<path>>>((std/core/hnd/clause-tail1<<(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),exp,(std/data/hashset/hash-set :: V -> V)<path>>))((fn<<(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>>(exp@6: exp){
                                                    (std/core/types/@open<(std/core/types/total :: E),<(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(map : (std/data/hashmap/hash-map :: (V, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>>, key : exp, default : (std/data/hashset/hash-set :: V -> V)<path>, ?(==) : (exp, exp) -> std/core/types/bool, ?hash : (exp, std/core/types/int64) -> std/core/types/int) -> (std/data/hashset/hash-set :: V -> V)<path>,(map : (std/data/hashmap/hash-map :: (V, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>>, key : exp, default : (std/data/hashset/hash-set :: V -> V)<path>, ?(==) : (exp, exp) -> std/core/types/bool, ?hash : (exp, std/core/types/int64) -> std/core/types/int) -> <(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> (std/data/hashset/hash-set :: V -> V)<path>>((fn(map@6: (std/data/hashmap/hash-map :: (V, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>>, key@6: exp, default@6: (std/data/hashset/hash-set :: V -> V)<path>, @implicit/(@x@6==): (exp, exp) -> std/core/types/bool, @implicit/hash@6: (exp, std/core/types/int64) -> std/core/types/int){
                                                      (match ((std/data/hashmap/get<exp,(std/data/hashset/hash-set :: V -> V)<path>>(map@6, key@6, @implicit/hash@6, @implicit/(@x@6==)))) {
                                                        ((std/core/types/Just((value@6: (std/data/hashset/hash-set :: V -> V)<path>) : (std/data/hashset/hash-set :: V -> V)<path>) : (std/core/types/maybe :: V -> V)<(std/data/hashset/hash-set :: V -> V)<path>> ) as @pat@7: ((std/core/types/maybe :: V -> V)<(std/data/hashset/hash-set :: V -> V)<path>>))
                                                           -> value@6;
                                                        ((@skip std/core/types/Nothing() : (std/core/types/maybe :: V -> V)<(std/data/hashset/hash-set :: V -> V)<path>> ) as @pat@0@6: ((std/core/types/maybe :: V -> V)<(std/data/hashset/hash-set :: V -> V)<path>>))
                                                           -> default@6;
                                                      });
                                                    }))((std/core/types/local-get<(std/data/hashmap/hash-map :: (V, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>>,(h :: H),<(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>>(traversalSummaries)), exp@6, (std/core/types/@open<(std/core/types/total :: E),<(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(capacity : (std/core/types/@optional :: V -> V)<std/core/types/int>) -> (std/data/hashset/hash-set :: V -> V)<path>,(capacity : (std/core/types/@optional :: V -> V)<std/core/types/int>) -> <(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> (std/data/hashset/hash-set :: V -> V)<path>>((std/data/hashset/#thread/hash-set<path>))((std/core/types/@None<std/core/types/int>))), main/#exp/(==), main/#exp/hash));
                                                  }))), (std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(op : (exp, absValue) -> <(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> ()) -> (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(),(attrGrammar :: (E, V) -> V),<(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(std/data/hashset/hash-set :: V -> V)<path>>,(op : (exp, absValue) -> <(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> ()) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(),(attrGrammar :: (E, V) -> V),<(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(std/data/hashset/hash-set :: V -> V)<path>>>((std/core/hnd/clause-tail2<<(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),exp,absValue,()>))((fn<<(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>>(exp@7: exp, absValue: absValue){
                                                    (std/core/types/local-set<(std/data/hashmap/hash-map :: (V, V) -> V)<exp,absValue>,<(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(h :: H)>(abstractValues, (std/core/types/@open<<(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>>,<(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(map : (std/data/hashmap/hash-map :: (V, V) -> V)<exp,absValue>, key : exp, value : absValue, ?(==) : (exp, exp) -> std/core/types/bool, ?hash : (exp, std/core/types/int64) -> std/core/types/int, ?value/(==) : (absValue, absValue) -> std/core/types/bool, ?show : (absValue) -> std/core/types/string) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>> (std/data/hashmap/hash-map :: (V, V) -> V)<exp,absValue>,(map : (std/data/hashmap/hash-map :: (V, V) -> V)<exp,absValue>, key : exp, value : absValue, ?(==) : (exp, exp) -> std/core/types/bool, ?hash : (exp, std/core/types/int64) -> std/core/types/int, ?value/(==) : (absValue, absValue) -> std/core/types/bool, ?show : (absValue) -> std/core/types/string) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> (std/data/hashmap/hash-map :: (V, V) -> V)<exp,absValue>>((main/update<exp,absValue>))((std/core/types/local-get<(std/data/hashmap/hash-map :: (V, V) -> V)<exp,absValue>,(h :: H),<(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>>(abstractValues)), exp@7, absValue, main/#exp/(==), main/#exp/hash, main/#absValue/(==), main/#absValue/show))));
                                                  }))), (std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(op : (exp, std/core/types/bool) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> ()) -> (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(),(attrGrammar :: (E, V) -> V),<(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(std/data/hashset/hash-set :: V -> V)<path>>,(op : (exp, std/core/types/bool) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> ()) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(),(attrGrammar :: (E, V) -> V),<(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(std/data/hashset/hash-set :: V -> V)<path>>>((std/core/hnd/clause-tail2<<(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),exp,std/core/types/bool,()>))((fn<<(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>>(exp@8: exp, dependence: std/core/types/bool){
                                                    (std/core/types/local-set<(std/data/hashmap/hash-map :: (V, V) -> V)<exp,std/core/types/bool>,<(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(h :: H)>(dataDependences, (std/core/types/@open<<(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>>,<(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(map : (std/data/hashmap/hash-map :: (V, V) -> V)<exp,std/core/types/bool>, key : exp, value : std/core/types/bool, ?(==) : (exp, exp) -> std/core/types/bool, ?hash : (exp, std/core/types/int64) -> std/core/types/int, ?value/(==) : (std/core/types/bool, std/core/types/bool) -> std/core/types/bool, ?show : (std/core/types/bool) -> std/core/types/string) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>> (std/data/hashmap/hash-map :: (V, V) -> V)<exp,std/core/types/bool>,(map : (std/data/hashmap/hash-map :: (V, V) -> V)<exp,std/core/types/bool>, key : exp, value : std/core/types/bool, ?(==) : (exp, exp) -> std/core/types/bool, ?hash : (exp, std/core/types/int64) -> std/core/types/int, ?value/(==) : (std/core/types/bool, std/core/types/bool) -> std/core/types/bool, ?show : (std/core/types/bool) -> std/core/types/string) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> (std/data/hashmap/hash-map :: (V, V) -> V)<exp,std/core/types/bool>>((main/update<exp,std/core/types/bool>))((std/core/types/local-get<(std/data/hashmap/hash-map :: (V, V) -> V)<exp,std/core/types/bool>,(h :: H),<(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>>(dataDependences)), exp@8, dependence, main/#exp/(==), main/#exp/hash, std/core/bool/(==), std/core/bool/show))));
                                                  }))), (std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(op : (exp, store) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> ()) -> (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),<(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(std/data/hashset/hash-set :: V -> V)<path>>,(op : (exp, store) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> ()) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),<(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(std/data/hashset/hash-set :: V -> V)<path>>>((std/core/hnd/clause-tail2<<(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),exp,store,()>))((fn<<(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>>(exp@9: exp, inputStore: store){
                                                    (std/core/types/local-set<(std/data/hashmap/hash-map :: (V, V) -> V)<exp,store>,<(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(h :: H)>(inputStores, (std/core/types/@open<<(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>>,<(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(map : (std/data/hashmap/hash-map :: (V, V) -> V)<exp,store>, key : exp, value : store, ?(==) : (exp, exp) -> std/core/types/bool, ?hash : (exp, std/core/types/int64) -> std/core/types/int, ?value/(==) : (store, store) -> std/core/types/bool, ?show : (store) -> std/core/types/string) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>> (std/data/hashmap/hash-map :: (V, V) -> V)<exp,store>,(map : (std/data/hashmap/hash-map :: (V, V) -> V)<exp,store>, key : exp, value : store, ?(==) : (exp, exp) -> std/core/types/bool, ?hash : (exp, std/core/types/int64) -> std/core/types/int, ?value/(==) : (store, store) -> std/core/types/bool, ?show : (store) -> std/core/types/string) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> (std/data/hashmap/hash-map :: (V, V) -> V)<exp,store>>((main/update<exp,store>))((std/core/types/local-get<(std/data/hashmap/hash-map :: (V, V) -> V)<exp,store>,(h :: H),<(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>>(inputStores)), exp@9, inputStore, main/#exp/(==), main/#exp/hash, (fn(@arg-x1: store, @arg-x2: store){
                                                          (main/#hashmap/(==)<varName,absValue>(@arg-x1, @arg-x2, main/#varName/(==), main/#varName/hash, main/#absValue/(==)));
                                                        }), main/#store/show))));
                                                  }))), (std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(op : (exp, (std/core/types/list :: V -> V)<path>) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> ()) -> (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),<(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(std/data/hashset/hash-set :: V -> V)<path>>,(op : (exp, (std/core/types/list :: V -> V)<path>) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> ()) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),<(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(std/data/hashset/hash-set :: V -> V)<path>>>((std/core/hnd/clause-tail2<<(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),exp,(std/core/types/list :: V -> V)<path>,()>))((fn<<(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>>(exp@10: exp, iteratorContext: (std/core/types/list :: V -> V)<path>){
                                                    (std/core/types/local-set<(std/data/hashmap/hash-map :: (V, V) -> V)<exp,(std/core/types/list :: V -> V)<path>>,<(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(h :: H)>(iteratorContexts, (std/core/types/@open<<(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>>,<(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(map : (std/data/hashmap/hash-map :: (V, V) -> V)<exp,(std/core/types/list :: V -> V)<path>>, key : exp, value : (std/core/types/list :: V -> V)<path>, ?(==) : (exp, exp) -> std/core/types/bool, ?hash : (exp, std/core/types/int64) -> std/core/types/int, ?value/(==) : ((std/core/types/list :: V -> V)<path>, (std/core/types/list :: V -> V)<path>) -> std/core/types/bool, ?show : ((std/core/types/list :: V -> V)<path>) -> std/core/types/string) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>> (std/data/hashmap/hash-map :: (V, V) -> V)<exp,(std/core/types/list :: V -> V)<path>>,(map : (std/data/hashmap/hash-map :: (V, V) -> V)<exp,(std/core/types/list :: V -> V)<path>>, key : exp, value : (std/core/types/list :: V -> V)<path>, ?(==) : (exp, exp) -> std/core/types/bool, ?hash : (exp, std/core/types/int64) -> std/core/types/int, ?value/(==) : ((std/core/types/list :: V -> V)<path>, (std/core/types/list :: V -> V)<path>) -> std/core/types/bool, ?show : ((std/core/types/list :: V -> V)<path>) -> std/core/types/string) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> (std/data/hashmap/hash-map :: (V, V) -> V)<exp,(std/core/types/list :: V -> V)<path>>>((main/update<exp,(std/core/types/list :: V -> V)<path>>))((std/core/types/local-get<(std/data/hashmap/hash-map :: (V, V) -> V)<exp,(std/core/types/list :: V -> V)<path>>,(h :: H),<(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>>(iteratorContexts)), exp@10, iteratorContext, main/#exp/(==), main/#exp/hash, (fn(@arg-x1@0: (std/core/types/list :: V -> V)<path>, @arg-x2@0: (std/core/types/list :: V -> V)<path>){
                                                          (std/core/list/(==)<path>(@arg-x1@0, @arg-x2@0, main/#path/(==)));
                                                        }), (fn(@arg-x1@1: (std/core/types/list :: V -> V)<path>){
                                                          (std/core/list/show<path,(std/core/types/total :: E)>(@arg-x1@1, main/#path/show));
                                                        })))));
                                                  }))), (std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(op : (exp, store) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> ()) -> (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),<(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(std/data/hashset/hash-set :: V -> V)<path>>,(op : (exp, store) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> ()) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),<(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(std/data/hashset/hash-set :: V -> V)<path>>>((std/core/hnd/clause-tail2<<(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),exp,store,()>))((fn<<(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>>(exp@11: exp, outputStore: store){
                                                    (std/core/types/local-set<(std/data/hashmap/hash-map :: (V, V) -> V)<exp,store>,<(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(h :: H)>(outputStores, (std/core/types/@open<<(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>>,<(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(map : (std/data/hashmap/hash-map :: (V, V) -> V)<exp,store>, key : exp, value : store, ?(==) : (exp, exp) -> std/core/types/bool, ?hash : (exp, std/core/types/int64) -> std/core/types/int, ?value/(==) : (store, store) -> std/core/types/bool, ?show : (store) -> std/core/types/string) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>> (std/data/hashmap/hash-map :: (V, V) -> V)<exp,store>,(map : (std/data/hashmap/hash-map :: (V, V) -> V)<exp,store>, key : exp, value : store, ?(==) : (exp, exp) -> std/core/types/bool, ?hash : (exp, std/core/types/int64) -> std/core/types/int, ?value/(==) : (store, store) -> std/core/types/bool, ?show : (store) -> std/core/types/string) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> (std/data/hashmap/hash-map :: (V, V) -> V)<exp,store>>((main/update<exp,store>))((std/core/types/local-get<(std/data/hashmap/hash-map :: (V, V) -> V)<exp,store>,(h :: H),<(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>>(outputStores)), exp@11, outputStore, main/#exp/(==), main/#exp/hash, (fn(@arg-x1@2: store, @arg-x2@1: store){
                                                          (main/#hashmap/(==)<varName,absValue>(@arg-x1@2, @arg-x2@1, main/#varName/(==), main/#varName/hash, main/#absValue/(==)));
                                                        }), main/#store/show))));
                                                  }))), (std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(op : (exp, (std/data/hashset/hash-set :: V -> V)<path>) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> ()) -> (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),<(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(std/data/hashset/hash-set :: V -> V)<path>>,(op : (exp, (std/data/hashset/hash-set :: V -> V)<path>) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> ()) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),<(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(std/data/hashset/hash-set :: V -> V)<path>>>((std/core/hnd/clause-tail2<<(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),exp,(std/data/hashset/hash-set :: V -> V)<path>,()>))((fn<<(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>>(exp@12: exp, paths: (std/data/hashset/hash-set :: V -> V)<path>){
                                                    (std/core/types/local-set<(std/data/hashmap/hash-map :: (V, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>>,<(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(h :: H)>(pathsByExp, (std/core/types/@open<<(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>>,<(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(map : (std/data/hashmap/hash-map :: (V, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>>, key : exp, value : (std/data/hashset/hash-set :: V -> V)<path>, ?(==) : (exp, exp) -> std/core/types/bool, ?hash : (exp, std/core/types/int64) -> std/core/types/int, ?value/(==) : ((std/data/hashset/hash-set :: V -> V)<path>, (std/data/hashset/hash-set :: V -> V)<path>) -> std/core/types/bool, ?show : ((std/data/hashset/hash-set :: V -> V)<path>) -> std/core/types/string) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>> (std/data/hashmap/hash-map :: (V, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>>,(map : (std/data/hashmap/hash-map :: (V, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>>, key : exp, value : (std/data/hashset/hash-set :: V -> V)<path>, ?(==) : (exp, exp) -> std/core/types/bool, ?hash : (exp, std/core/types/int64) -> std/core/types/int, ?value/(==) : ((std/data/hashset/hash-set :: V -> V)<path>, (std/data/hashset/hash-set :: V -> V)<path>) -> std/core/types/bool, ?show : ((std/data/hashset/hash-set :: V -> V)<path>) -> std/core/types/string) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> (std/data/hashmap/hash-map :: (V, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>>>((main/update<exp,(std/data/hashset/hash-set :: V -> V)<path>>))((std/core/types/local-get<(std/data/hashmap/hash-map :: (V, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>>,(h :: H),<(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>>(pathsByExp)), exp@12, paths, main/#exp/(==), main/#exp/hash, (fn(@arg-x1@3: (std/data/hashset/hash-set :: V -> V)<path>, @arg-x2@2: (std/data/hashset/hash-set :: V -> V)<path>){
                                                          (std/core/list/(==)<path>((main/#hashset/list<path>(@arg-x1@3)), (main/#hashset/list<path>(@arg-x2@2)), main/#path/(==)));
                                                        }), (fn(@arg-x1@4: (std/data/hashset/hash-set :: V -> V)<path>){
                                                          (std/core/list/show<path,(std/core/types/total :: E)>((main/#hashset/list<path>(@arg-x1@4)), main/#path/show));
                                                        })))));
                                                  }))), (std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(op : (exp, absOp) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> ()) -> (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(),(attrGrammar :: (E, V) -> V),<(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(std/data/hashset/hash-set :: V -> V)<path>>,(op : (exp, absOp) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> ()) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(),(attrGrammar :: (E, V) -> V),<(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(std/data/hashset/hash-set :: V -> V)<path>>>((std/core/hnd/clause-tail2<<(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),exp,absOp,()>))((fn<<(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>>(exp@13: exp, queryCondition: absOp){
                                                    (std/core/types/local-set<(std/data/hashmap/hash-map :: (V, V) -> V)<exp,absOp>,<(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(h :: H)>(queryConditions, (std/core/types/@open<<(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>>,<(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(map : (std/data/hashmap/hash-map :: (V, V) -> V)<exp,absOp>, key : exp, value : absOp, ?(==) : (exp, exp) -> std/core/types/bool, ?hash : (exp, std/core/types/int64) -> std/core/types/int, ?value/(==) : (absOp, absOp) -> std/core/types/bool, ?show : (absOp) -> std/core/types/string) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>> (std/data/hashmap/hash-map :: (V, V) -> V)<exp,absOp>,(map : (std/data/hashmap/hash-map :: (V, V) -> V)<exp,absOp>, key : exp, value : absOp, ?(==) : (exp, exp) -> std/core/types/bool, ?hash : (exp, std/core/types/int64) -> std/core/types/int, ?value/(==) : (absOp, absOp) -> std/core/types/bool, ?show : (absOp) -> std/core/types/string) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> (std/data/hashmap/hash-map :: (V, V) -> V)<exp,absOp>>((main/update<exp,absOp>))((std/core/types/local-get<(std/data/hashmap/hash-map :: (V, V) -> V)<exp,absOp>,(h :: H),<(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>>(queryConditions)), exp@13, queryCondition, main/#exp/(==), main/#exp/hash, main/#absOp/(==), main/#absOp/show))));
                                                  }))), (std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(op : (exp, (std/data/hashset/hash-set :: V -> V)<path>) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> ()) -> (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),<(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(std/data/hashset/hash-set :: V -> V)<path>>,(op : (exp, (std/data/hashset/hash-set :: V -> V)<path>) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> ()) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),<(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(std/data/hashset/hash-set :: V -> V)<path>>>((std/core/hnd/clause-tail2<<(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),exp,(std/data/hashset/hash-set :: V -> V)<path>,()>))((fn<<(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>>(exp@14: exp, traversalSummary: (std/data/hashset/hash-set :: V -> V)<path>){
                                                    (std/core/types/local-set<(std/data/hashmap/hash-map :: (V, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>>,<(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(h :: H)>(traversalSummaries, (std/core/types/@open<<(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>>,<(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(map : (std/data/hashmap/hash-map :: (V, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>>, key : exp, value : (std/data/hashset/hash-set :: V -> V)<path>, ?(==) : (exp, exp) -> std/core/types/bool, ?hash : (exp, std/core/types/int64) -> std/core/types/int, ?value/(==) : ((std/data/hashset/hash-set :: V -> V)<path>, (std/data/hashset/hash-set :: V -> V)<path>) -> std/core/types/bool, ?show : ((std/data/hashset/hash-set :: V -> V)<path>) -> std/core/types/string) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>> (std/data/hashmap/hash-map :: (V, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>>,(map : (std/data/hashmap/hash-map :: (V, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>>, key : exp, value : (std/data/hashset/hash-set :: V -> V)<path>, ?(==) : (exp, exp) -> std/core/types/bool, ?hash : (exp, std/core/types/int64) -> std/core/types/int, ?value/(==) : ((std/data/hashset/hash-set :: V -> V)<path>, (std/data/hashset/hash-set :: V -> V)<path>) -> std/core/types/bool, ?show : ((std/data/hashset/hash-set :: V -> V)<path>) -> std/core/types/string) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> (std/data/hashmap/hash-map :: (V, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>>>((main/update<exp,(std/data/hashset/hash-set :: V -> V)<path>>))((std/core/types/local-get<(std/data/hashmap/hash-map :: (V, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>>,(h :: H),<(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>>(traversalSummaries)), exp@14, traversalSummary, main/#exp/(==), main/#exp/hash, (fn(@arg-x1@5: (std/data/hashset/hash-set :: V -> V)<path>, @arg-x2@3: (std/data/hashset/hash-set :: V -> V)<path>){
                                                          (std/core/list/(==)<path>((main/#hashset/list<path>(@arg-x1@5)), (main/#hashset/list<path>(@arg-x2@3)), main/#path/(==)));
                                                        }), (fn(@arg-x1@6: (std/data/hashset/hash-set :: V -> V)<path>){
                                                          (std/core/list/show<path,(std/core/types/total :: E)>((main/#hashset/list<path>(@arg-x1@6)), main/#path/show));
                                                        })))));
                                                  }))))), (fn<<(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>>(@x@0: (std/data/hashset/hash-set :: V -> V)<path>){
                                                  @x@0;
                                                }), (fn<<(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>>(){
                                                  (std/core/hnd/local-var<std/core/types/int,(std/data/hashset/hash-set :: V -> V)<path>,<(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>>,(h :: H)>(1000, (fn<<(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>>>(gas: (std/core/types/local-var :: (H, V) -> V)<(h :: H),std/core/types/int>){
                                                      val _@1[810,3,810,45] : ()
                                                        = (std/core/while<<(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>>>((fn<<(std/core/types/div :: X),(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>>>(){
                                                            (match ((std/core/types/local-get<std/core/types/bool,(h :: H),<(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>>>(updatedThisIteration))) {
                                                              ((std/core/types/True() : std/core/types/bool ) as @pat@8: std/core/types/bool)
                                                                 -> std/core/types/@open<(std/core/types/total :: E),<(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>>,(x : std/core/types/int, y : std/core/types/int) -> std/core/types/bool,(x : std/core/types/int, y : std/core/types/int) -> <(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>> std/core/types/bool>(std/core/int/(>))((std/core/types/local-get<std/core/types/int,(h :: H),<(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>>>(gas)), 0);
                                                              (@pat@0@7: std/core/types/bool)
                                                                 -> std/core/types/False;
                                                            });
                                                          }), (fn<<(std/core/types/div :: X),(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>>>(){
                                                            val _[811,5,811,33] : ()
                                                              = (std/core/types/local-set<std/core/types/bool,<(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>>,(h :: H)>(updatedThisIteration, std/core/types/False));
                                                            val _@0[812,5,812,18] : ()
                                                              = (std/core/types/local-set<std/core/types/int,<(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>>,(h :: H)>(gas, (std/core/types/@open<(std/core/types/total :: E),<(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>>,(x : std/core/types/int, y : std/core/types/int) -> std/core/types/int,(x : std/core/types/int, y : std/core/types/int) -> <(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>> std/core/types/int>((fn(x: std/core/types/int, y: std/core/types/int){
                                                                  (std/core/int/int-sub(x, y));
                                                                }))((std/core/types/local-get<std/core/types/int,(h :: H),<(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>>>(gas)), 1))));
                                                            (std/core/types/@open<<(std/core/pure :: E),(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>>,<(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>>,(exp : exp) -> <(std/core/pure :: E),(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>> (),(exp : exp) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>> ()>(main/iterateAttributeGrammar)(root));
                                                          })));
                                                      val _@2[828,6,830,3] : ()
                                                        = (match ((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>>,(x : std/core/types/int, y : std/core/types/int) -> std/core/types/bool,(x : std/core/types/int, y : std/core/types/int) -> <(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>> std/core/types/bool>(std/core/int/(==))((std/core/types/local-get<std/core/types/int,(h :: H),<(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>>>(gas)), 0))) {
                                                          ((std/core/types/True() : std/core/types/bool ) as @pat@1@0: std/core/types/bool)
                                                             -> std/core/types/@open<(std/core/types/total :: E),<(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>>,(message : std/core/types/string) -> (),(message : std/core/types/string) -> <(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>> ()>(std/core/debug/trace)("ran out of gas");
                                                          ((@skip std/core/types/False() : std/core/types/bool ) as @pat@2@0: std/core/types/bool)
                                                             -> std/core/types/Unit;
                                                        });
                                                      (std/core/types/@open<<(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>>,<(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>>,(exp : exp) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>> (std/data/hashset/hash-set :: V -> V)<path>,(exp : exp) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>> (std/data/hashset/hash-set :: V -> V)<path>>((fn<<(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>>>(exp@15: exp){
                                                        (std/core/hnd/@perform1<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),<(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>>>((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>>,(i : std/core/hnd/ev-index) -> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(attrGrammar :: (E, V) -> V)>,(i : std/core/hnd/ev-index) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(attrGrammar :: (E, V) -> V)>>((std/core/hnd/@evv-at<(attrGrammar :: (E, V) -> V)>))((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>>,(i : std/core/types/int) -> std/core/types/ssize_t,(i : std/core/types/int) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>> std/core/types/ssize_t>(std/core/types/@make-ssize_t)(0)))), main/@select-getTraversalSummary, exp@15));
                                                      }))(root));
                                                    })));
                                                })));
                                            })));
                                        })));
                                    })));
                                })));
                            })));
                        })));
                    })));
                })));
            })));
        }));
    }))();
  };
specialize "***"  fun applyOp // inline size: 1
  = fn(op: op, a: absValue, b: absValue){
    val set@10192[1,0,1,0] : (std/data/hashset/hash-set :: V -> V)<absOp>
          = std/data/hashset/#thread/hash-set<absOp>((std/core/types/@None<std/core/types/int>));
    main/AVOp((std/data/hashset/insert<absOp>(set@10192, (main/AOOp(op, (std/core/types/Cons<absValue>(a, (std/core/types/Cons<absValue>(b, (std/core/types/Nil<absValue>))))))), main/#absOp/hash, main/#absOp/(==), std/data/hashset/when-resize, std/data/hashset/resizer)));
  };
specialize "_*_*_"  fun getOrDefault // inline size: 1
  = forall<a,b> fn(map: (std/data/hashmap/hash-map :: (V, V) -> V)<a,b>, key: a, default: b, @implicit/(==): (a, a) -> std/core/types/bool, @implicit/hash: (a, std/core/types/int64) -> std/core/types/int){
    (match ((std/data/hashmap/get<a,b>(map, key, @implicit/hash, @implicit/(==)))) {
      ((std/core/types/Just((value: b) : b) : (std/core/types/maybe :: V -> V)<b> ) as @pat: ((std/core/types/maybe :: V -> V)<b>))
         -> value;
      ((@skip std/core/types/Nothing() : (std/core/types/maybe :: V -> V)<b> ) as @pat@0: ((std/core/types/maybe :: V -> V)<b>))
         -> default;
    });
  };
specialize "***"  fun mapShow // inline size: 1
  = forall<a,b> fn(map: (std/data/hashmap/hash-map :: (V, V) -> V)<a,b>, @implicit/keyShow: (a) -> std/core/types/string, @implicit/valueShow: (b) -> std/core/types/string){
    main/#hashmap/show<a,b>(map, @implicit/keyShow, @implicit/valueShow);
  };
recursive specialize "_*"  fun visit // inline size: 18
  = forall<(e :: E)> fn<(e :: E)>(exp: exp, f: (exp) -> (e :: E) ()){
    val _[709,3,709,9] : ()
          = f(exp);
    (match (exp) {
      ((main/DotE((e: exp) : exp, (@pat@0: fieldName) : fieldName, (@pat@1: std/core/types/int) : std/core/types/int) : exp ) as @pat: exp)
         -> main/visit<(e :: E)>(e, f);
      ((main/OpE((@pat@3: op) : op, (e1: exp) : exp, (e2: exp) : exp, (@pat@4: std/core/types/int) : std/core/types/int) : exp ) as @pat@2: exp)
         -> val _@0[713,7,713,17] : ()
                  = main/visit<(e :: E)>(e1, f);
        main/visit<(e :: E)>(e2, f);
      ((main/AsgnE(((@skip main/VarName((@pat@7: std/core/types/string) : std/core/types/string) : varName ) as @pat@6: varName) : varName, (e@0: exp) : exp, (@pat@8: std/core/types/int) : std/core/types/int) : exp ) as @pat@5: exp)
         -> main/visit<(e :: E)>(e@0, f);
      ((main/IfE((e@1: exp) : exp, (s1: exp) : exp, (s2: exp) : exp, (@pat@10: std/core/types/int) : std/core/types/int) : exp ) as @pat@9: exp)
         -> val _@1[718,7,718,16] : ()
              = main/visit<(e :: E)>(e@1, f);
            val _@2[719,7,719,17] : ()
              = main/visit<(e :: E)>(s1, f);
        main/visit<(e :: E)>(s2, f);
      ((main/ForE(((@skip main/VarName((@pat@13: std/core/types/string) : std/core/types/string) : varName ) as @pat@12: varName) : varName, (e@2: exp) : exp, (s: exp) : exp, (@pat@14: std/core/types/int) : std/core/types/int) : exp ) as @pat@11: exp)
         -> val _@3[723,7,723,16] : ()
                  = main/visit<(e :: E)>(e@2, f);
        main/visit<(e :: E)>(s, f);
      ((main/SeqE((s1@0: exp) : exp, (s2@0: exp) : exp, (@pat@16: std/core/types/int) : std/core/types/int) : exp ) as @pat@15: exp)
         -> val _@4[727,7,727,17] : ()
                  = main/visit<(e :: E)>(s1@0, f);
        main/visit<(e :: E)>(s2@0, f);
      (@pat@17: exp)
         -> std/core/types/Unit;
    });
  };
specialize "*_"  fun absOp/(&) // inline size: 1
  = fn(absOp: absOp, absValue: absValue){
    val set@10199[1,0,1,0] : (std/data/hashset/hash-set :: V -> V)<absOp>
          = std/data/hashset/#thread/hash-set<absOp>((std/core/types/@None<std/core/types/int>));
    main/AOOp(main/AndOp, (std/core/types/Cons<absValue>((main/AVOp((std/data/hashset/insert<absOp>(set@10199, absOp, main/#absOp/hash, main/#absOp/(==), std/data/hashset/when-resize, std/data/hashset/resizer)))), (std/core/types/Cons<absValue>(absValue, (std/core/types/Nil<absValue>))))));
  };
specialize "*"  fun absValue/not // inline size: 1
  = fn(absValue: absValue){
    val set@10206[1,0,1,0] : (std/data/hashset/hash-set :: V -> V)<absOp>
          = std/data/hashset/#thread/hash-set<absOp>((std/core/types/@None<std/core/types/int>));
    main/AVOp((std/data/hashset/insert<absOp>(set@10206, (main/AOOp(main/NotOp, (std/core/types/Cons<absValue>(absValue, (std/core/types/Nil<absValue>))))), main/#absOp/hash, main/#absOp/(==), std/data/hashset/when-resize, std/data/hashset/resizer)));
  };
specialize "*****"  fun hashmap/(==) // inline size: 1
  = forall<a,b> fn(a: (std/data/hashmap/hash-map :: (V, V) -> V)<a,b>, b: (std/data/hashmap/hash-map :: (V, V) -> V)<a,b>, @implicit/(==): (a, a) -> std/core/types/bool, @implicit/hash: (a, std/core/types/int64) -> std/core/types/int, @implicit/value/(==): (b, b) -> std/core/types/bool){
    (match ((std/core/int/(==)((match (a) {
        ((@skip std/data/hashmap/Hash-map((@pat@0: (std/core/types/vector :: V -> V)<(std/core/types/list :: V -> V)<(a, b)>>) : (std/core/types/vector :: V -> V)<(std/core/types/list :: V -> V)<(a, b)>>, (@x: std/core/types/int) : std/core/types/int, (@pat@1: std/core/types/int64) : std/core/types/int64) : (std/data/hashmap/hash-map :: (V, V) -> V)<a,b> ) as @pat: ((std/data/hashmap/hash-map :: (V, V) -> V)<a,b>))
           -> @x;
      }), (match (b) {
        ((@skip std/data/hashmap/Hash-map((@pat@0@0: (std/core/types/vector :: V -> V)<(std/core/types/list :: V -> V)<(a, b)>>) : (std/core/types/vector :: V -> V)<(std/core/types/list :: V -> V)<(a, b)>>, (@x@0: std/core/types/int) : std/core/types/int, (@pat@1@0: std/core/types/int64) : std/core/types/int64) : (std/data/hashmap/hash-map :: (V, V) -> V)<a,b> ) as @pat@2: ((std/data/hashmap/hash-map :: (V, V) -> V)<a,b>))
           -> @x@0;
      })))) {
      ((std/core/types/True() : std/core/types/bool ) as @pat@3: std/core/types/bool)
         -> std/core/types/unsafe-no-local-cast<std/core/types/bool,(std/core/types/total :: E)>((forall<(h :: H)> fn<<(std/core/types/local :: H -> X)<(h :: H)>>>(){
          std/core/hnd/local-var<std/core/types/bool,std/core/types/bool,(std/core/types/total :: E),(h :: H)>(std/core/types/True, (fn<<(std/core/types/local :: H -> X)<(h :: H)>>>(allMatch: (std/core/types/local-var :: (H, V) -> V)<(h :: H),std/core/types/bool>){
              val _[31,5,34,6] : ()
                    = (std/data/hashmap/foreach<<(std/core/types/local :: H -> X)<(h :: H)>>,a,b>(a, (fn<<(std/core/types/local :: H -> X)<(h :: H)>>>(key: a, aValue: b){
                        (match ((std/data/hashmap/get<a,b>(b, key, @implicit/hash, @implicit/(==)))) {
                          ((std/core/types/Just((bValue: b) : b) : (std/core/types/maybe :: V -> V)<b> ) as @pat@0@1: ((std/core/types/maybe :: V -> V)<b>))
                             -> std/core/types/local-set<std/core/types/bool,(std/core/types/total :: E),(h :: H)>(allMatch, (match ((std/core/types/local-get<std/core/types/bool,(h :: H),(std/core/types/total :: E)>(allMatch))) {
                                ((std/core/types/True() : std/core/types/bool ) as @pat@1@1: std/core/types/bool)
                                   -> @implicit/value/(==)(aValue, bValue);
                                (@pat@2@0: std/core/types/bool)
                                   -> std/core/types/False;
                              }));
                          ((@skip std/core/types/Nothing() : (std/core/types/maybe :: V -> V)<b> ) as @pat@3@0: ((std/core/types/maybe :: V -> V)<b>))
                             -> std/core/types/local-set<std/core/types/bool,(std/core/types/total :: E),(h :: H)>(allMatch, std/core/types/False);
                        });
                      })));
              (std/core/types/local-get<std/core/types/bool,(h :: H),(std/core/types/total :: E)>(allMatch));
            }));
        }))();
      (@pat@4: std/core/types/bool)
         -> std/core/types/False;
    });
  };
specialize "__*"  fun hashset/(==) // inline size: 1
  = forall<a> fn(a: (std/data/hashset/hash-set :: V -> V)<a>, b: (std/data/hashset/hash-set :: V -> V)<a>, @implicit/(==): (a, a) -> std/core/types/bool){
    std/core/list/(==)<a>((main/#hashset/list<a>(a)), (main/#hashset/list<a>(b)), @implicit/(==));
  };
specialize "_*_*_"  fun hash-map/insert // inline size: 1
  = forall<a,b> fn(map: (std/data/hashmap/hash-map :: (V, V) -> V)<a,b>, key: a, value: b, @implicit/(==): (a, a) -> std/core/types/bool, @implicit/hash: (a, std/core/types/int64) -> std/core/types/int){
    std/data/hashmap/insert<a,b>(map, key, value, @implicit/hash, @implicit/(==), std/data/hashmap/when-resize, std/data/hashmap/resizer);
  };
specialize "_**_"  fun hash-set/insert // inline size: 1
  = forall<a> fn(set: (std/data/hashset/hash-set :: V -> V)<a>, x: a, @implicit/(==): (a, a) -> std/core/types/bool, @implicit/hash: (a, std/core/types/int64) -> std/core/types/int){
    std/data/hashset/insert<a>(set, x, @implicit/hash, @implicit/(==), std/data/hashset/when-resize, std/data/hashset/resizer);
  };
specialize "_***"  fun hashmap/insertAll // inline size: 1
  = forall<a,b> fn<(std/core/pure :: E)>(a: (std/data/hashmap/hash-map :: (V, V) -> V)<a,b>, b: (std/data/hashmap/hash-map :: (V, V) -> V)<a,b>, @implicit/(==): (a, a) -> std/core/types/bool, @implicit/hash: (a, std/core/types/int64) -> std/core/types/int){
    std/core/types/@open<(std/core/types/total :: E),<(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(action : forall<(h :: H)> () -> <(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> (std/data/hashmap/hash-map :: (V, V) -> V)<a,b>) -> (() -> <(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> (std/data/hashmap/hash-map :: (V, V) -> V)<a,b>),(action : forall<(h :: H)> () -> <(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> (std/data/hashmap/hash-map :: (V, V) -> V)<a,b>) -> <(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> (() -> <(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> (std/data/hashmap/hash-map :: (V, V) -> V)<a,b>)>((std/core/types/unsafe-no-local-cast<(std/data/hashmap/hash-map :: (V, V) -> V)<a,b>,<(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>>))((forall<(h :: H)> fn<<(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>>(){
      std/core/hnd/local-var<(std/data/hashmap/hash-map :: (V, V) -> V)<a,b>,(std/data/hashmap/hash-map :: (V, V) -> V)<a,b>,<(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(h :: H)>(a, (fn<<(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>>(result: (std/core/types/local-var :: (H, V) -> V)<(h :: H),(std/data/hashmap/hash-map :: (V, V) -> V)<a,b>>){
          val _[413,3,415,4] : ()
                = (std/data/hashmap/foreach-key<<(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>>,a,b>(b, (fn<<(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>>>(key: a){
                    (std/core/types/local-set<(std/data/hashmap/hash-map :: (V, V) -> V)<a,b>,<(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/div :: X)>,(h :: H)>(result, (std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X)>,(map : (std/data/hashmap/hash-map :: (V, V) -> V)<a,b>, key : a, value : b, ?(==) : (a, a) -> std/core/types/bool, ?hash : (a, std/core/types/int64) -> std/core/types/int) -> (std/data/hashmap/hash-map :: (V, V) -> V)<a,b>,(map : (std/data/hashmap/hash-map :: (V, V) -> V)<a,b>, key : a, value : b, ?(==) : (a, a) -> std/core/types/bool, ?hash : (a, std/core/types/int64) -> std/core/types/int) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X)> (std/data/hashmap/hash-map :: (V, V) -> V)<a,b>>((fn(map: (std/data/hashmap/hash-map :: (V, V) -> V)<a,b>, key@0: a, value: b, @implicit/(@x@0==): (a, a) -> std/core/types/bool, @implicit/hash@0: (a, std/core/types/int64) -> std/core/types/int){
                        (std/data/hashmap/insert<a,b>(map, key@0, value, @implicit/hash@0, @implicit/(@x@0==), std/data/hashmap/when-resize, std/data/hashmap/resizer));
                      }))((std/core/types/local-get<(std/data/hashmap/hash-map :: (V, V) -> V)<a,b>,(h :: H),<(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/div :: X)>>(result)), key, (match ((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(hm : (std/data/hashmap/hash-map :: (V, V) -> V)<a,b>, key : a, ?hash : (a, std/core/types/int64) -> std/core/types/int, ?(==) : (a, a) -> std/core/types/bool) -> (std/core/types/maybe :: V -> V)<b>,(hm : (std/data/hashmap/hash-map :: (V, V) -> V)<a,b>, key : a, ?hash : (a, std/core/types/int64) -> std/core/types/int, ?(==) : (a, a) -> std/core/types/bool) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> (std/core/types/maybe :: V -> V)<b>>((std/data/hashmap/get<a,b>))(b, key, @implicit/hash, @implicit/(==)))) {
                          ((std/core/types/Just((value@0: b) : b) : (std/core/types/maybe :: V -> V)<b> ) as @pat: ((std/core/types/maybe :: V -> V)<b>))
                             -> value@0;
                          ((@skip std/core/types/Nothing() : (std/core/types/maybe :: V -> V)<b> ) as @pat@0: ((std/core/types/maybe :: V -> V)<b>))
                             -> std/core/exn/throw<b>("key not present", (std/core/types/@None<std/core/exn/exception-info>));
                        }), @implicit/(==), @implicit/hash))));
                  })));
          (std/core/types/local-get<(std/data/hashmap/hash-map :: (V, V) -> V)<a,b>,(h :: H),<(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>>(result));
        }));
    }))();
  };
specialize "*"  fun hashset/list // inline size: 1
  = forall<a> fn(set: (std/data/hashset/hash-set :: V -> V)<a>){
    std/core/undiv/pretend-nodiv-cast<(std/core/types/total :: E),(std/core/types/list :: V -> V)<a>>((fn<<(std/core/types/div :: X)>>(){
      (std/core/types/unsafe-no-local-cast<(std/core/types/list :: V -> V)<a>,<(std/core/types/div :: X)>>((forall<(h :: H)> fn<<(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X)>>(){
        std/core/hnd/local-var<(std/core/types/list :: V -> V)<a>,(std/core/types/list :: V -> V)<a>,<(std/core/types/div :: X)>,(h :: H)>((std/core/types/Nil<a>), (fn<<(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/div :: X)>>(retList: (std/core/types/local-var :: (H, V) -> V)<(h :: H),(std/core/types/list :: V -> V)<a>>){
            val _[10,5,10,50] : ()
                  = (std/data/hashset/foreach<<(std/core/types/div :: X),(std/core/types/local :: H -> X)<(h :: H)>>,a>(set, (fn<<(std/core/types/div :: X),(std/core/types/local :: H -> X)<(h :: H)>>>(x: a){
                      (std/core/types/local-set<(std/core/types/list :: V -> V)<a>,<(std/core/types/div :: X)>,(h :: H)>(retList, (std/core/types/Cons<a>(x, (std/core/types/local-get<(std/core/types/list :: V -> V)<a>,(h :: H),<(std/core/types/div :: X)>>(retList))))));
                    })));
            (std/core/types/local-get<(std/core/types/list :: V -> V)<a>,(h :: H),<(std/core/types/div :: X)>>(retList));
          }));
      }))());
    }))();
  };
specialize "***"  fun hashmap/show // inline size: 1
  = forall<a,b> fn(map: (std/data/hashmap/hash-map :: (V, V) -> V)<a,b>, @implicit/key/show: (a) -> std/core/types/string, @implicit/value/show: (b) -> std/core/types/string){
    std/core/types/unsafe-no-local-cast<std/core/types/string,(std/core/types/total :: E)>((forall<(h :: H)> fn<<(std/core/types/local :: H -> X)<(h :: H)>>>(){
      std/core/hnd/local-var<std/core/types/string,std/core/types/string,(std/core/types/total :: E),(h :: H)>("{", (fn<<(std/core/types/local :: H -> X)<(h :: H)>>>(result: (std/core/types/local-var :: (H, V) -> V)<(h :: H),std/core/types/string>){
          val _[41,3,41,94] : ()
                = (std/data/hashmap/foreach<<(std/core/types/local :: H -> X)<(h :: H)>>,a,b>(map, (fn<<(std/core/types/local :: H -> X)<(h :: H)>>>(k: a, v: b){
                    (std/core/types/local-set<std/core/types/string,(std/core/types/total :: E),(h :: H)>(result, (std/core/types/(++)((std/core/types/local-get<std/core/types/string,(h :: H),(std/core/types/total :: E)>(result)), (std/core/types/(++)("(", (std/core/types/(++)((@implicit/key/show(k)), (std/core/types/(++)(",", (std/core/types/(++)((@implicit/value/show(v)), ")"))))))))))));
                  })));
          (std/core/types/(++)((std/core/types/local-get<std/core/types/string,(h :: H),(std/core/types/total :: E)>(result)), "}"));
        }));
    }))();
  };
specialize "_*"  fun hashset/show // inline size: 1
  = forall<a> fn(set: (std/data/hashset/hash-set :: V -> V)<a>, @implicit/show: (a) -> std/core/types/string){
    std/core/list/show<a,(std/core/types/total :: E)>((main/#hashset/list<a>(set)), @implicit/show);
  };
specialize "**_"  fun hashset/singleton // inline size: 1
  = forall<a> fn(x: a, @implicit/(==): (a, a) -> std/core/types/bool, @implicit/hash: (a, std/core/types/int64) -> std/core/types/int){
    val set@10185[1,0,1,0] : (std/data/hashset/hash-set :: V -> V)<a>
          = std/data/hashset/#thread/hash-set<a>((std/core/types/@None<std/core/types/int>));
    std/data/hashset/insert<a>(set@10185, x, @implicit/hash, @implicit/(==), std/data/hashset/when-resize, std/data/hashset/resizer);
  };
specialize "*___"  fun hashset/union // inline size: 1
  = forall<a> fn(a: (std/data/hashset/hash-set :: V -> V)<a>, b: (std/data/hashset/hash-set :: V -> V)<a>, @implicit/(==): (a, a) -> std/core/types/bool, @implicit/hash: (a, std/core/types/int64) -> std/core/types/int){
    val xs@10078[1,0,1,0] : (std/core/types/list :: V -> V)<a>
      = main/#hashset/list<a>(a);
    val ys@10079[1,0,1,0] : (std/core/types/list :: V -> V)<a>
      = main/#hashset/list<a>(b);
    std/data/hashset/#thread/list/hash-set<a>((std/core/list/append<a>(xs@10078, ys@10079)), @implicit/hash, @implicit/(==));
  };
specialize "*"  fun store/show // inline size: 1
  = fn(store: store){
    main/#hashmap/show<varName,absValue>(store, main/#varName/show, main/#absValue/show);
  };
inline borrow "^" fip fun is-stringLit // inline size: 1
  = fn(literal: literal){
    match (literal) {
      ((main/StringLit((@pat@0: std/core/types/string) : std/core/types/string) : literal ) as @pat: literal)
         -> std/core/types/True;
      ((@skip main/NumberLit((@pat@2: std/core/types/int) : std/core/types/int) : literal ) as @pat@1: literal)
         -> std/core/types/False;
    };
  };
inline borrow "^" fip fun is-numberLit // inline size: 1
  = fn(literal: literal){
    match (literal) {
      ((main/NumberLit((@pat@0: std/core/types/int) : std/core/types/int) : literal ) as @pat: literal)
         -> std/core/types/True;
      ((@skip main/StringLit((@pat@2: std/core/types/string) : std/core/types/string) : literal ) as @pat@1: literal)
         -> std/core/types/False;
    };
  };
inline borrow "^" fip fun is-fnnamed // inline size: 1
  = fn(fieldName: fieldName){
    match (fieldName) {
      ((main/FNNamed((@pat@0: std/core/types/string) : std/core/types/string) : fieldName ) as @pat: fieldName)
         -> std/core/types/True;
      ((@skip main/FNL() : fieldName ) as @pat@1: fieldName)
         -> std/core/types/False;
    };
  };
inline borrow "^" fip fun is-fnl // inline size: 1
  = fn(fieldName: fieldName){
    match (fieldName) {
      ((main/FNL() : fieldName ) as @pat: fieldName)
         -> std/core/types/True;
      ((@skip main/FNNamed((@pat@1: std/core/types/string) : std/core/types/string) : fieldName ) as @pat@0: fieldName)
         -> std/core/types/False;
    };
  };
inline borrow "^" fip fun is-andOp // inline size: 1
  = fn(op: op){
    match (op) {
      ((main/AndOp() : op ) as @pat: op)
         -> std/core/types/True;
      (@pat@0: op)
         -> std/core/types/False;
    };
  };
inline borrow "^" fip fun is-notOp // inline size: 1
  = fn(op: op){
    match (op) {
      ((main/NotOp() : op ) as @pat: op)
         -> std/core/types/True;
      (@pat@0: op)
         -> std/core/types/False;
    };
  };
inline borrow "^" fip fun is-eqOp // inline size: 1
  = fn(op: op){
    match (op) {
      ((main/EqOp() : op ) as @pat: op)
         -> std/core/types/True;
      (@pat@0: op)
         -> std/core/types/False;
    };
  };
inline borrow "^" fip fun is-gtOp // inline size: 1
  = fn(op: op){
    match (op) {
      ((main/GtOp() : op ) as @pat: op)
         -> std/core/types/True;
      (@pat@0: op)
         -> std/core/types/False;
    };
  };
inline borrow "^" fip fun is-plusOp // inline size: 1
  = fn(op: op){
    match (op) {
      ((main/PlusOp() : op ) as @pat: op)
         -> std/core/types/True;
      (@pat@0: op)
         -> std/core/types/False;
    };
  };
inline borrow "^" fip fun is-aotrue // inline size: 1
  = fn(absOp: absOp){
    match (absOp) {
      ((main/AOTrue() : absOp ) as @pat: absOp)
         -> std/core/types/True;
      ((@skip main/AOOp((@pat@1: op) : op, (@pat@2: (std/core/types/list :: V -> V)<absValue>) : (std/core/types/list :: V -> V)<absValue>) : absOp ) as @pat@0: absOp)
         -> std/core/types/False;
    };
  };
inline borrow "^" fip fun is-aoop // inline size: 1
  = fn(absOp: absOp){
    match (absOp) {
      ((main/AOOp((@pat@0: op) : op, (@pat@1: (std/core/types/list :: V -> V)<absValue>) : (std/core/types/list :: V -> V)<absValue>) : absOp ) as @pat: absOp)
         -> std/core/types/True;
      ((@skip main/AOTrue() : absOp ) as @pat@2: absOp)
         -> std/core/types/False;
    };
  };
inline borrow "^" fip fun is-avbot // inline size: 1
  = fn(absValue: absValue){
    match (absValue) {
      ((main/AVBot() : absValue ) as @pat: absValue)
         -> std/core/types/True;
      (@pat@0: absValue)
         -> std/core/types/False;
    };
  };
inline borrow "^" fip fun is-avlit // inline size: 1
  = fn(absValue: absValue){
    match (absValue) {
      ((main/AVLit((@pat@0: (std/data/hashset/hash-set :: V -> V)<literal>) : (std/data/hashset/hash-set :: V -> V)<literal>) : absValue ) as @pat: absValue)
         -> std/core/types/True;
      (@pat@1: absValue)
         -> std/core/types/False;
    };
  };
inline borrow "^" fip fun is-avop // inline size: 1
  = fn(absValue: absValue){
    match (absValue) {
      ((main/AVOp((@pat@0: (std/data/hashset/hash-set :: V -> V)<absOp>) : (std/data/hashset/hash-set :: V -> V)<absOp>) : absValue ) as @pat: absValue)
         -> std/core/types/True;
      (@pat@1: absValue)
         -> std/core/types/False;
    };
  };
inline borrow "^" fip fun is-avpath // inline size: 1
  = fn(absValue: absValue){
    match (absValue) {
      ((main/AVPath((@pat@0: (std/data/hashset/hash-set :: V -> V)<path>) : (std/data/hashset/hash-set :: V -> V)<path>) : absValue ) as @pat: absValue)
         -> std/core/types/True;
      (@pat@1: absValue)
         -> std/core/types/False;
    };
  };
inline borrow "^"  fun path/names // inline size: 0
  = fn(path: path){
    match (path) {
      ((@skip main/Path((@x: (std/core/types/list :: V -> V)<fieldName>) : (std/core/types/list :: V -> V)<fieldName>, (@pat@0: absOp) : absOp, (@pat@1: std/core/types/bool) : std/core/types/bool) : path ) as @pat: path)
         -> @x;
    };
  };
inline borrow "^"  fun path/absOp // inline size: 0
  = fn(path: path){
    match (path) {
      ((@skip main/Path((@pat@0: (std/core/types/list :: V -> V)<fieldName>) : (std/core/types/list :: V -> V)<fieldName>, (@x: absOp) : absOp, (@pat@1: std/core/types/bool) : std/core/types/bool) : path ) as @pat: path)
         -> @x;
    };
  };
inline borrow "^"  fun path/dependence // inline size: 0
  = fn(path: path){
    match (path) {
      ((@skip main/Path((@pat@0: (std/core/types/list :: V -> V)<fieldName>) : (std/core/types/list :: V -> V)<fieldName>, (@pat@1: absOp) : absOp, (@x: std/core/types/bool) : std/core/types/bool) : path ) as @pat: path)
         -> @x;
    };
  };
 fun path/@copy // inline size: 4
  = fn(@this: path, names: (std/core/types/@optional :: V -> V)<(std/core/types/list :: V -> V)<fieldName>>, absOp: (std/core/types/@optional :: V -> V)<absOp>, dependence: (std/core/types/@optional :: V -> V)<std/core/types/bool>){
    main/Path((match (names) {
        ((std/core/types/@Optional((@uniq-names@895: (std/core/types/list :: V -> V)<fieldName>) : (std/core/types/list :: V -> V)<fieldName>) : (std/core/types/@optional :: V -> V)<(std/core/types/list :: V -> V)<fieldName>> ) as @pat: ((std/core/types/@optional :: V -> V)<(std/core/types/list :: V -> V)<fieldName>>))
           -> @uniq-names@895;
        ((@skip std/core/types/@None() : (std/core/types/@optional :: V -> V)<(std/core/types/list :: V -> V)<fieldName>> ) as @pat@0: ((std/core/types/@optional :: V -> V)<(std/core/types/list :: V -> V)<fieldName>>))
           -> (match (@this) {
            ((@skip main/Path((@x: (std/core/types/list :: V -> V)<fieldName>) : (std/core/types/list :: V -> V)<fieldName>, (@pat@0@0: absOp) : absOp, (@pat@1@0: std/core/types/bool) : std/core/types/bool) : path ) as @pat@1: path)
               -> @x;
          });
      }), (match (absOp) {
        ((std/core/types/@Optional((@uniq-absOp@902: absOp) : absOp) : (std/core/types/@optional :: V -> V)<absOp> ) as @pat@1@1: ((std/core/types/@optional :: V -> V)<absOp>))
           -> @uniq-absOp@902;
        ((@skip std/core/types/@None() : (std/core/types/@optional :: V -> V)<absOp> ) as @pat@2: ((std/core/types/@optional :: V -> V)<absOp>))
           -> (match (@this) {
            ((@skip main/Path((@pat@0@1: (std/core/types/list :: V -> V)<fieldName>) : (std/core/types/list :: V -> V)<fieldName>, (@x@0: absOp) : absOp, (@pat@1@2: std/core/types/bool) : std/core/types/bool) : path ) as @pat@3: path)
               -> @x@0;
          });
      }), (match (dependence) {
        ((std/core/types/@Optional((@uniq-dependence@909: std/core/types/bool) : std/core/types/bool) : (std/core/types/@optional :: V -> V)<std/core/types/bool> ) as @pat@3@0: ((std/core/types/@optional :: V -> V)<std/core/types/bool>))
           -> @uniq-dependence@909;
        ((@skip std/core/types/@None() : (std/core/types/@optional :: V -> V)<std/core/types/bool> ) as @pat@4: ((std/core/types/@optional :: V -> V)<std/core/types/bool>))
           -> (match (@this) {
            ((@skip main/Path((@pat@0@2: (std/core/types/list :: V -> V)<fieldName>) : (std/core/types/list :: V -> V)<fieldName>, (@pat@1@3: absOp) : absOp, (@x@1: std/core/types/bool) : std/core/types/bool) : path ) as @pat@5: path)
               -> @x@1;
          });
      }));
  };
inline borrow "^"  fun varName/name // inline size: 0
  = fn(varName: varName){
    match (varName) {
      ((@skip main/VarName((@x: std/core/types/string) : std/core/types/string) : varName ) as @pat: varName)
         -> @x;
    };
  };
 fun varName/@copy // inline size: 2
  = fn(@this: varName, name: (std/core/types/@optional :: V -> V)<std/core/types/string>){
    main/VarName((match (name) {
      ((std/core/types/@Optional((@uniq-name@933: std/core/types/string) : std/core/types/string) : (std/core/types/@optional :: V -> V)<std/core/types/string> ) as @pat: ((std/core/types/@optional :: V -> V)<std/core/types/string>))
         -> @uniq-name@933;
      ((@skip std/core/types/@None() : (std/core/types/@optional :: V -> V)<std/core/types/string> ) as @pat@0: ((std/core/types/@optional :: V -> V)<std/core/types/string>))
         -> (match (@this) {
          ((@skip main/VarName((@x: std/core/types/string) : std/core/types/string) : varName ) as @pat@1: varName)
             -> @x;
        });
    }));
  };
inline borrow "^"  fun exp/id // inline size: 10
  = fn(exp: exp){
    match (exp) {
      ((main/NullE((@x: std/core/types/int) : std/core/types/int) : exp ) as @pat: exp)
         -> @x;
      ((main/LitE((@pat@1: literal) : literal, (@x@0: std/core/types/int) : std/core/types/int) : exp ) as @pat@0: exp)
         -> @x@0;
      ((main/RootE((@x@1: std/core/types/int) : std/core/types/int) : exp ) as @pat@2: exp)
         -> @x@1;
      ((main/DotE((@pat@4: exp) : exp, (@pat@5: fieldName) : fieldName, (@x@2: std/core/types/int) : std/core/types/int) : exp ) as @pat@3: exp)
         -> @x@2;
      ((main/OpE((@pat@7: op) : op, (@pat@8: exp) : exp, (@pat@9: exp) : exp, (@x@3: std/core/types/int) : std/core/types/int) : exp ) as @pat@6: exp)
         -> @x@3;
      ((main/VarE(((@skip main/VarName((@pat@12: std/core/types/string) : std/core/types/string) : varName ) as @pat@11: varName) : varName, (@x@4: std/core/types/int) : std/core/types/int) : exp ) as @pat@10: exp)
         -> @x@4;
      ((main/AsgnE(((@skip main/VarName((@pat@15: std/core/types/string) : std/core/types/string) : varName ) as @pat@14: varName) : varName, (@pat@16: exp) : exp, (@x@5: std/core/types/int) : std/core/types/int) : exp ) as @pat@13: exp)
         -> @x@5;
      ((main/IfE((@pat@18: exp) : exp, (@pat@19: exp) : exp, (@pat@20: exp) : exp, (@x@6: std/core/types/int) : std/core/types/int) : exp ) as @pat@17: exp)
         -> @x@6;
      ((main/ForE(((@skip main/VarName((@pat@23: std/core/types/string) : std/core/types/string) : varName ) as @pat@22: varName) : varName, (@pat@24: exp) : exp, (@pat@25: exp) : exp, (@x@7: std/core/types/int) : std/core/types/int) : exp ) as @pat@21: exp)
         -> @x@7;
      ((main/SeqE((@pat@27: exp) : exp, (@pat@28: exp) : exp, (@x@8: std/core/types/int) : std/core/types/int) : exp ) as @pat@26: exp)
         -> @x@8;
      ((@skip main/PrintE((@pat@30: exp) : exp, (@x@9: std/core/types/int) : std/core/types/int) : exp ) as @pat@29: exp)
         -> @x@9;
    };
  };
inline borrow "^" fip fun is-nullE // inline size: 1
  = fn(exp: exp){
    match (exp) {
      ((main/NullE((@pat@0: std/core/types/int) : std/core/types/int) : exp ) as @pat: exp)
         -> std/core/types/True;
      (@pat@1: exp)
         -> std/core/types/False;
    };
  };
inline borrow "^" fip fun is-litE // inline size: 1
  = fn(exp: exp){
    match (exp) {
      ((main/LitE((@pat@0: literal) : literal, (@pat@1: std/core/types/int) : std/core/types/int) : exp ) as @pat: exp)
         -> std/core/types/True;
      (@pat@2: exp)
         -> std/core/types/False;
    };
  };
inline borrow "^" fip fun is-rootE // inline size: 1
  = fn(exp: exp){
    match (exp) {
      ((main/RootE((@pat@0: std/core/types/int) : std/core/types/int) : exp ) as @pat: exp)
         -> std/core/types/True;
      (@pat@1: exp)
         -> std/core/types/False;
    };
  };
inline borrow "^" fip fun is-dotE // inline size: 1
  = fn(exp: exp){
    match (exp) {
      ((main/DotE((@pat@0: exp) : exp, (@pat@1: fieldName) : fieldName, (@pat@2: std/core/types/int) : std/core/types/int) : exp ) as @pat: exp)
         -> std/core/types/True;
      (@pat@3: exp)
         -> std/core/types/False;
    };
  };
inline borrow "^" fip fun is-opE // inline size: 1
  = fn(exp: exp){
    match (exp) {
      ((main/OpE((@pat@0: op) : op, (@pat@1: exp) : exp, (@pat@2: exp) : exp, (@pat@3: std/core/types/int) : std/core/types/int) : exp ) as @pat: exp)
         -> std/core/types/True;
      (@pat@4: exp)
         -> std/core/types/False;
    };
  };
inline borrow "^" fip fun is-varE // inline size: 1
  = fn(exp: exp){
    match (exp) {
      ((main/VarE(((@skip main/VarName((@pat@1: std/core/types/string) : std/core/types/string) : varName ) as @pat@0: varName) : varName, (@pat@2: std/core/types/int) : std/core/types/int) : exp ) as @pat: exp)
         -> std/core/types/True;
      (@pat@3: exp)
         -> std/core/types/False;
    };
  };
inline borrow "^" fip fun is-asgnE // inline size: 1
  = fn(exp: exp){
    match (exp) {
      ((main/AsgnE(((@skip main/VarName((@pat@1: std/core/types/string) : std/core/types/string) : varName ) as @pat@0: varName) : varName, (@pat@2: exp) : exp, (@pat@3: std/core/types/int) : std/core/types/int) : exp ) as @pat: exp)
         -> std/core/types/True;
      (@pat@4: exp)
         -> std/core/types/False;
    };
  };
inline borrow "^" fip fun is-ifE // inline size: 1
  = fn(exp: exp){
    match (exp) {
      ((main/IfE((@pat@0: exp) : exp, (@pat@1: exp) : exp, (@pat@2: exp) : exp, (@pat@3: std/core/types/int) : std/core/types/int) : exp ) as @pat: exp)
         -> std/core/types/True;
      (@pat@4: exp)
         -> std/core/types/False;
    };
  };
inline borrow "^" fip fun is-forE // inline size: 1
  = fn(exp: exp){
    match (exp) {
      ((main/ForE(((@skip main/VarName((@pat@1: std/core/types/string) : std/core/types/string) : varName ) as @pat@0: varName) : varName, (@pat@2: exp) : exp, (@pat@3: exp) : exp, (@pat@4: std/core/types/int) : std/core/types/int) : exp ) as @pat: exp)
         -> std/core/types/True;
      (@pat@5: exp)
         -> std/core/types/False;
    };
  };
inline borrow "^" fip fun is-seqE // inline size: 1
  = fn(exp: exp){
    match (exp) {
      ((main/SeqE((@pat@0: exp) : exp, (@pat@1: exp) : exp, (@pat@2: std/core/types/int) : std/core/types/int) : exp ) as @pat: exp)
         -> std/core/types/True;
      (@pat@3: exp)
         -> std/core/types/False;
    };
  };
inline borrow "^" fip fun is-printE // inline size: 1
  = fn(exp: exp){
    match (exp) {
      ((main/PrintE((@pat@0: exp) : exp, (@pat@1: std/core/types/int) : std/core/types/int) : exp ) as @pat: exp)
         -> std/core/types/True;
      (@pat@2: exp)
         -> std/core/types/False;
    };
  };
inline borrow "^"  fun attrGrammar/@cfc // inline size: 0
  = forall<(e :: E),a> fn(attrGrammar: (attrGrammar :: (E, V) -> V)<(e :: E),a>){
    (match (attrGrammar) {
      ((@skip main/@Hnd-attrGrammar((@x: std/core/types/int) : std/core/types/int, (@pat@0: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@1: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@2: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@3: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@4: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@5: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@6: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@7: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@8: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@9: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@10: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@11: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@12: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@13: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@14: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@15: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (attrGrammar :: (E, V) -> V)<(e :: E),a> ) as @pat: ((attrGrammar :: (E, V) -> V)<(e :: E),a>))
         -> @x;
    });
  };
inline borrow "^"  fun attrGrammar/@fun-getAbstractValue // inline size: 0
  = forall<(e :: E),a> fn(attrGrammar: (attrGrammar :: (E, V) -> V)<(e :: E),a>){
    (match (attrGrammar) {
      ((@skip main/@Hnd-attrGrammar((@pat@0: std/core/types/int) : std/core/types/int, (@x: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@1: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@2: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@3: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@4: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@5: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@6: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@7: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@8: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@9: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@10: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@11: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@12: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@13: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@14: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@15: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (attrGrammar :: (E, V) -> V)<(e :: E),a> ) as @pat: ((attrGrammar :: (E, V) -> V)<(e :: E),a>))
         -> @x;
    });
  };
inline borrow "^"  fun attrGrammar/@fun-getDataDependence // inline size: 0
  = forall<(e :: E),a> fn(attrGrammar: (attrGrammar :: (E, V) -> V)<(e :: E),a>){
    (match (attrGrammar) {
      ((@skip main/@Hnd-attrGrammar((@pat@0: std/core/types/int) : std/core/types/int, (@pat@1: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@x: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@2: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@3: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@4: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@5: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@6: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@7: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@8: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@9: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@10: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@11: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@12: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@13: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@14: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@15: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (attrGrammar :: (E, V) -> V)<(e :: E),a> ) as @pat: ((attrGrammar :: (E, V) -> V)<(e :: E),a>))
         -> @x;
    });
  };
inline borrow "^"  fun attrGrammar/@fun-getInputStore // inline size: 0
  = forall<(e :: E),a> fn(attrGrammar: (attrGrammar :: (E, V) -> V)<(e :: E),a>){
    (match (attrGrammar) {
      ((@skip main/@Hnd-attrGrammar((@pat@0: std/core/types/int) : std/core/types/int, (@pat@1: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@2: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@x: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@3: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@4: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@5: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@6: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@7: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@8: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@9: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@10: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@11: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@12: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@13: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@14: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@15: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (attrGrammar :: (E, V) -> V)<(e :: E),a> ) as @pat: ((attrGrammar :: (E, V) -> V)<(e :: E),a>))
         -> @x;
    });
  };
inline borrow "^"  fun attrGrammar/@fun-getIteratorContext // inline size: 0
  = forall<(e :: E),a> fn(attrGrammar: (attrGrammar :: (E, V) -> V)<(e :: E),a>){
    (match (attrGrammar) {
      ((@skip main/@Hnd-attrGrammar((@pat@0: std/core/types/int) : std/core/types/int, (@pat@1: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@2: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@3: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@x: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@4: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@5: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@6: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@7: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@8: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@9: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@10: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@11: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@12: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@13: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@14: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@15: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (attrGrammar :: (E, V) -> V)<(e :: E),a> ) as @pat: ((attrGrammar :: (E, V) -> V)<(e :: E),a>))
         -> @x;
    });
  };
inline borrow "^"  fun attrGrammar/@fun-getOutputStore // inline size: 0
  = forall<(e :: E),a> fn(attrGrammar: (attrGrammar :: (E, V) -> V)<(e :: E),a>){
    (match (attrGrammar) {
      ((@skip main/@Hnd-attrGrammar((@pat@0: std/core/types/int) : std/core/types/int, (@pat@1: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@2: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@3: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@4: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@x: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@5: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@6: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@7: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@8: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@9: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@10: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@11: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@12: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@13: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@14: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@15: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (attrGrammar :: (E, V) -> V)<(e :: E),a> ) as @pat: ((attrGrammar :: (E, V) -> V)<(e :: E),a>))
         -> @x;
    });
  };
inline borrow "^"  fun attrGrammar/@fun-getPaths // inline size: 0
  = forall<(e :: E),a> fn(attrGrammar: (attrGrammar :: (E, V) -> V)<(e :: E),a>){
    (match (attrGrammar) {
      ((@skip main/@Hnd-attrGrammar((@pat@0: std/core/types/int) : std/core/types/int, (@pat@1: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@2: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@3: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@4: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@5: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@x: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@6: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@7: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@8: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@9: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@10: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@11: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@12: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@13: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@14: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@15: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (attrGrammar :: (E, V) -> V)<(e :: E),a> ) as @pat: ((attrGrammar :: (E, V) -> V)<(e :: E),a>))
         -> @x;
    });
  };
inline borrow "^"  fun attrGrammar/@fun-getQueryCondition // inline size: 0
  = forall<(e :: E),a> fn(attrGrammar: (attrGrammar :: (E, V) -> V)<(e :: E),a>){
    (match (attrGrammar) {
      ((@skip main/@Hnd-attrGrammar((@pat@0: std/core/types/int) : std/core/types/int, (@pat@1: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@2: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@3: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@4: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@5: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@6: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@x: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@7: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@8: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@9: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@10: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@11: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@12: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@13: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@14: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@15: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (attrGrammar :: (E, V) -> V)<(e :: E),a> ) as @pat: ((attrGrammar :: (E, V) -> V)<(e :: E),a>))
         -> @x;
    });
  };
inline borrow "^"  fun attrGrammar/@fun-getTraversalSummary // inline size: 0
  = forall<(e :: E),a> fn(attrGrammar: (attrGrammar :: (E, V) -> V)<(e :: E),a>){
    (match (attrGrammar) {
      ((@skip main/@Hnd-attrGrammar((@pat@0: std/core/types/int) : std/core/types/int, (@pat@1: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@2: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@3: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@4: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@5: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@6: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@7: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@x: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@8: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@9: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@10: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@11: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@12: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@13: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@14: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@15: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (attrGrammar :: (E, V) -> V)<(e :: E),a> ) as @pat: ((attrGrammar :: (E, V) -> V)<(e :: E),a>))
         -> @x;
    });
  };
inline borrow "^"  fun attrGrammar/@fun-setAbstractValue // inline size: 0
  = forall<(e :: E),a> fn(attrGrammar: (attrGrammar :: (E, V) -> V)<(e :: E),a>){
    (match (attrGrammar) {
      ((@skip main/@Hnd-attrGrammar((@pat@0: std/core/types/int) : std/core/types/int, (@pat@1: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@2: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@3: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@4: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@5: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@6: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@7: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@8: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@x: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@9: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@10: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@11: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@12: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@13: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@14: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@15: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (attrGrammar :: (E, V) -> V)<(e :: E),a> ) as @pat: ((attrGrammar :: (E, V) -> V)<(e :: E),a>))
         -> @x;
    });
  };
inline borrow "^"  fun attrGrammar/@fun-setDataDependence // inline size: 0
  = forall<(e :: E),a> fn(attrGrammar: (attrGrammar :: (E, V) -> V)<(e :: E),a>){
    (match (attrGrammar) {
      ((@skip main/@Hnd-attrGrammar((@pat@0: std/core/types/int) : std/core/types/int, (@pat@1: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@2: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@3: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@4: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@5: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@6: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@7: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@8: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@9: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@x: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@10: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@11: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@12: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@13: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@14: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@15: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (attrGrammar :: (E, V) -> V)<(e :: E),a> ) as @pat: ((attrGrammar :: (E, V) -> V)<(e :: E),a>))
         -> @x;
    });
  };
inline borrow "^"  fun attrGrammar/@fun-setInputStore // inline size: 0
  = forall<(e :: E),a> fn(attrGrammar: (attrGrammar :: (E, V) -> V)<(e :: E),a>){
    (match (attrGrammar) {
      ((@skip main/@Hnd-attrGrammar((@pat@0: std/core/types/int) : std/core/types/int, (@pat@1: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@2: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@3: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@4: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@5: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@6: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@7: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@8: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@9: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@10: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@x: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@11: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@12: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@13: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@14: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@15: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (attrGrammar :: (E, V) -> V)<(e :: E),a> ) as @pat: ((attrGrammar :: (E, V) -> V)<(e :: E),a>))
         -> @x;
    });
  };
inline borrow "^"  fun attrGrammar/@fun-setIteratorContext // inline size: 0
  = forall<(e :: E),a> fn(attrGrammar: (attrGrammar :: (E, V) -> V)<(e :: E),a>){
    (match (attrGrammar) {
      ((@skip main/@Hnd-attrGrammar((@pat@0: std/core/types/int) : std/core/types/int, (@pat@1: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@2: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@3: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@4: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@5: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@6: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@7: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@8: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@9: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@10: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@11: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@x: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@12: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@13: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@14: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@15: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (attrGrammar :: (E, V) -> V)<(e :: E),a> ) as @pat: ((attrGrammar :: (E, V) -> V)<(e :: E),a>))
         -> @x;
    });
  };
inline borrow "^"  fun attrGrammar/@fun-setOutputStore // inline size: 0
  = forall<(e :: E),a> fn(attrGrammar: (attrGrammar :: (E, V) -> V)<(e :: E),a>){
    (match (attrGrammar) {
      ((@skip main/@Hnd-attrGrammar((@pat@0: std/core/types/int) : std/core/types/int, (@pat@1: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@2: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@3: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@4: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@5: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@6: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@7: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@8: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@9: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@10: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@11: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@12: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@x: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@13: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@14: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@15: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (attrGrammar :: (E, V) -> V)<(e :: E),a> ) as @pat: ((attrGrammar :: (E, V) -> V)<(e :: E),a>))
         -> @x;
    });
  };
inline borrow "^"  fun attrGrammar/@fun-setPaths // inline size: 0
  = forall<(e :: E),a> fn(attrGrammar: (attrGrammar :: (E, V) -> V)<(e :: E),a>){
    (match (attrGrammar) {
      ((@skip main/@Hnd-attrGrammar((@pat@0: std/core/types/int) : std/core/types/int, (@pat@1: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@2: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@3: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@4: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@5: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@6: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@7: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@8: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@9: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@10: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@11: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@12: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@13: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@x: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@14: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@15: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (attrGrammar :: (E, V) -> V)<(e :: E),a> ) as @pat: ((attrGrammar :: (E, V) -> V)<(e :: E),a>))
         -> @x;
    });
  };
inline borrow "^"  fun attrGrammar/@fun-setQueryCondition // inline size: 0
  = forall<(e :: E),a> fn(attrGrammar: (attrGrammar :: (E, V) -> V)<(e :: E),a>){
    (match (attrGrammar) {
      ((@skip main/@Hnd-attrGrammar((@pat@0: std/core/types/int) : std/core/types/int, (@pat@1: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@2: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@3: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@4: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@5: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@6: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@7: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@8: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@9: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@10: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@11: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@12: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@13: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@14: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@x: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@15: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (attrGrammar :: (E, V) -> V)<(e :: E),a> ) as @pat: ((attrGrammar :: (E, V) -> V)<(e :: E),a>))
         -> @x;
    });
  };
inline borrow "^"  fun attrGrammar/@fun-setTraversalSummary // inline size: 0
  = forall<(e :: E),a> fn(attrGrammar: (attrGrammar :: (E, V) -> V)<(e :: E),a>){
    (match (attrGrammar) {
      ((@skip main/@Hnd-attrGrammar((@pat@0: std/core/types/int) : std/core/types/int, (@pat@1: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@2: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@3: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@4: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@5: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@6: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@7: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@8: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@9: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@10: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@11: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@12: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@13: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@14: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@15: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@x: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (attrGrammar :: (E, V) -> V)<(e :: E),a> ) as @pat: ((attrGrammar :: (E, V) -> V)<(e :: E),a>))
         -> @x;
    });
  };
inline borrow "^"  fun fixpoint/@cfc // inline size: 0
  = forall<(e :: E),a> fn(fixpoint: (fixpoint :: (E, V) -> V)<(e :: E),a>){
    (match (fixpoint) {
      ((@skip main/@Hnd-fixpoint((@x: std/core/types/int) : std/core/types/int, (@pat@0: (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<(),(fixpoint :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<(),(fixpoint :: (E, V) -> V),(e :: E),a>) : (fixpoint :: (E, V) -> V)<(e :: E),a> ) as @pat: ((fixpoint :: (E, V) -> V)<(e :: E),a>))
         -> @x;
    });
  };
inline borrow "^"  fun fixpoint/@fun-modified // inline size: 0
  = forall<(e :: E),a> fn(fixpoint: (fixpoint :: (E, V) -> V)<(e :: E),a>){
    (match (fixpoint) {
      ((@skip main/@Hnd-fixpoint((@pat@0: std/core/types/int) : std/core/types/int, (@x: (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<(),(fixpoint :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<(),(fixpoint :: (E, V) -> V),(e :: E),a>) : (fixpoint :: (E, V) -> V)<(e :: E),a> ) as @pat: ((fixpoint :: (E, V) -> V)<(e :: E),a>))
         -> @x;
    });
  };
inline borrow "^"  fun nondet/@cfc // inline size: 0
  = forall<(e :: E),a> fn(nondet: (nondet :: (E, V) -> V)<(e :: E),a>){
    (match (nondet) {
      ((@skip main/@Hnd-nondet((@x: std/core/types/int) : std/core/types/int, (@pat@0: forall<b> (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<b,b,b,(nondet :: (E, V) -> V),(e :: E),a>) : forall<b> (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<b,b,b,(nondet :: (E, V) -> V),(e :: E),a>, (@pat@1: (forall<b> (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<b,(nondet :: (E, V) -> V),(e :: E),a>)) : (forall<b> (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<b,(nondet :: (E, V) -> V),(e :: E),a>)) : (nondet :: (E, V) -> V)<(e :: E),a> ) as @pat: ((nondet :: (E, V) -> V)<(e :: E),a>))
         -> @x;
    });
  };
inline borrow "^"  fun nondet/@ctl-choose // inline size: 0
  = forall<(e :: E),a,b> fn(nondet: (nondet :: (E, V) -> V)<(e :: E),a>){
    (match (nondet) {
      ((@skip main/@Hnd-nondet((@pat@0: std/core/types/int) : std/core/types/int, (@x: forall<c> (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<c,c,c,(nondet :: (E, V) -> V),(e :: E),a>) : forall<c> (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<c,c,c,(nondet :: (E, V) -> V),(e :: E),a>, (@pat@1: (forall<c> (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<c,(nondet :: (E, V) -> V),(e :: E),a>)) : (forall<c> (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<c,(nondet :: (E, V) -> V),(e :: E),a>)) : (nondet :: (E, V) -> V)<(e :: E),a> ) as @pat: ((nondet :: (E, V) -> V)<(e :: E),a>))
         -> @x<b>;
    });
  };
inline borrow "^"  fun nondet/@brk-fail // inline size: 0
  = forall<(e :: E),a,b> fn(nondet: (nondet :: (E, V) -> V)<(e :: E),a>){
    (match (nondet) {
      ((@skip main/@Hnd-nondet((@pat@0: std/core/types/int) : std/core/types/int, (@pat@1: forall<c> (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<c,c,c,(nondet :: (E, V) -> V),(e :: E),a>) : forall<c> (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<c,c,c,(nondet :: (E, V) -> V),(e :: E),a>, (@x: (forall<c> (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<c,(nondet :: (E, V) -> V),(e :: E),a>)) : (forall<c> (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<c,(nondet :: (E, V) -> V),(e :: E),a>)) : (nondet :: (E, V) -> V)<(e :: E),a> ) as @pat: ((nondet :: (E, V) -> V)<(e :: E),a>))
         -> @x<b>;
    });
  };
 fun fieldName/show // inline size: 3
  = fn(fieldName: fieldName){
    match (fieldName) {
      ((main/FNNamed((name: std/core/types/string) : std/core/types/string) : fieldName ) as @pat: fieldName)
         -> std/core/types/(++)("FNNamed(", (std/core/types/(++)(name, ")")));
      ((@skip main/FNL() : fieldName ) as @pat@0: fieldName)
         -> "FNL";
    };
  };
 fun varName/show // inline size: 2
  = fn(varName: varName){
    std/core/types/(++)("VarName(", (std/core/types/(++)((match (varName) {
          ((@skip main/VarName((@x: std/core/types/string) : std/core/types/string) : varName ) as @pat: varName)
             -> @x;
        }), ")")));
  };
 fun op/show // inline size: 4
  = fn(op: op){
    match (op) {
      ((main/AndOp() : op ) as @pat: op)
         -> "AndOp";
      ((main/NotOp() : op ) as @pat@0: op)
         -> "NotOp";
      ((main/EqOp() : op ) as @pat@1: op)
         -> "EqOp";
      ((main/GtOp() : op ) as @pat@2: op)
         -> "GtOp";
      ((@skip main/PlusOp() : op ) as @pat@3: op)
         -> "PlusOp";
    };
  };
 fun hashset/show // inline size: 2
  = forall<a> fn(set: (std/data/hashset/hash-set :: V -> V)<a>, @implicit/show: (a) -> std/core/types/string){
    std/core/list/show<a,(std/core/types/total :: E)>((main/#hashset/list<a>(set)), @implicit/show);
  };
 fun literal/show // inline size: 3
  = fn(lit: literal){
    match (lit) {
      ((main/StringLit((str: std/core/types/string) : std/core/types/string) : literal ) as @pat: literal)
         -> std/core/show/#string/show(str);
      ((@skip main/NumberLit((num: std/core/types/int) : std/core/types/int) : literal ) as @pat@0: literal)
         -> std/core/int/show(num);
    };
  };
 fun absOp/show // inline size: 3
  = fn(absOp: absOp){
    std/core/undiv/pretend-nodiv-cast<(std/core/types/total :: E),std/core/types/string>((fn<<(std/core/types/div :: X)>>(){
      (main/#absOp/showDiv(absOp));
    }))();
  };
 fun absValue/show // inline size: 3
  = fn(absValue: absValue){
    std/core/undiv/pretend-nodiv-cast<(std/core/types/total :: E),std/core/types/string>((fn<<(std/core/types/div :: X)>>(){
      (main/#absValue/showDiv(absValue));
    }))();
  };
 fun path/show // inline size: 3
  = fn(path: path){
    std/core/undiv/pretend-nodiv-cast<(std/core/types/total :: E),std/core/types/string>((fn<<(std/core/types/div :: X)>>(){
      (main/#path/showDiv(path));
    }))();
  };
 fun store/show // inline size: 1
  = fn(store: store){
    main/#hashmap/show<varName,absValue>(store, main/#varName/show, main/#absValue/show);
  };
 fun hashset/(==) // inline size: 3
  = forall<a> fn(a: (std/data/hashset/hash-set :: V -> V)<a>, b: (std/data/hashset/hash-set :: V -> V)<a>, @implicit/(==): (a, a) -> std/core/types/bool){
    std/core/list/(==)<a>((main/#hashset/list<a>(a)), (main/#hashset/list<a>(b)), @implicit/(==));
  };
 fun literal/(==) // inline size: 4
  = fn(a: literal, b: literal){
    match (a, b) {
      ((main/StringLit((bStr: std/core/types/string) : std/core/types/string) : literal ) as @pat@1: literal), ((main/StringLit((aStr: std/core/types/string) : std/core/types/string) : literal ) as @pat@0: literal)
         -> std/core/string/(==)(aStr, bStr);
      ((main/NumberLit((bNum: std/core/types/int) : std/core/types/int) : literal ) as @pat@4: literal), ((main/NumberLit((aNum: std/core/types/int) : std/core/types/int) : literal ) as @pat@3: literal)
         -> std/core/int/(==)(aNum, bNum);
      (@pat@2: literal), (@pat: literal)
         -> std/core/types/False;
    };
  };
 fun fieldName/(==) // inline size: 3
  = fn(a: fieldName, b: fieldName){
    match (a, b) {
      ((main/FNNamed((bName: std/core/types/string) : std/core/types/string) : fieldName ) as @pat@1: fieldName), ((main/FNNamed((aName: std/core/types/string) : std/core/types/string) : fieldName ) as @pat@0: fieldName)
         -> std/core/string/(==)(aName, bName);
      ((main/FNL() : fieldName ) as @pat@4: fieldName), ((main/FNL() : fieldName ) as @pat@3: fieldName)
         -> std/core/types/True;
      (@pat@2: fieldName), (@pat: fieldName)
         -> std/core/types/False;
    };
  };
 fun absOp/(==) // inline size: 3
  = fn(a: absOp, b: absOp){
    std/core/undiv/pretend-nodiv-cast<(std/core/types/total :: E),std/core/types/bool>((fn<<(std/core/types/div :: X)>>(){
      (main/#absOp/eqDiv(a, b));
    }))();
  };
 fun absValue/(==) // inline size: 3
  = fn(a: absValue, b: absValue){
    std/core/undiv/pretend-nodiv-cast<(std/core/types/total :: E),std/core/types/bool>((fn<<(std/core/types/div :: X)>>(){
      (main/#absValue/eqDiv(a, b));
    }))();
  };
 fun varName/(==) // inline size: 1
  = fn(a: varName, b: varName){
    std/core/string/(==)((match (a) {
        ((@skip main/VarName((@x: std/core/types/string) : std/core/types/string) : varName ) as @pat: varName)
           -> @x;
      }), (match (b) {
        ((@skip main/VarName((@x@0: std/core/types/string) : std/core/types/string) : varName ) as @pat@0: varName)
           -> @x@0;
      }));
  };
 fun exp/(==) // inline size: 3
  = fn(a: exp, b: exp){
    std/core/undiv/pretend-nodiv-cast<(std/core/types/total :: E),std/core/types/bool>((fn<<(std/core/types/div :: X)>>(){
      (main/#exp/eqDiv(a, b));
    }))();
  };
 fun path/(==) // inline size: 3
  = fn(a: path, b: path){
    std/core/undiv/pretend-nodiv-cast<(std/core/types/total :: E),std/core/types/bool>((fn<<(std/core/types/div :: X)>>(){
      (main/#path/eqDiv(a, b));
    }))();
  };
 fun hashset/union // inline size: 4
  = forall<a> fn(a: (std/data/hashset/hash-set :: V -> V)<a>, b: (std/data/hashset/hash-set :: V -> V)<a>, @implicit/(==): (a, a) -> std/core/types/bool, @implicit/hash: (a, std/core/types/int64) -> std/core/types/int){
    val xs@10078[1,0,1,0] : (std/core/types/list :: V -> V)<a>
      = main/#hashset/list<a>(a);
    val ys@10079[1,0,1,0] : (std/core/types/list :: V -> V)<a>
      = main/#hashset/list<a>(b);
    std/data/hashset/#thread/list/hash-set<a>((std/core/list/append<a>(xs@10078, ys@10079)), @implicit/hash, @implicit/(==));
  };
 fun op/hash // inline size: 4
  = fn(op: op, x: std/core/types/int64){
    match (op) {
      ((main/AndOp() : op ) as @pat: op)
         -> 0;
      ((main/NotOp() : op ) as @pat@0: op)
         -> 1;
      ((main/EqOp() : op ) as @pat@1: op)
         -> 2;
      ((main/GtOp() : op ) as @pat@2: op)
         -> 3;
      ((@skip main/PlusOp() : op ) as @pat@3: op)
         -> 4;
    };
  };
 fun literal/hash // inline size: 3
  = fn(a: literal, x: std/core/types/int64){
    match (a) {
      ((main/StringLit((str: std/core/types/string) : std/core/types/string) : literal ) as @pat: literal)
         -> std/data/hash/#string/hash(str, x);
      ((@skip main/NumberLit((num: std/core/types/int) : std/core/types/int) : literal ) as @pat@0: literal)
         -> std/data/hash/extern-int-hash(num, x);
    };
  };
 fun fieldName/hash // inline size: 2
  = fn(fieldName: fieldName, x: std/core/types/int64){
    match (fieldName) {
      ((main/FNNamed((name: std/core/types/string) : std/core/types/string) : fieldName ) as @pat: fieldName)
         -> std/data/hash/#string/hash(name, x);
      ((@skip main/FNL() : fieldName ) as @pat@0: fieldName)
         -> 0;
    };
  };
 fun absOp/hash // inline size: 3
  = fn(absOp: absOp, x: std/core/types/int64){
    std/core/undiv/pretend-nodiv-cast<(std/core/types/total :: E),std/core/types/int>((fn<<(std/core/types/div :: X)>>(){
      (main/#absOp/divHash(absOp, x));
    }))();
  };
 fun absValue/hash // inline size: 3
  = fn(absValue: absValue, x: std/core/types/int64){
    std/core/undiv/pretend-nodiv-cast<(std/core/types/total :: E),std/core/types/int>((fn<<(std/core/types/div :: X)>>(){
      (main/#absValue/divHash(absValue, x));
    }))();
  };
 fun varName/hash // inline size: 1
  = fn(varName: varName, x: std/core/types/int64){
    std/data/hash/#string/hash((match (varName) {
        ((@skip main/VarName((@x: std/core/types/string) : std/core/types/string) : varName ) as @pat: varName)
           -> @x;
      }), x);
  };
 fun path/hash // inline size: 3
  = fn(path: path, x: std/core/types/int64){
    std/core/undiv/pretend-nodiv-cast<(std/core/types/total :: E),std/core/types/int>((fn<<(std/core/types/div :: X)>>(){
      (main/#path/divHash(path, x));
    }))();
  };
inline borrow "^"  fun @select-getAbstractValue // inline size: 0
  = forall<(e :: E),a> fn(hnd: (attrGrammar :: (E, V) -> V)<(e :: E),a>){
    (match (hnd) {
      ((@skip main/@Hnd-attrGrammar((@pat@0: std/core/types/int) : std/core/types/int, (@fun-getAbstractValue: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@1: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@2: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@3: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@4: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@5: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@6: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@7: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@8: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@9: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@10: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@11: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@12: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@13: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@14: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@15: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (attrGrammar :: (E, V) -> V)<(e :: E),a> ) as @pat: ((attrGrammar :: (E, V) -> V)<(e :: E),a>))
         -> @fun-getAbstractValue;
    });
  };
inline  fun getAbstractValue // inline size: 5
  = fn<<(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>>>(exp: exp){
    std/core/hnd/@perform1<exp,absValue,(attrGrammar :: (E, V) -> V),<(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>>>((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>>,(i : std/core/hnd/ev-index) -> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(attrGrammar :: (E, V) -> V)>,(i : std/core/hnd/ev-index) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(attrGrammar :: (E, V) -> V)>>((std/core/hnd/@evv-at<(attrGrammar :: (E, V) -> V)>))((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>>,(i : std/core/types/int) -> std/core/types/ssize_t,(i : std/core/types/int) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>> std/core/types/ssize_t>(std/core/types/@make-ssize_t)(0)))), main/@select-getAbstractValue, exp);
  };
inline borrow "^"  fun @select-setAbstractValue // inline size: 0
  = forall<(e :: E),a> fn(hnd: (attrGrammar :: (E, V) -> V)<(e :: E),a>){
    (match (hnd) {
      ((@skip main/@Hnd-attrGrammar((@pat@0: std/core/types/int) : std/core/types/int, (@pat@1: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@2: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@3: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@4: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@5: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@6: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@7: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@8: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@fun-setAbstractValue: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@9: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@10: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@11: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@12: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@13: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@14: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@15: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (attrGrammar :: (E, V) -> V)<(e :: E),a> ) as @pat: ((attrGrammar :: (E, V) -> V)<(e :: E),a>))
         -> @fun-setAbstractValue;
    });
  };
inline  fun setAbstractValue // inline size: 5
  = fn<<(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>>>(exp: exp, absValue: absValue){
    std/core/hnd/@perform2<exp,absValue,(),<(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>>,(attrGrammar :: (E, V) -> V)>((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>>,(i : std/core/hnd/ev-index) -> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(attrGrammar :: (E, V) -> V)>,(i : std/core/hnd/ev-index) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(attrGrammar :: (E, V) -> V)>>((std/core/hnd/@evv-at<(attrGrammar :: (E, V) -> V)>))((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>>,(i : std/core/types/int) -> std/core/types/ssize_t,(i : std/core/types/int) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>> std/core/types/ssize_t>(std/core/types/@make-ssize_t)(0)))), main/@select-setAbstractValue, exp, absValue);
  };
inline borrow "^"  fun @select-getPaths // inline size: 0
  = forall<(e :: E),a> fn(hnd: (attrGrammar :: (E, V) -> V)<(e :: E),a>){
    (match (hnd) {
      ((@skip main/@Hnd-attrGrammar((@pat@0: std/core/types/int) : std/core/types/int, (@pat@1: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@2: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@3: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@4: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@5: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@fun-getPaths: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@6: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@7: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@8: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@9: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@10: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@11: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@12: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@13: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@14: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@15: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (attrGrammar :: (E, V) -> V)<(e :: E),a> ) as @pat: ((attrGrammar :: (E, V) -> V)<(e :: E),a>))
         -> @fun-getPaths;
    });
  };
inline  fun getPaths // inline size: 5
  = fn<<(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>>>(exp: exp){
    std/core/hnd/@perform1<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),<(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>>>((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>>,(i : std/core/hnd/ev-index) -> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(attrGrammar :: (E, V) -> V)>,(i : std/core/hnd/ev-index) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(attrGrammar :: (E, V) -> V)>>((std/core/hnd/@evv-at<(attrGrammar :: (E, V) -> V)>))((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>>,(i : std/core/types/int) -> std/core/types/ssize_t,(i : std/core/types/int) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>> std/core/types/ssize_t>(std/core/types/@make-ssize_t)(0)))), main/@select-getPaths, exp);
  };
inline borrow "^"  fun @select-setPaths // inline size: 0
  = forall<(e :: E),a> fn(hnd: (attrGrammar :: (E, V) -> V)<(e :: E),a>){
    (match (hnd) {
      ((@skip main/@Hnd-attrGrammar((@pat@0: std/core/types/int) : std/core/types/int, (@pat@1: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@2: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@3: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@4: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@5: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@6: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@7: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@8: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@9: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@10: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@11: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@12: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@13: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@fun-setPaths: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@14: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@15: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (attrGrammar :: (E, V) -> V)<(e :: E),a> ) as @pat: ((attrGrammar :: (E, V) -> V)<(e :: E),a>))
         -> @fun-setPaths;
    });
  };
inline  fun setPaths // inline size: 5
  = fn<<(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>>>(exp: exp, paths: (std/data/hashset/hash-set :: V -> V)<path>){
    std/core/hnd/@perform2<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),<(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>>,(attrGrammar :: (E, V) -> V)>((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>>,(i : std/core/hnd/ev-index) -> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(attrGrammar :: (E, V) -> V)>,(i : std/core/hnd/ev-index) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(attrGrammar :: (E, V) -> V)>>((std/core/hnd/@evv-at<(attrGrammar :: (E, V) -> V)>))((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>>,(i : std/core/types/int) -> std/core/types/ssize_t,(i : std/core/types/int) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>> std/core/types/ssize_t>(std/core/types/@make-ssize_t)(0)))), main/@select-setPaths, exp, paths);
  };
inline borrow "^"  fun @select-getOutputStore // inline size: 0
  = forall<(e :: E),a> fn(hnd: (attrGrammar :: (E, V) -> V)<(e :: E),a>){
    (match (hnd) {
      ((@skip main/@Hnd-attrGrammar((@pat@0: std/core/types/int) : std/core/types/int, (@pat@1: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@2: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@3: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@4: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@fun-getOutputStore: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@5: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@6: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@7: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@8: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@9: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@10: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@11: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@12: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@13: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@14: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@15: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (attrGrammar :: (E, V) -> V)<(e :: E),a> ) as @pat: ((attrGrammar :: (E, V) -> V)<(e :: E),a>))
         -> @fun-getOutputStore;
    });
  };
inline  fun getOutputStore // inline size: 5
  = fn<<(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>>>(exp: exp){
    std/core/hnd/@perform1<exp,store,(attrGrammar :: (E, V) -> V),<(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>>>((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>>,(i : std/core/hnd/ev-index) -> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(attrGrammar :: (E, V) -> V)>,(i : std/core/hnd/ev-index) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(attrGrammar :: (E, V) -> V)>>((std/core/hnd/@evv-at<(attrGrammar :: (E, V) -> V)>))((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>>,(i : std/core/types/int) -> std/core/types/ssize_t,(i : std/core/types/int) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>> std/core/types/ssize_t>(std/core/types/@make-ssize_t)(0)))), main/@select-getOutputStore, exp);
  };
inline borrow "^"  fun @select-setOutputStore // inline size: 0
  = forall<(e :: E),a> fn(hnd: (attrGrammar :: (E, V) -> V)<(e :: E),a>){
    (match (hnd) {
      ((@skip main/@Hnd-attrGrammar((@pat@0: std/core/types/int) : std/core/types/int, (@pat@1: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@2: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@3: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@4: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@5: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@6: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@7: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@8: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@9: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@10: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@11: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@12: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@fun-setOutputStore: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@13: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@14: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@15: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (attrGrammar :: (E, V) -> V)<(e :: E),a> ) as @pat: ((attrGrammar :: (E, V) -> V)<(e :: E),a>))
         -> @fun-setOutputStore;
    });
  };
inline  fun setOutputStore // inline size: 5
  = fn<<(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>>>(exp: exp, store: store){
    std/core/hnd/@perform2<exp,store,(),<(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>>,(attrGrammar :: (E, V) -> V)>((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>>,(i : std/core/hnd/ev-index) -> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(attrGrammar :: (E, V) -> V)>,(i : std/core/hnd/ev-index) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(attrGrammar :: (E, V) -> V)>>((std/core/hnd/@evv-at<(attrGrammar :: (E, V) -> V)>))((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>>,(i : std/core/types/int) -> std/core/types/ssize_t,(i : std/core/types/int) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>> std/core/types/ssize_t>(std/core/types/@make-ssize_t)(0)))), main/@select-setOutputStore, exp, store);
  };
inline borrow "^"  fun @select-getInputStore // inline size: 0
  = forall<(e :: E),a> fn(hnd: (attrGrammar :: (E, V) -> V)<(e :: E),a>){
    (match (hnd) {
      ((@skip main/@Hnd-attrGrammar((@pat@0: std/core/types/int) : std/core/types/int, (@pat@1: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@2: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@fun-getInputStore: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@3: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@4: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@5: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@6: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@7: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@8: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@9: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@10: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@11: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@12: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@13: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@14: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@15: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (attrGrammar :: (E, V) -> V)<(e :: E),a> ) as @pat: ((attrGrammar :: (E, V) -> V)<(e :: E),a>))
         -> @fun-getInputStore;
    });
  };
inline  fun getInputStore // inline size: 5
  = fn<<(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>>>(exp: exp){
    std/core/hnd/@perform1<exp,store,(attrGrammar :: (E, V) -> V),<(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>>>((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>>,(i : std/core/hnd/ev-index) -> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(attrGrammar :: (E, V) -> V)>,(i : std/core/hnd/ev-index) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(attrGrammar :: (E, V) -> V)>>((std/core/hnd/@evv-at<(attrGrammar :: (E, V) -> V)>))((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>>,(i : std/core/types/int) -> std/core/types/ssize_t,(i : std/core/types/int) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>> std/core/types/ssize_t>(std/core/types/@make-ssize_t)(0)))), main/@select-getInputStore, exp);
  };
inline borrow "^"  fun @select-setInputStore // inline size: 0
  = forall<(e :: E),a> fn(hnd: (attrGrammar :: (E, V) -> V)<(e :: E),a>){
    (match (hnd) {
      ((@skip main/@Hnd-attrGrammar((@pat@0: std/core/types/int) : std/core/types/int, (@pat@1: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@2: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@3: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@4: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@5: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@6: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@7: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@8: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@9: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@10: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@fun-setInputStore: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@11: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@12: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@13: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@14: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@15: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (attrGrammar :: (E, V) -> V)<(e :: E),a> ) as @pat: ((attrGrammar :: (E, V) -> V)<(e :: E),a>))
         -> @fun-setInputStore;
    });
  };
inline  fun setInputStore // inline size: 5
  = fn<<(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>>>(exp: exp, store: store){
    std/core/hnd/@perform2<exp,store,(),<(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>>,(attrGrammar :: (E, V) -> V)>((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>>,(i : std/core/hnd/ev-index) -> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(attrGrammar :: (E, V) -> V)>,(i : std/core/hnd/ev-index) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(attrGrammar :: (E, V) -> V)>>((std/core/hnd/@evv-at<(attrGrammar :: (E, V) -> V)>))((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>>,(i : std/core/types/int) -> std/core/types/ssize_t,(i : std/core/types/int) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>> std/core/types/ssize_t>(std/core/types/@make-ssize_t)(0)))), main/@select-setInputStore, exp, store);
  };
inline borrow "^"  fun @select-getQueryCondition // inline size: 0
  = forall<(e :: E),a> fn(hnd: (attrGrammar :: (E, V) -> V)<(e :: E),a>){
    (match (hnd) {
      ((@skip main/@Hnd-attrGrammar((@pat@0: std/core/types/int) : std/core/types/int, (@pat@1: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@2: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@3: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@4: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@5: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@6: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@fun-getQueryCondition: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@7: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@8: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@9: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@10: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@11: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@12: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@13: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@14: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@15: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (attrGrammar :: (E, V) -> V)<(e :: E),a> ) as @pat: ((attrGrammar :: (E, V) -> V)<(e :: E),a>))
         -> @fun-getQueryCondition;
    });
  };
inline  fun getQueryCondition // inline size: 5
  = fn<<(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>>>(exp: exp){
    std/core/hnd/@perform1<exp,absOp,(attrGrammar :: (E, V) -> V),<(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>>>((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>>,(i : std/core/hnd/ev-index) -> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(attrGrammar :: (E, V) -> V)>,(i : std/core/hnd/ev-index) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(attrGrammar :: (E, V) -> V)>>((std/core/hnd/@evv-at<(attrGrammar :: (E, V) -> V)>))((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>>,(i : std/core/types/int) -> std/core/types/ssize_t,(i : std/core/types/int) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>> std/core/types/ssize_t>(std/core/types/@make-ssize_t)(0)))), main/@select-getQueryCondition, exp);
  };
inline borrow "^"  fun @select-setQueryCondition // inline size: 0
  = forall<(e :: E),a> fn(hnd: (attrGrammar :: (E, V) -> V)<(e :: E),a>){
    (match (hnd) {
      ((@skip main/@Hnd-attrGrammar((@pat@0: std/core/types/int) : std/core/types/int, (@pat@1: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@2: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@3: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@4: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@5: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@6: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@7: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@8: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@9: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@10: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@11: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@12: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@13: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@14: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@fun-setQueryCondition: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@15: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (attrGrammar :: (E, V) -> V)<(e :: E),a> ) as @pat: ((attrGrammar :: (E, V) -> V)<(e :: E),a>))
         -> @fun-setQueryCondition;
    });
  };
inline  fun setQueryCondition // inline size: 5
  = fn<<(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>>>(exp: exp, absOp: absOp){
    std/core/hnd/@perform2<exp,absOp,(),<(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>>,(attrGrammar :: (E, V) -> V)>((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>>,(i : std/core/hnd/ev-index) -> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(attrGrammar :: (E, V) -> V)>,(i : std/core/hnd/ev-index) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(attrGrammar :: (E, V) -> V)>>((std/core/hnd/@evv-at<(attrGrammar :: (E, V) -> V)>))((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>>,(i : std/core/types/int) -> std/core/types/ssize_t,(i : std/core/types/int) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>> std/core/types/ssize_t>(std/core/types/@make-ssize_t)(0)))), main/@select-setQueryCondition, exp, absOp);
  };
inline borrow "^"  fun @select-getDataDependence // inline size: 0
  = forall<(e :: E),a> fn(hnd: (attrGrammar :: (E, V) -> V)<(e :: E),a>){
    (match (hnd) {
      ((@skip main/@Hnd-attrGrammar((@pat@0: std/core/types/int) : std/core/types/int, (@pat@1: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@fun-getDataDependence: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@2: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@3: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@4: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@5: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@6: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@7: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@8: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@9: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@10: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@11: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@12: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@13: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@14: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@15: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (attrGrammar :: (E, V) -> V)<(e :: E),a> ) as @pat: ((attrGrammar :: (E, V) -> V)<(e :: E),a>))
         -> @fun-getDataDependence;
    });
  };
inline  fun getDataDependence // inline size: 5
  = fn<<(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>>>(exp: exp){
    std/core/hnd/@perform1<exp,std/core/types/bool,(attrGrammar :: (E, V) -> V),<(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>>>((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>>,(i : std/core/hnd/ev-index) -> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(attrGrammar :: (E, V) -> V)>,(i : std/core/hnd/ev-index) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(attrGrammar :: (E, V) -> V)>>((std/core/hnd/@evv-at<(attrGrammar :: (E, V) -> V)>))((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>>,(i : std/core/types/int) -> std/core/types/ssize_t,(i : std/core/types/int) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>> std/core/types/ssize_t>(std/core/types/@make-ssize_t)(0)))), main/@select-getDataDependence, exp);
  };
inline borrow "^"  fun @select-setDataDependence // inline size: 0
  = forall<(e :: E),a> fn(hnd: (attrGrammar :: (E, V) -> V)<(e :: E),a>){
    (match (hnd) {
      ((@skip main/@Hnd-attrGrammar((@pat@0: std/core/types/int) : std/core/types/int, (@pat@1: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@2: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@3: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@4: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@5: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@6: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@7: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@8: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@9: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@fun-setDataDependence: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@10: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@11: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@12: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@13: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@14: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@15: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (attrGrammar :: (E, V) -> V)<(e :: E),a> ) as @pat: ((attrGrammar :: (E, V) -> V)<(e :: E),a>))
         -> @fun-setDataDependence;
    });
  };
inline  fun setDataDependence // inline size: 5
  = fn<<(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>>>(exp: exp, dependence: std/core/types/bool){
    std/core/hnd/@perform2<exp,std/core/types/bool,(),<(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>>,(attrGrammar :: (E, V) -> V)>((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>>,(i : std/core/hnd/ev-index) -> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(attrGrammar :: (E, V) -> V)>,(i : std/core/hnd/ev-index) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(attrGrammar :: (E, V) -> V)>>((std/core/hnd/@evv-at<(attrGrammar :: (E, V) -> V)>))((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>>,(i : std/core/types/int) -> std/core/types/ssize_t,(i : std/core/types/int) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>> std/core/types/ssize_t>(std/core/types/@make-ssize_t)(0)))), main/@select-setDataDependence, exp, dependence);
  };
inline borrow "^"  fun @select-getIteratorContext // inline size: 0
  = forall<(e :: E),a> fn(hnd: (attrGrammar :: (E, V) -> V)<(e :: E),a>){
    (match (hnd) {
      ((@skip main/@Hnd-attrGrammar((@pat@0: std/core/types/int) : std/core/types/int, (@pat@1: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@2: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@3: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@fun-getIteratorContext: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@4: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@5: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@6: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@7: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@8: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@9: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@10: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@11: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@12: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@13: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@14: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@15: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (attrGrammar :: (E, V) -> V)<(e :: E),a> ) as @pat: ((attrGrammar :: (E, V) -> V)<(e :: E),a>))
         -> @fun-getIteratorContext;
    });
  };
inline  fun getIteratorContext // inline size: 5
  = fn<<(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>>>(exp: exp){
    std/core/hnd/@perform1<exp,(std/core/types/list :: V -> V)<path>,(attrGrammar :: (E, V) -> V),<(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>>>((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>>,(i : std/core/hnd/ev-index) -> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(attrGrammar :: (E, V) -> V)>,(i : std/core/hnd/ev-index) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(attrGrammar :: (E, V) -> V)>>((std/core/hnd/@evv-at<(attrGrammar :: (E, V) -> V)>))((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>>,(i : std/core/types/int) -> std/core/types/ssize_t,(i : std/core/types/int) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>> std/core/types/ssize_t>(std/core/types/@make-ssize_t)(0)))), main/@select-getIteratorContext, exp);
  };
inline borrow "^"  fun @select-setIteratorContext // inline size: 0
  = forall<(e :: E),a> fn(hnd: (attrGrammar :: (E, V) -> V)<(e :: E),a>){
    (match (hnd) {
      ((@skip main/@Hnd-attrGrammar((@pat@0: std/core/types/int) : std/core/types/int, (@pat@1: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@2: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@3: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@4: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@5: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@6: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@7: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@8: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@9: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@10: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@11: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@fun-setIteratorContext: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@12: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@13: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@14: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@15: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (attrGrammar :: (E, V) -> V)<(e :: E),a> ) as @pat: ((attrGrammar :: (E, V) -> V)<(e :: E),a>))
         -> @fun-setIteratorContext;
    });
  };
inline  fun setIteratorContext // inline size: 5
  = fn<<(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>>>(exp: exp, paths: (std/core/types/list :: V -> V)<path>){
    std/core/hnd/@perform2<exp,(std/core/types/list :: V -> V)<path>,(),<(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>>,(attrGrammar :: (E, V) -> V)>((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>>,(i : std/core/hnd/ev-index) -> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(attrGrammar :: (E, V) -> V)>,(i : std/core/hnd/ev-index) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(attrGrammar :: (E, V) -> V)>>((std/core/hnd/@evv-at<(attrGrammar :: (E, V) -> V)>))((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>>,(i : std/core/types/int) -> std/core/types/ssize_t,(i : std/core/types/int) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>> std/core/types/ssize_t>(std/core/types/@make-ssize_t)(0)))), main/@select-setIteratorContext, exp, paths);
  };
inline borrow "^"  fun @select-getTraversalSummary // inline size: 0
  = forall<(e :: E),a> fn(hnd: (attrGrammar :: (E, V) -> V)<(e :: E),a>){
    (match (hnd) {
      ((@skip main/@Hnd-attrGrammar((@pat@0: std/core/types/int) : std/core/types/int, (@pat@1: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@2: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@3: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@4: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@5: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@6: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@7: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@fun-getTraversalSummary: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@8: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@9: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@10: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@11: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@12: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@13: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@14: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@15: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (attrGrammar :: (E, V) -> V)<(e :: E),a> ) as @pat: ((attrGrammar :: (E, V) -> V)<(e :: E),a>))
         -> @fun-getTraversalSummary;
    });
  };
inline  fun getTraversalSummary // inline size: 5
  = fn<<(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>>>(exp: exp){
    std/core/hnd/@perform1<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),<(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>>>((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>>,(i : std/core/hnd/ev-index) -> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(attrGrammar :: (E, V) -> V)>,(i : std/core/hnd/ev-index) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(attrGrammar :: (E, V) -> V)>>((std/core/hnd/@evv-at<(attrGrammar :: (E, V) -> V)>))((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>>,(i : std/core/types/int) -> std/core/types/ssize_t,(i : std/core/types/int) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>> std/core/types/ssize_t>(std/core/types/@make-ssize_t)(0)))), main/@select-getTraversalSummary, exp);
  };
inline borrow "^"  fun @select-setTraversalSummary // inline size: 0
  = forall<(e :: E),a> fn(hnd: (attrGrammar :: (E, V) -> V)<(e :: E),a>){
    (match (hnd) {
      ((@skip main/@Hnd-attrGrammar((@pat@0: std/core/types/int) : std/core/types/int, (@pat@1: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@2: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@3: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@4: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@5: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,store,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@6: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@7: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@8: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@9: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absValue,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@10: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,std/core/types/bool,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@11: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@12: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/core/types/list :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@13: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,store,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@14: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@pat@15: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,absOp,(),(attrGrammar :: (E, V) -> V),(e :: E),a>, (@fun-setTraversalSummary: (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),(attrGrammar :: (E, V) -> V),(e :: E),a>) : (attrGrammar :: (E, V) -> V)<(e :: E),a> ) as @pat: ((attrGrammar :: (E, V) -> V)<(e :: E),a>))
         -> @fun-setTraversalSummary;
    });
  };
inline  fun setTraversalSummary // inline size: 5
  = fn<<(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>>>(exp: exp, summary: (std/data/hashset/hash-set :: V -> V)<path>){
    std/core/hnd/@perform2<exp,(std/data/hashset/hash-set :: V -> V)<path>,(),<(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>>,(attrGrammar :: (E, V) -> V)>((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>>,(i : std/core/hnd/ev-index) -> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(attrGrammar :: (E, V) -> V)>,(i : std/core/hnd/ev-index) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(attrGrammar :: (E, V) -> V)>>((std/core/hnd/@evv-at<(attrGrammar :: (E, V) -> V)>))((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>>,(i : std/core/types/int) -> std/core/types/ssize_t,(i : std/core/types/int) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>> std/core/types/ssize_t>(std/core/types/@make-ssize_t)(0)))), main/@select-setTraversalSummary, exp, summary);
  };
inline borrow "^"  fun @select-choose // inline size: 0
  = forall<a,(e :: E),b> fn(hnd: (nondet :: (E, V) -> V)<(e :: E),b>){
    (match (hnd) {
      ((@skip main/@Hnd-nondet((@pat@0: std/core/types/int) : std/core/types/int, (@ctl-choose: forall<c> (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<c,c,c,(nondet :: (E, V) -> V),(e :: E),b>) : forall<c> (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<c,c,c,(nondet :: (E, V) -> V),(e :: E),b>, (@pat@1: (forall<c> (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<c,(nondet :: (E, V) -> V),(e :: E),b>)) : (forall<c> (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<c,(nondet :: (E, V) -> V),(e :: E),b>)) : (nondet :: (E, V) -> V)<(e :: E),b> ) as @pat: ((nondet :: (E, V) -> V)<(e :: E),b>))
         -> @ctl-choose<a>;
    });
  };
inline  fun choose // inline size: 5
  = forall<a> fn<<(std/core/types/handled :: ((E, V) -> V) -> X)<(nondet :: (E, V) -> V)>>>(x: a, y: a){
    std/core/hnd/@perform2<a,a,a,<(std/core/types/handled :: ((E, V) -> V) -> X)<(nondet :: (E, V) -> V)>>,(nondet :: (E, V) -> V)>((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(nondet :: (E, V) -> V)>>,(i : std/core/hnd/ev-index) -> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(nondet :: (E, V) -> V)>,(i : std/core/hnd/ev-index) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(nondet :: (E, V) -> V)>> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(nondet :: (E, V) -> V)>>((std/core/hnd/@evv-at<(nondet :: (E, V) -> V)>))((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(nondet :: (E, V) -> V)>>,(i : std/core/types/int) -> std/core/types/ssize_t,(i : std/core/types/int) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(nondet :: (E, V) -> V)>> std/core/types/ssize_t>(std/core/types/@make-ssize_t)(0)))), (forall<(e :: E),b> main/@select-choose<a,(e :: E),b>), x, y);
  };
inline borrow "^"  fun @select-fail // inline size: 0
  = forall<a,(e :: E),b> fn(hnd: (nondet :: (E, V) -> V)<(e :: E),b>){
    (match (hnd) {
      ((@skip main/@Hnd-nondet((@pat@0: std/core/types/int) : std/core/types/int, (@pat@1: forall<c> (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<c,c,c,(nondet :: (E, V) -> V),(e :: E),b>) : forall<c> (std/core/hnd/clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<c,c,c,(nondet :: (E, V) -> V),(e :: E),b>, (@brk-fail: (forall<c> (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<c,(nondet :: (E, V) -> V),(e :: E),b>)) : (forall<c> (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<c,(nondet :: (E, V) -> V),(e :: E),b>)) : (nondet :: (E, V) -> V)<(e :: E),b> ) as @pat: ((nondet :: (E, V) -> V)<(e :: E),b>))
         -> @brk-fail<a>;
    });
  };
inline  fun fail // inline size: 5
  = forall<a> fn<<(std/core/types/handled :: ((E, V) -> V) -> X)<(nondet :: (E, V) -> V)>>>(){
    std/core/hnd/@perform0<a,<(std/core/types/handled :: ((E, V) -> V) -> X)<(nondet :: (E, V) -> V)>>,(nondet :: (E, V) -> V)>((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(nondet :: (E, V) -> V)>>,(i : std/core/hnd/ev-index) -> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(nondet :: (E, V) -> V)>,(i : std/core/hnd/ev-index) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(nondet :: (E, V) -> V)>> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(nondet :: (E, V) -> V)>>((std/core/hnd/@evv-at<(nondet :: (E, V) -> V)>))((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(nondet :: (E, V) -> V)>>,(i : std/core/types/int) -> std/core/types/ssize_t,(i : std/core/types/int) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(nondet :: (E, V) -> V)>> std/core/types/ssize_t>(std/core/types/@make-ssize_t)(0)))), (forall<(e :: E),b> main/@select-fail<a,(e :: E),b>));
  };
 fun getOrThrow // inline size: 4
  = forall<a,b> fn<<(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>>(map: (std/data/hashmap/hash-map :: (V, V) -> V)<a,b>, key: a, @implicit/(==): (a, a) -> std/core/types/bool, @implicit/hash: (a, std/core/types/int64) -> std/core/types/int){
    (match ((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(hm : (std/data/hashmap/hash-map :: (V, V) -> V)<a,b>, key : a, ?hash : (a, std/core/types/int64) -> std/core/types/int, ?(==) : (a, a) -> std/core/types/bool) -> (std/core/types/maybe :: V -> V)<b>,(hm : (std/data/hashmap/hash-map :: (V, V) -> V)<a,b>, key : a, ?hash : (a, std/core/types/int64) -> std/core/types/int, ?(==) : (a, a) -> std/core/types/bool) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> (std/core/types/maybe :: V -> V)<b>>((std/data/hashmap/get<a,b>))(map, key, @implicit/hash, @implicit/(==)))) {
      ((std/core/types/Just((value: b) : b) : (std/core/types/maybe :: V -> V)<b> ) as @pat: ((std/core/types/maybe :: V -> V)<b>))
         -> value;
      ((@skip std/core/types/Nothing() : (std/core/types/maybe :: V -> V)<b> ) as @pat@0: ((std/core/types/maybe :: V -> V)<b>))
         -> std/core/exn/throw<b>("key not present", (std/core/types/@None<std/core/exn/exception-info>));
    });
  };
 fun hash-map/insert // inline size: 1
  = forall<a,b> fn(map: (std/data/hashmap/hash-map :: (V, V) -> V)<a,b>, key: a, value: b, @implicit/(==): (a, a) -> std/core/types/bool, @implicit/hash: (a, std/core/types/int64) -> std/core/types/int){
    std/data/hashmap/insert<a,b>(map, key, value, @implicit/hash, @implicit/(==), std/data/hashmap/when-resize, std/data/hashmap/resizer);
  };
 fun hash-set/insert // inline size: 1
  = forall<a> fn(set: (std/data/hashset/hash-set :: V -> V)<a>, x: a, @implicit/(==): (a, a) -> std/core/types/bool, @implicit/hash: (a, std/core/types/int64) -> std/core/types/int){
    std/data/hashset/insert<a>(set, x, @implicit/hash, @implicit/(==), std/data/hashset/when-resize, std/data/hashset/resizer);
  };
 fun hashset/singleton // inline size: 2
  = forall<a> fn(x: a, @implicit/(==): (a, a) -> std/core/types/bool, @implicit/hash: (a, std/core/types/int64) -> std/core/types/int){
    val set@10185[1,0,1,0] : (std/data/hashset/hash-set :: V -> V)<a>
          = std/data/hashset/#thread/hash-set<a>((std/core/types/@None<std/core/types/int>));
    std/data/hashset/insert<a>(set@10185, x, @implicit/hash, @implicit/(==), std/data/hashset/when-resize, std/data/hashset/resizer);
  };
 fun extractPaths // inline size: 2
  = fn(absValue: absValue){
    match (absValue) {
      ((main/AVPath((paths: (std/data/hashset/hash-set :: V -> V)<path>) : (std/data/hashset/hash-set :: V -> V)<path>) : absValue ) as @pat: absValue)
         -> paths;
      (@pat@0: absValue)
         -> std/data/hashset/#thread/hash-set<path>((std/core/types/@None<std/core/types/int>));
    };
  };
 fun extends // inline size: 3
  = fn(absValue: absValue, paths: (std/core/types/list :: V -> V)<path>){
    match (absValue) {
      ((main/AVPath((valuePaths: (std/data/hashset/hash-set :: V -> V)<path>) : (std/data/hashset/hash-set :: V -> V)<path>) : absValue ) as @pat: absValue)
         -> std/core/list/all<path,(std/core/types/total :: E)>(paths, (fn(path: path){
            (std/data/hashset/contains<path>(valuePaths, path, main/#path/hash, main/#path/(==)));
          }));
      (@pat@0: absValue)
         -> std/core/types/False;
    };
  };
 fun getOrDefault // inline size: 2
  = forall<a,b> fn(map: (std/data/hashmap/hash-map :: (V, V) -> V)<a,b>, key: a, default: b, @implicit/(==): (a, a) -> std/core/types/bool, @implicit/hash: (a, std/core/types/int64) -> std/core/types/int){
    (match ((std/data/hashmap/get<a,b>(map, key, @implicit/hash, @implicit/(==)))) {
      ((std/core/types/Just((value: b) : b) : (std/core/types/maybe :: V -> V)<b> ) as @pat: ((std/core/types/maybe :: V -> V)<b>))
         -> value;
      ((@skip std/core/types/Nothing() : (std/core/types/maybe :: V -> V)<b> ) as @pat@0: ((std/core/types/maybe :: V -> V)<b>))
         -> default;
    });
  };
 fun firstOrThrow // inline size: 2
  = forall<a> fn<<(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>>(l: (std/core/types/list :: V -> V)<a>){
    (match (l) {
      ((std/core/types/Cons((h: a) : a, (@pat@0: (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a> ) as @pat: ((std/core/types/list :: V -> V)<a>))
         -> h;
      ((@skip std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@1: ((std/core/types/list :: V -> V)<a>))
         -> std/core/exn/throw<a>("empty list", (std/core/types/@None<std/core/exn/exception-info>));
    });
  };
 fun updateSynthesizedAttrs // inline size: 4
  = fn<<(std/core/types/handled :: ((E, V) -> V) -> X)<(attrGrammar :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>>(exp: exp){
    val _[699,3,699,27] : ()
      = main/updateAbstractValue(exp);
    val _@0[701,3,701,19] : ()
      = main/updatePaths(exp);
    val _@1[703,3,703,25] : ()
      = main/updateOutputStore(exp);
    main/updateTraversalSummary(exp);
  };
inline borrow "^"  fun @select-modified // inline size: 0
  = forall<(e :: E),a> fn(hnd: (fixpoint :: (E, V) -> V)<(e :: E),a>){
    (match (hnd) {
      ((@skip main/@Hnd-fixpoint((@pat@0: std/core/types/int) : std/core/types/int, (@fun-modified: (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<(),(fixpoint :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<(),(fixpoint :: (E, V) -> V),(e :: E),a>) : (fixpoint :: (E, V) -> V)<(e :: E),a> ) as @pat: ((fixpoint :: (E, V) -> V)<(e :: E),a>))
         -> @fun-modified;
    });
  };
inline  fun modified // inline size: 5
  = fn<<(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>>>(){
    std/core/hnd/@perform0<(),<(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>>,(fixpoint :: (E, V) -> V)>((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>>,(i : std/core/hnd/ev-index) -> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(fixpoint :: (E, V) -> V)>,(i : std/core/hnd/ev-index) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(fixpoint :: (E, V) -> V)>>((std/core/hnd/@evv-at<(fixpoint :: (E, V) -> V)>))((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>>,(i : std/core/types/int) -> std/core/types/ssize_t,(i : std/core/types/int) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(fixpoint :: (E, V) -> V)>> std/core/types/ssize_t>(std/core/types/@make-ssize_t)(0)))), main/@select-modified);
  };
 fun mapShow // inline size: 1
  = forall<a,b> fn(map: (std/data/hashmap/hash-map :: (V, V) -> V)<a,b>, @implicit/keyShow: (a) -> std/core/types/string, @implicit/valueShow: (b) -> std/core/types/string){
    main/#hashmap/show<a,b>(map, @implicit/keyShow, @implicit/valueShow);
  };