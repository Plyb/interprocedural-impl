module interface std/core-extras
 
//------------------------------
//#kki: import declarations
 
import std/core/types = std/core/types pub = "";
import std/core/hnd = std/core/hnd pub = "";
import std/core/exn = std/core/exn pub = "";
import std/core/bool = std/core/bool pub = "";
import std/core/order = std/core/order pub = "";
import std/core/char = std/core/char pub = "";
import std/core/int = std/core/int pub = "";
import std/core/vector = std/core/vector pub = "";
import std/core/string = std/core/string pub = "";
import std/core/sslice = std/core/sslice pub = "";
import std/core/list = std/core/list pub = "";
import std/core/maybe = std/core/maybe pub = "";
import std/core/either = std/core/either pub = "";
import std/core/tuple = std/core/tuple pub = "";
import std/core/show = std/core/show pub = "";
import std/core/debug = std/core/debug pub = "";
import std/core/delayed = std/core/delayed pub = "";
import std/core/console = std/core/console pub = "";
import std/core = std/core = "";
import std/core/undiv = std/core/undiv = "";
 
//------------------------------
//#kki: external imports
 
 
//------------------------------
//#kki: fixity declarations
 
 
//------------------------------
//#kki: local imported aliases
 
// A first-class constructor context where the hole is of the same type as the root of the structure.
local alias std/core/types/ctx[483,1,483,28]<a> :: V -> V = (std/core/types/cctx :: (V, V) -> V)<a,a> = 1;
 
//------------------------------
//#kki: type declarations
 

// Operations:
// ```koka
// final ctl found
// ```
pub recursive effect type find[117,1,117,15] <a,(e :: E),b> :: (V, E, V) -> V {
  pub con @Hnd-find[117,1,117,15](@cfc: std/core/types/int, @brk-found: forall<c> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<a,c,(find :: (V, E, V) -> V)<a>,(e :: E),b>){0,2,8} : forall<a,(e :: E),b> (std/core/types/int, forall<c> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<a,c,(find :: (V, E, V) -> V)<a>,(e :: E),b>) -> (find :: (V, E, V) -> V)<a,(e :: E),b>;
};
 
//------------------------------
//#kki: declarations
 
// Automatically generated. Retrieves the `@cfc` constructor field of the `:find` type.
 fun find/@cfc[117,1,117,15] : forall<a,(e :: E),b> (^ find : (find :: (V, E, V) -> V)<a,(e :: E),b>) -> std/core/types/int;
// Automatically generated. Retrieves the `@brk-found` constructor field of the `:find` type.
 fun find/@brk-found[118,13,118,26] : forall<a,(e :: E),b,c> (^ find : (find :: (V, E, V) -> V)<a,(e :: E),b>) -> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<a,c,(find :: (V, E, V) -> V)<a>,(e :: E),b>;
// monadic lift
 fun eql/(@mlift-x@10078==)[1,0,1,0] : forall<a,(e :: E)> (l1' : (std/core/types/list :: V -> V)<a>, l2' : (std/core/types/list :: V -> V)<a>, ?(==) : (a, a) -> (e :: E) std/core/types/bool, @y-x10035 : std/core/types/bool) -> (e :: E) std/core/types/bool;
// List Utilities
pub  fun eql/(==)[66,9,66,16] : forall<a,(e :: E)> (l1 : (std/core/types/list :: V -> V)<a>, l2 : (std/core/types/list :: V -> V)<a>, ?(==) : (a, a) -> (e :: E) std/core/types/bool) -> (e :: E) std/core/types/bool;
pub  fun maybe/(==)[130,9,130,18] : forall<a,(e :: E)> (m1 : (std/core/types/maybe :: V -> V)<a>, m2 : (std/core/types/maybe :: V -> V)<a>, ?(==) : (a, a) -> (e :: E) std/core/types/bool) -> (e :: E) std/core/types/bool;
// String ordering
pub  fun str/order2[16,16,16,25] : (^ x : std/core/types/string, ^ y : std/core/types/string) -> (std/core/types/order2 :: V -> V)<std/core/types/string>;
// monadic lift
 fun eff/@mlift-order2@10079[1,0,1,0] : forall<a,(e :: E)> (@y-x10041 : (std/core/types/order2 :: V -> V)<a>) -> (e :: E) (std/core/types/order2 :: V -> V)<(std/core/types/maybe :: V -> V)<a>>;
// Order two `:maybe` values in ascending order
pub fip fun eff/order2[22,13,22,22] : forall<a,(e :: E)> (mb1 : (std/core/types/maybe :: V -> V)<a>, mb2 : (std/core/types/maybe :: V -> V)<a>, ^ ?order2 : (a, a) -> (e :: E) (std/core/types/order2 :: V -> V)<a>) -> (e :: E) (std/core/types/order2 :: V -> V)<(std/core/types/maybe :: V -> V)<a>>;
// monadic lift
 fun list/@mlift-order2@10080[1,0,1,0] : forall<a,(e :: E)> (h1@1' : a, @y-x10045 : (std/core/types/order2 :: V -> V)<(std/core/types/list :: V -> V)<a>>) -> (e :: E) (std/core/types/order2 :: V -> V)<(std/core/types/list :: V -> V)<a>>;
// monadic lift
 fun list/@mlift-order2@10081[1,0,1,0] : forall<a,(e :: E)> (t1 : (std/core/types/list :: V -> V)<a>, t2 : (std/core/types/list :: V -> V)<a>, ?order2 : (a, a) -> (e :: E) (std/core/types/order2 :: V -> V)<a>, @y-x10044 : (std/core/types/order2 :: V -> V)<a>) -> (e :: E) (std/core/types/order2 :: V -> V)<(std/core/types/list :: V -> V)<a>>;
pub tail fun list/order2[49,14,49,24] : forall<a,(e :: E)> (l1 : (std/core/types/list :: V -> V)<a>, l2 : (std/core/types/list :: V -> V)<a>, ?order2 : (a, a) -> (e :: E) (std/core/types/order2 :: V -> V)<a>) -> (e :: E) (std/core/types/order2 :: V -> V)<(std/core/types/list :: V -> V)<a>>;
// monadic lift
 fun tuple2/@mlift-order2@10082[1,0,1,0] : forall<a,b,(e :: E)> (a1@1' : a, @y-x10049 : (std/core/types/order2 :: V -> V)<b>) -> (e :: E) (std/core/types/order2 :: V -> V)<(a, b)>;
// monadic lift
 fun tuple2/@mlift-order2@10083[1,0,1,0] : forall<a,b,(e :: E)> (b1 : b, b2 : b, ?b/order2 : (b, b) -> (e :: E) (std/core/types/order2 :: V -> V)<b>, @y-x10048 : (std/core/types/order2 :: V -> V)<a>) -> (e :: E) (std/core/types/order2 :: V -> V)<(a, b)>;
// Order two integers in ascending order.
pub  fun tuple2/order2[38,9,38,21] : forall<a,b,(e :: E)> (t1 : (a, b), t2 : (a, b), ^ ?a/order2 : (a, a) -> (e :: E) (std/core/types/order2 :: V -> V)<a>, ^ ?b/order2 : (b, b) -> (e :: E) (std/core/types/order2 :: V -> V)<b>) -> (e :: E) (std/core/types/order2 :: V -> V)<(a, b)>;
pub  fun list/and[72,9,72,16] : (l : (std/core/types/list :: V -> V)<std/core/types/bool>) -> std/core/types/bool;
// String and char utilities
pub  fun string/is-prefix-of[98,9,98,27] : (s1 : std/core/types/string, s2 : std/core/types/string) -> std/core/types/bool;
// monadic lift
 fun list/@mlift-is-prefix-of@10084[1,0,1,0] : forall<a,(e :: E)> (t1 : (std/core/types/list :: V -> V)<a>, t2 : (std/core/types/list :: V -> V)<a>, ?(==) : (a, a) -> (e :: E) std/core/types/bool, @y-x10053 : std/core/types/bool) -> (e :: E) std/core/types/bool;
pub  fun list/is-prefix-of[78,9,78,25] : forall<a,(e :: E)> (l1 : (std/core/types/list :: V -> V)<a>, l2 : (std/core/types/list :: V -> V)<a>, ?(==) : (a, a) -> (e :: E) std/core/types/bool) -> (e :: E) std/core/types/bool;
// monadic lift
 fun list/@mlift-lift-maximum-by@2803@10085[1,0,1,0] : forall<a,(e :: E)> (acc : (std/core/types/maybe :: V -> V)<a>, cmp : (a, a) -> (e :: E) std/core/types/order, h : a, t : (std/core/types/list :: V -> V)<a>, @y-x10058 : std/core/types/order) -> (e :: E) (std/core/types/maybe :: V -> V)<a>;
// lifted local: list/maximum-by, loop
 fun list/@lift-maximum-by@2803[1,0,1,0] : forall<a,(e :: E)> (l : (std/core/types/list :: V -> V)<a>, acc : (std/core/types/maybe :: V -> V)<a>, cmp : (a, a) -> (e :: E) std/core/types/order) -> (e :: E) (std/core/types/maybe :: V -> V)<a>;
pub  fun list/maximum-by[84,9,84,23] : forall<a,(e :: E)> (l0 : (std/core/types/list :: V -> V)<a>, cmp0 : (a, a) -> (e :: E) std/core/types/order) -> (e :: E) (std/core/types/maybe :: V -> V)<a>;
pub  fun to-upper[101,9,101,16] : (c : std/core/types/char) -> std/core/types/char;
pub  fun to-lower[104,9,104,16] : (c : std/core/types/char) -> std/core/types/char;
// lifted local: split-by, loop
 fun @lift-split-by@2804[1,0,1,0] : (pred : (std/core/types/char) -> std/core/types/bool, sl : std/core/sslice/sslice, numchars : std/core/types/int, acc : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<std/core/types/string>>) -> (std/core/types/list :: V -> V)<std/core/types/string>;
pub  fun split-by[107,9,107,16] : (s : std/core/types/string, pred : (std/core/types/char) -> std/core/types/bool) -> (std/core/types/list :: V -> V)<std/core/types/string>;
// runtime tag for the effect `:find`
pub val @tag-find[117,1,117,15] : forall<a> (std/core/hnd/htag :: ((E, V) -> V) -> V)<(find :: (V, E, V) -> V)<a>>;
// handler for the effect `:find`
pub  fun @handle-find[117,12,117,15] : forall<a,b,(e :: E),c> (hnd : (find :: (V, E, V) -> V)<a,(e :: E),c>, ret : (res : b) -> (e :: E) c, action : () -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(find :: (V, E, V) -> V)<a>>|(e :: E)> b) -> (e :: E) c;
// select `found` operation out of effect `:find`
pub  fun @select-found[118,13,118,26] : forall<a,b,(e :: E),c> (^ hnd : (find :: (V, E, V) -> V)<a,(e :: E),c>) -> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<a,b,(find :: (V, E, V) -> V)<a>,(e :: E),c>;
// Call the `final ctl found` operation of the effect `:find`
pub  fun found[118,13,118,17] : forall<a,b> (a : a) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(find :: (V, E, V) -> V)<a>>> b;
pub  fun find[120,9,120,12] : forall<a,(e :: E)> (f : () -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(find :: (V, E, V) -> V)<a>>|(e :: E)> a) -> (e :: E) a;
// Maybe utilities
pub  fun flatten[125,16,125,22] : forall<a> (item : (std/core/types/maybe :: V -> V)<(std/core/types/maybe :: V -> V)<a>>) -> (std/core/types/maybe :: V -> V)<a>;
pub  fun expect[136,9,136,14] : forall<a> (m : (std/core/types/maybe :: V -> V)<a>, msg : (std/core/types/@optional :: V -> V)<std/core/types/string>, ?kk-file-line : std/core/types/string) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> a;
pub  fun expect-unjust[141,9,141,21] : forall<a> (m : (std/core/types/maybe :: V -> V)<a>, msg : std/core/types/string) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> a;
// lifted local: vector-init-list, assigns
 fun @lift-vector-init-list@2805[1,0,1,0] : forall<a> (v : (std/core/types/vector :: V -> V)<a>, xs' : (std/core/types/list :: V -> V)<(std/core/types/int, a)>) -> ();
// Vector utilities
pub  fun vector-init-list[147,9,147,24] : forall<a> (^ n : std/core/types/int, xs : (std/core/types/list :: V -> V)<(std/core/types/int, a)>) -> (std/core/types/vector :: V -> V)<a>;
pub  fun is-space[158,9,158,16] : (c : std/core/types/char) -> std/core/types/bool;
// This function takes a vector `v` and a position to stop at `stop`
// If you supply a `stop` larger than the length, then the length of the vector is used instead.
// This function shouldn't be called directly unless you know exactly what you are doing.
pub  fun unsafe-vector-clear[173,12,173,30] : forall<a> (v : (std/core/types/vector :: V -> V)<a>, stop : std/core/types/ssize_t) -> ();
// This function takes a vector `v` and a `position` to clear at.
// This is all done without a bounds check, so make sure to get it right.
// This function shouldn't be called directly unless you know exactly what you are doing.
pub  fun unsafe-vector-clear-at[179,12,179,33] : forall<a> (v : (std/core/types/vector :: V -> V)<a>, position : std/core/types/ssize_t) -> ();
// Set the element at position `index` in vector `v` without bounds check!
pub  fun unsafe-set[199,9,199,18] : forall<a> (v : (std/core/types/vector :: V -> V)<a>, ^ index : std/core/types/int, value : a) -> (std/core/types/vector :: V -> V)<a>;
pub  fun a/unsafe-swap[210,9,210,21] : forall<a> (v : (std/core/types/vector :: V -> V)<a>, ^ idx1 : std/core/types/int, ^ idx2 : std/core/types/int) -> (std/core/types/vector :: V -> V)<a>;
pub fip fun ssize_t/incr[283,16,283,27] : (i : std/core/types/ssize_t) -> std/core/types/ssize_t;
// monadic lift
 fun @mlift-lift-forz@2806@10086[1,0,1,0] : forall<(e :: E)> (action : (std/core/types/ssize_t) -> (e :: E) (), i : std/core/types/ssize_t, n : std/core/types/ssize_t, wild_ : ()) -> (e :: E) ();
// lifted local: forz, rep
 fun @lift-forz@2806[1,0,1,0] : forall<(e :: E)> (action : (std/core/types/ssize_t) -> (e :: E) (), n : std/core/types/ssize_t, i : std/core/types/ssize_t) -> (e :: E) ();
// Executes `action` `n` times for each integer between [`0`,`n`)  (excluding `n` ).
// If `n <= 0`  the function returns without any call to `action` .
pub  fun forz[276,9,276,12] : forall<(e :: E)> (n : std/core/types/ssize_t, action : (std/core/types/ssize_t) -> (e :: E) ()) -> (e :: E) ();
pub  fun foreach-indexedz[270,9,270,24] : forall<a,(e :: E)> (v : (std/core/types/vector :: V -> V)<a>, f : (std/core/types/ssize_t, a) -> (e :: E) ()) -> (e :: E) ();
// Apply a total function `f` to each element in a vector `v`
// Since the vector consists of boxed values we can ignore type incompatibilities
// However, we also cannot allow exception effects in f, because then the vector would be left in an inconsistent state which would be observable and unreversable
// We could allow div, but then this is always div even when f is not div
pub  fun unique/map[186,9,186,18] : forall<a,b> (v : (std/core/types/vector :: V -> V)<a>, f : (a) -> b) -> (std/core/types/vector :: V -> V)<b>;
// This variant mutates in-place
pub  fun unit/unsafe-swap[224,9,224,24] : forall<a> (v : (std/core/types/vector :: V -> V)<a>, ^ idx1 : std/core/types/int, ^ idx2 : std/core/types/int) -> ();
 
//------------------------------
//#kki: external declarations
 
// Copies a vector
pub  extern copy[162,19,162,22] : forall<a> (v : (std/core/types/vector :: V -> V)<a>) -> (std/core/types/vector :: V -> V)<a> {
  c inline "kk_vector_copy(#1,kk_context())";
  js inline "[...(#1)]";
};
pub  extern realloc[166,19,166,25] : forall<a> (v : (std/core/types/vector :: V -> V)<a>, new_capacity : std/core/types/ssize_t) -> (std/core/types/vector :: V -> V)<a> {
  c inline "kk_vector_realloc(#1, #2, kk_box_null(), kk_context())";
  js inline "[...(#1)]";
};
pub  extern is-ref-unique[229,19,229,31] : forall<a> (^ x : a) -> std/core/types/bool {
  c inline "!kk_box_is_ptr(#1, kk_context()) || kk_block_is_unique(kk_box_to_ptr(#1, kk_context()))";
};
pub  extern is-vec-unique[232,19,232,31] : forall<a> (^ v : (std/core/types/vector :: V -> V)<a>) -> std/core/types/bool {
  c inline "kk_datatype_is_unique(#1, kk_context())";
};
pub  extern unsafe-box-drop[235,19,235,33] : forall<a> (^ x : a) -> () {
  c inline "kk_box_drop(#1, kk_context())";
};
pub  extern drop-at[238,19,238,25] : forall<a> (^ v : (std/core/types/vector :: V -> V)<a>, index : std/core/types/ssize_t) -> () {
  c inline "kk_vector_dup(#1, kk_context()); kk_box_drop(kk_vector_at_borrow(#1, #2, kk_context()), kk_context()); kk_vector_unsafe_assign(#1, #2, kk_box_null(), kk_context())";
};
// Valid only for boxed values
pub  extern unsafe-ignore-type[242,19,242,36] : forall<a,b> (x : a) -> b = inline "#1";
// Make the following preexisting functions public, or make them public in an unsafe module
pub  extern unsafe-vector[246,19,246,31] : forall<a> (n : std/core/types/ssize_t) -> (std/core/types/vector :: V -> V)<a> {
  c inline "kk_vector_alloc(#1,kk_box_null(),kk_context())";
  cs inline "(new ##1[#1])";
  js inline "Array(#1)";
};
// This function should never be called directly unless you know exactly what you are doing
pub  extern unsafe-assign[252,19,252,31] : forall<a> (v : (std/core/types/vector :: V -> V)<a>, i : std/core/types/ssize_t, x : a) -> () {
  c inline "kk_vector_unsafe_assign(#1,#2,#3,kk_context())";
  cs inline "(#1)[#2] = #3";
  js inline "(#1)[#2] = #3";
};
// Return the element at position `index` in vector `v` without bounds check!
// This function should never be called directly unless you know exactly what you are doing
pub  extern unsafe-idx[259,19,259,28] : forall<a> (^ v : (std/core/types/vector :: V -> V)<a>, index : std/core/types/ssize_t) -> a {
  c inline "kk_vector_at_borrow(#1,#2,kk_context())";
  cs inline "(#1)[#2]";
  js inline "(#1)[#2]";
};
// Length of a vector.
pub  extern lengthz[265,19,265,25] : forall<a> (^ v : (std/core/types/vector :: V -> V)<a>) -> std/core/types/ssize_t {
  c inline "kk_vector_len_borrow(#1,kk_context())";
  cs inline "((#1).Length)";
  js inline "((#1).length)";
};
pub fip extern ssize_t/(<)[286,23,286,33] : (std/core/types/ssize_t, std/core/types/ssize_t) -> std/core/types/bool = inline "(#1 < #2)";
 
//------------------------------
//#kki: inline definitions
 
//.inline-section
recursive specialize "*__"  fun @lift-forz@2806 // inline size: 9
  = forall<(e :: E)> fn<(e :: E)>(action: (std/core/types/ssize_t) -> (e :: E) (), n: std/core/types/ssize_t, i: std/core/types/ssize_t){
    (match ((std/core/types/@open<(std/core/types/total :: E),(e :: E),(std/core/types/ssize_t, std/core/types/ssize_t) -> std/core/types/bool,(std/core/types/ssize_t, std/core/types/ssize_t) -> (e :: E) std/core/types/bool>(std/core-extras/#ssize_t/(<))(i, n))) {
      ((std/core/types/True() : std/core/types/bool ) as @pat: std/core/types/bool)
         -> val _[279,7,279,15] : ()
              = action(i);
            val i@0@10023[1,0,1,0] : std/core/types/ssize_t
              = std/core/types/@open<(std/core/types/total :: E),(e :: E),(x : std/core/types/ssize_t) -> std/core/types/ssize_t,(x : std/core/types/ssize_t) -> (e :: E) std/core/types/ssize_t>((std/core/undiv/pretend-decreasing<std/core/types/ssize_t>))((std/core/types/@open<(std/core/types/total :: E),(e :: E),(i : std/core/types/ssize_t) -> std/core/types/ssize_t,(i : std/core/types/ssize_t) -> (e :: E) std/core/types/ssize_t>(std/core-extras/#ssize_t/incr)(i)));
        std/core-extras/@lift-forz@2806<(e :: E)>(action, n, i@0@10023);
      ((@skip std/core/types/False() : std/core/types/bool ) as @pat@0: std/core/types/bool)
         -> std/core/types/Unit;
    });
  };
recursive specialize "*___"  fun @lift-split-by@2804 // inline size: 20
  = fn(pred: (std/core/types/char) -> std/core/types/bool, sl: std/core/sslice/sslice, numchars: std/core/types/int, acc: (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<std/core/types/string>>){
    match ((std/core/sslice/next(sl))) {
      ((std/core/types/Nothing() : (std/core/types/maybe :: V -> V)<(std/core/types/char, std/core/sslice/sslice)> ) as @pat: ((std/core/types/maybe :: V -> V)<(std/core/types/char, std/core/sslice/sslice)>))
         -> std/core/types/#cctx/(++.)<(std/core/types/list :: V -> V)<std/core/types/string>,(std/core/types/list :: V -> V)<std/core/types/string>>(acc, (std/core/types/Nil<std/core/types/string>));
      ((@skip std/core/types/Just(((@skip std/core/types/Tuple2((c: std/core/types/char) : std/core/types/char, ((@skip std/core/sslice/Sslice((@pat@2: std/core/types/string) : std/core/types/string, (@pat@3: std/core/types/int) : std/core/types/int, (@pat@4: std/core/types/int) : std/core/types/int) : std/core/sslice/sslice ) as sl': std/core/sslice/sslice) : std/core/sslice/sslice) : (std/core/types/char, std/core/sslice/sslice) ) as @pat@1: (std/core/types/char, std/core/sslice/sslice)) : (std/core/types/char, std/core/sslice/sslice)) : (std/core/types/maybe :: V -> V)<(std/core/types/char, std/core/sslice/sslice)> ) as @pat@0: ((std/core/types/maybe :: V -> V)<(std/core/types/char, std/core/sslice/sslice)>))
         -> (match ((pred(c))) {
          ((std/core/types/True() : std/core/types/bool ) as @pat@5: std/core/types/bool)
             -> val slice@0@10009[1,0,1,0] : std/core/sslice/sslice
                  = std/core/sslice/advance(sl', (std/core/int/int-sub(0, numchars)));
                val @cctx-x1775[1,0,1,0] : (std/core/types/list :: V -> V)<std/core/types/string>
                  = std/core/types/Cons<std/core/types/string>((std/core/sslice/string((std/core/sslice/extend((std/core/sslice/Sslice((match (slice@0@10009) {
                          ((@skip std/core/sslice/Sslice((@x: std/core/types/string) : std/core/types/string, (@pat@0@0: std/core/types/int) : std/core/types/int, (@pat@1@0: std/core/types/int) : std/core/types/int) : std/core/sslice/sslice ) as @pat@6: std/core/sslice/sslice)
                             -> @x;
                        }), (match (slice@0@10009) {
                          ((@skip std/core/sslice/Sslice((@pat@0@0@0: std/core/types/string) : std/core/types/string, (@x@0: std/core/types/int) : std/core/types/int, (@pat@1@0@0: std/core/types/int) : std/core/types/int) : std/core/sslice/sslice ) as @pat@2@0: std/core/sslice/sslice)
                             -> @x@0;
                        }), 0)), numchars)))), (std/core/types/@cctx-hole-create<(std/core/types/list :: V -> V)<std/core/types/string>>()));
                val @cctx-x1776[1,0,1,0] : (std/core/types/@field-addr :: V -> V)<(std/core/types/list :: V -> V)<std/core/types/string>>
                  = std/core/types/@field-addr-of<(std/core/types/list :: V -> V)<std/core/types/string>>(@cctx-x1775, "(\x22std/core/types\x22,\x22\x22,\x22Cons\x22)", "(\x22\x22,\x22\x22,\x22tail\x22)");
                val sl@0@10012[1,0,1,0] : std/core/sslice/sslice
                  = std/core/undiv/pretend-decreasing<std/core/sslice/sslice>(sl');
                val acc@0@10014[1,0,1,0] : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<std/core/types/string>>
                  = std/core/types/#cctx/(++)<(std/core/types/list :: V -> V)<std/core/types/string>,(std/core/types/list :: V -> V)<std/core/types/string>,(std/core/types/list :: V -> V)<std/core/types/string>>(acc, (std/core/types/@cctx-create<(std/core/types/list :: V -> V)<std/core/types/string>,(std/core/types/list :: V -> V)<std/core/types/string>>(@cctx-x1775, @cctx-x1776)));
            std/core-extras/@lift-split-by@2804(pred, sl@0@10012, 0, acc@0@10014);
          ((@skip std/core/types/False() : std/core/types/bool ) as @pat@6@0: std/core/types/bool)
             -> val sl@1@10015[1,0,1,0] : std/core/sslice/sslice
                  = std/core/undiv/pretend-decreasing<std/core/sslice/sslice>(sl');
                val numchars@1@10016[1,0,1,0] : std/core/types/int
                  = std/core/int/int-add(numchars, 1);
            std/core-extras/@lift-split-by@2804(pred, sl@1@10015, numchars@1@10016, acc);
        });
    };
  };
specialize "**"  fun foreach-indexedz // inline size: 1
  = forall<a,(e :: E)> fn<(e :: E)>(v: (std/core/types/vector :: V -> V)<a>, f: (std/core/types/ssize_t, a) -> (e :: E) ()){
    val n@10024[1,0,1,0] : std/core/types/ssize_t
      = std/core/types/@open<(std/core/types/total :: E),(e :: E),(v : (std/core/types/vector :: V -> V)<a>) -> std/core/types/ssize_t,(v : (std/core/types/vector :: V -> V)<a>) -> (e :: E) std/core/types/ssize_t>((std/core-extras/lengthz<a>))(v);
    val i[1,0,1,0] : std/core/types/ssize_t
      = std/core/types/@open<(std/core/types/total :: E),(e :: E),(i : std/core/types/int) -> std/core/types/ssize_t,(i : std/core/types/int) -> (e :: E) std/core/types/ssize_t>(std/core/int/ssize_t)(0);
    std/core-extras/@lift-forz@2806<(e :: E)>((fn<(e :: E)>(i@0: std/core/types/ssize_t){
        (f(i@0, (std/core/types/@open<(std/core/types/total :: E),(e :: E),(v : (std/core/types/vector :: V -> V)<a>, index : std/core/types/ssize_t) -> a,(v : (std/core/types/vector :: V -> V)<a>, index : std/core/types/ssize_t) -> (e :: E) a>((std/core-extras/unsafe-idx<a>))(v, i@0))));
      }), n@10024, i);
  };
specialize "_*"  fun forz // inline size: 1
  = forall<(e :: E)> fn<(e :: E)>(n: std/core/types/ssize_t, action: (std/core/types/ssize_t) -> (e :: E) ()){
    val i[1,0,1,0] : std/core/types/ssize_t
          = std/core/types/@open<(std/core/types/total :: E),(e :: E),(i : std/core/types/int) -> std/core/types/ssize_t,(i : std/core/types/int) -> (e :: E) std/core/types/ssize_t>(std/core/int/ssize_t)(0);
    std/core-extras/@lift-forz@2806<(e :: E)>(action, n, i);
  };
specialize "_*"  fun split-by // inline size: 1
  = fn(s: std/core/types/string, pred: (std/core/types/char) -> std/core/types/bool){
    val sl[1,0,1,0] : std/core/sslice/sslice
      = std/core/sslice/Sslice(s, 0, (std/core/sslice/length(s)));
    val acc[1,0,1,0] : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<std/core/types/string>>
      = std/core/types/#cctx/empty<(std/core/types/list :: V -> V)<std/core/types/string>>();
    std/core-extras/@lift-split-by@2804(pred, sl, 0, acc);
  };
recursive specialize "__*"  fun eql/(==) // inline size: 7
  = forall<a,(e :: E)> fn<(e :: E)>(l1: (std/core/types/list :: V -> V)<a>, l2: (std/core/types/list :: V -> V)<a>, @implicit/(==): (a, a) -> (e :: E) std/core/types/bool){
    (match (l1, l2) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@1: (std/core/types/list :: V -> V)<a>), ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@0: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/True;
      ((std/core/types/Cons((s2: a) : a, (l2': (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a> ) as @pat@4: (std/core/types/list :: V -> V)<a>), ((std/core/types/Cons((s1: a) : a, (l1': (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a> ) as @pat@3: ((std/core/types/list :: V -> V)<a>))
         -> (match ((@implicit/(==)(s1, s2))) {
          ((std/core/types/True() : std/core/types/bool ) as @pat@5: std/core/types/bool)
             -> std/core-extras/#eql/(==)<a,(e :: E)>((std/core/types/@open<(std/core/types/total :: E),(e :: E),(x : (std/core/types/list :: V -> V)<a>) -> (std/core/types/list :: V -> V)<a>,(x : (std/core/types/list :: V -> V)<a>) -> (e :: E) (std/core/types/list :: V -> V)<a>>((std/core/undiv/pretend-decreasing<(std/core/types/list :: V -> V)<a>>))(l1')), l2', @implicit/(==));
          (@pat@6: std/core/types/bool)
             -> std/core/types/False;
        });
      (@pat@2: ((std/core/types/list :: V -> V)<a>)), (@pat: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/False;
    });
  };
recursive specialize "__*"  fun list/@lift-maximum-by@2803 // inline size: 9
  = forall<a,(e :: E)> fn<(e :: E)>(l: (std/core/types/list :: V -> V)<a>, acc: (std/core/types/maybe :: V -> V)<a>, cmp: (a, a) -> (e :: E) std/core/types/order){
    (match (l) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat: ((std/core/types/list :: V -> V)<a>))
         -> acc;
      ((@skip std/core/types/Cons((h: a) : a, (t: (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a> ) as @pat@0: ((std/core/types/list :: V -> V)<a>))
         -> (match (acc) {
          ((std/core/types/Nothing() : (std/core/types/maybe :: V -> V)<a> ) as @pat@1: ((std/core/types/maybe :: V -> V)<a>))
             -> std/core-extras/#list/@lift-maximum-by@2803<a,(e :: E)>(t, (std/core/types/Just<a>(h)), cmp);
          ((@skip std/core/types/Just((max: a) : a) : (std/core/types/maybe :: V -> V)<a> ) as @pat@2: ((std/core/types/maybe :: V -> V)<a>))
             -> (match ((cmp(h, max))) {
              ((std/core/types/Gt() : std/core/types/order ) as @pat@3: std/core/types/order)
                 -> std/core-extras/#list/@lift-maximum-by@2803<a,(e :: E)>(t, (std/core/types/Just<a>(h)), cmp);
              (@pat@4: std/core/types/order)
                 -> std/core-extras/#list/@lift-maximum-by@2803<a,(e :: E)>(t, acc, cmp);
            });
        });
    });
  };
recursive specialize "__*"  fun list/is-prefix-of // inline size: 7
  = forall<a,(e :: E)> fn<(e :: E)>(l1: (std/core/types/list :: V -> V)<a>, l2: (std/core/types/list :: V -> V)<a>, @implicit/(==): (a, a) -> (e :: E) std/core/types/bool){
    (match (l1, l2) {
      (@pat@1: (std/core/types/list :: V -> V)<a>), ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@0: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/True;
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@4: ((std/core/types/list :: V -> V)<a>)), (@pat@3: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/False;
      ((@skip std/core/types/Cons((h2: a) : a, (t2: (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a> ) as @pat@7: (std/core/types/list :: V -> V)<a>), ((@skip std/core/types/Cons((h1: a) : a, (t1: (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a> ) as @pat@6: ((std/core/types/list :: V -> V)<a>))
         -> (match ((@implicit/(==)(h1, h2))) {
          ((std/core/types/True() : std/core/types/bool ) as @pat@8: std/core/types/bool)
             -> std/core-extras/#list/is-prefix-of<a,(e :: E)>((std/core/types/@open<(std/core/types/total :: E),(e :: E),(x : (std/core/types/list :: V -> V)<a>) -> (std/core/types/list :: V -> V)<a>,(x : (std/core/types/list :: V -> V)<a>) -> (e :: E) (std/core/types/list :: V -> V)<a>>((std/core/undiv/pretend-decreasing<(std/core/types/list :: V -> V)<a>>))(t1)), t2, @implicit/(==));
          (@pat@9: std/core/types/bool)
             -> std/core/types/False;
        });
    });
  };
specialize "_*"  fun list/maximum-by // inline size: 1
  = forall<a,(e :: E)> fn<(e :: E)>(l0: (std/core/types/list :: V -> V)<a>, cmp0: (a, a) -> (e :: E) std/core/types/order){
    std/core-extras/#list/@lift-maximum-by@2803<a,(e :: E)>(l0, (std/core/types/Nothing<a>), cmp0);
  };
recursive specialize "__*" tail fun list/order2 // inline size: 28
  = forall<a,(e :: E)> fn<(e :: E)>(l1: (std/core/types/list :: V -> V)<a>, l2: (std/core/types/list :: V -> V)<a>, @implicit/order2: (a, a) -> (e :: E) (std/core/types/order2 :: V -> V)<a>){
    (match (l1, l2) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@1: (std/core/types/list :: V -> V)<a>), ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@0: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/Eq2<(std/core/types/list :: V -> V)<a>>((std/core/types/Nil<a>));
      (@pat@4: (std/core/types/list :: V -> V)<a>), ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@3: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/Lt2<(std/core/types/list :: V -> V)<a>>((std/core/types/Nil<a>), l2);
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@7: ((std/core/types/list :: V -> V)<a>)), (@pat@6: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/Gt2<(std/core/types/list :: V -> V)<a>>((std/core/types/Nil<a>), l1);
      ((@skip std/core/types/Cons((h2: a) : a, (t2: (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a> ) as @pat@10: (std/core/types/list :: V -> V)<a>), ((@skip std/core/types/Cons((h1: a) : a, (t1: (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a> ) as @pat@9: ((std/core/types/list :: V -> V)<a>))
         -> (match ((@implicit/order2(h1, h2))) {
          ((std/core/types/Lt2((h1': a) : a, (h2': a) : a) : (std/core/types/order2 :: V -> V)<a> ) as @pat@11: ((std/core/types/order2 :: V -> V)<a>))
             -> std/core/types/Lt2<(std/core/types/list :: V -> V)<a>>((std/core/types/Cons<a>(h1', t1)), (std/core/types/Cons<a>(h2', t2)));
          ((std/core/types/Gt2((h2@0': a) : a, (h1@0': a) : a) : (std/core/types/order2 :: V -> V)<a> ) as @pat@12: ((std/core/types/order2 :: V -> V)<a>))
             -> std/core/types/Gt2<(std/core/types/list :: V -> V)<a>>((std/core/types/Cons<a>(h2@0', t2)), (std/core/types/Cons<a>(h1@0', t1)));
          ((@skip std/core/types/Eq2((h1@1': a) : a) : (std/core/types/order2 :: V -> V)<a> ) as @pat@13: ((std/core/types/order2 :: V -> V)<a>))
             -> (match ((std/core-extras/#list/order2<a,(e :: E)>((std/core/types/@open<(std/core/types/total :: E),(e :: E),(x : (std/core/types/list :: V -> V)<a>) -> (std/core/types/list :: V -> V)<a>,(x : (std/core/types/list :: V -> V)<a>) -> (e :: E) (std/core/types/list :: V -> V)<a>>((std/core/undiv/pretend-decreasing<(std/core/types/list :: V -> V)<a>>))(t1)), t2, @implicit/order2))) {
              ((std/core/types/Lt2((t1': (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a>, (t2': (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a>) : (std/core/types/order2 :: V -> V)<(std/core/types/list :: V -> V)<a>> ) as @pat@14: ((std/core/types/order2 :: V -> V)<(std/core/types/list :: V -> V)<a>>))
                 -> std/core/types/Lt2<(std/core/types/list :: V -> V)<a>>((std/core/types/Cons<a>(h1@1', t1')), (std/core/types/Cons<a>(h1@1', t2')));
              ((std/core/types/Gt2((t2@0': (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a>, (t1@0': (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a>) : (std/core/types/order2 :: V -> V)<(std/core/types/list :: V -> V)<a>> ) as @pat@15: ((std/core/types/order2 :: V -> V)<(std/core/types/list :: V -> V)<a>>))
                 -> std/core/types/Gt2<(std/core/types/list :: V -> V)<a>>((std/core/types/Cons<a>(h1@1', t2@0')), (std/core/types/Cons<a>(h1@1', t1@0')));
              ((@skip std/core/types/Eq2((t1@1': (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a>) : (std/core/types/order2 :: V -> V)<(std/core/types/list :: V -> V)<a>> ) as @pat@16: ((std/core/types/order2 :: V -> V)<(std/core/types/list :: V -> V)<a>>))
                 -> std/core/types/Eq2<(std/core/types/list :: V -> V)<a>>((std/core/types/Cons<a>(h1@1', t1@1')));
            });
        });
    });
  };
specialize "**"  fun unique/map // inline size: 1
  = forall<a,b> fn(v: (std/core/types/vector :: V -> V)<a>, f: (a) -> b){
    (match ((std/core-extras/is-vec-unique<a>(v))) {
      ((std/core/types/True() : std/core/types/bool ) as @pat: std/core/types/bool)
         -> val n@10024[1,0,1,0] : std/core/types/ssize_t
              = std/core-extras/lengthz<a>(v);
            val i[1,0,1,0] : std/core/types/ssize_t
              = std/core/int/ssize_t(0);
            val _[189,5,189,75] : ()
              = std/core-extras/@lift-forz@2806<(std/core/types/total :: E)>((fn(i@0: std/core/types/ssize_t){
                  val x@10032[1,0,1,0] : a
                        = (std/core-extras/unsafe-idx<a>(v, i@0));
                  (std/core-extras/unsafe-assign<a>(v, i@0, (std/core-extras/unsafe-ignore-type<b,a>((f(x@10032))))));
                }), n@10024, i);
        std/core-extras/unsafe-ignore-type<(std/core/types/vector :: V -> V)<a>,(std/core/types/vector :: V -> V)<b>>(v);
      ((@skip std/core/types/False() : std/core/types/bool ) as @pat@0: std/core/types/bool)
         -> val w[193,9,193,9] : (std/core/types/vector :: V -> V)<b>
              = std/core-extras/unsafe-vector<b>((std/core/int/ssize_t((std/core/int/#ssize_t/int((std/core/vector/lengthz<a>(v)))))));
            val n@10024@0[1,0,1,0] : std/core/types/ssize_t
              = std/core-extras/lengthz<a>(v);
            val i@2[1,0,1,0] : std/core/types/ssize_t
              = std/core/int/ssize_t(0);
            val _@0[194,5,194,22] : ()
              = std/core-extras/@lift-forz@2806<(std/core/types/total :: E)>((fn(i@0@0: std/core/types/ssize_t){
                  val x@0@10034[1,0,1,0] : a
                        = (std/core-extras/unsafe-idx<a>(v, i@0@0));
                  (std/core-extras/unsafe-assign<b>(w, i@0@0, (f(x@0@10034))));
                }), n@10024@0, i@2);
        w;
    });
  };
inline borrow "^"  fun find/@cfc // inline size: 0
  = forall<a,(e :: E),b> fn(find@0: (find :: (V, E, V) -> V)<a,(e :: E),b>){
    (match (find@0) {
      ((@skip std/core-extras/@Hnd-find((@x: std/core/types/int) : std/core/types/int, (@pat@0: (forall<c> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<a,c,(find :: (V, E, V) -> V)<a>,(e :: E),b>)) : (forall<c> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<a,c,(find :: (V, E, V) -> V)<a>,(e :: E),b>)) : (find :: (V, E, V) -> V)<a,(e :: E),b> ) as @pat: ((find :: (V, E, V) -> V)<a,(e :: E),b>))
         -> @x;
    });
  };
inline borrow "^"  fun find/@brk-found // inline size: 0
  = forall<a,(e :: E),b,c> fn(find@0: (find :: (V, E, V) -> V)<a,(e :: E),b>){
    (match (find@0) {
      ((@skip std/core-extras/@Hnd-find((@pat@0: std/core/types/int) : std/core/types/int, (@x: (forall<d> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<a,d,(find :: (V, E, V) -> V)<a>,(e :: E),b>)) : (forall<d> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<a,d,(find :: (V, E, V) -> V)<a>,(e :: E),b>)) : (find :: (V, E, V) -> V)<a,(e :: E),b> ) as @pat: ((find :: (V, E, V) -> V)<a,(e :: E),b>))
         -> @x<c>;
    });
  };
 fun maybe/(==) // inline size: 3
  = forall<a,(e :: E)> fn<(e :: E)>(m1: (std/core/types/maybe :: V -> V)<a>, m2: (std/core/types/maybe :: V -> V)<a>, @implicit/(==): (a, a) -> (e :: E) std/core/types/bool){
    (match (m1, m2) {
      ((std/core/types/Just((m2': a) : a) : (std/core/types/maybe :: V -> V)<a> ) as @pat@1: (std/core/types/maybe :: V -> V)<a>), ((std/core/types/Just((m1': a) : a) : (std/core/types/maybe :: V -> V)<a> ) as @pat@0: ((std/core/types/maybe :: V -> V)<a>))
         -> @implicit/(==)(m1', m2');
      ((std/core/types/Nothing() : (std/core/types/maybe :: V -> V)<a> ) as @pat@4: (std/core/types/maybe :: V -> V)<a>), ((std/core/types/Nothing() : (std/core/types/maybe :: V -> V)<a> ) as @pat@3: ((std/core/types/maybe :: V -> V)<a>))
         -> std/core/types/True;
      (@pat@2: ((std/core/types/maybe :: V -> V)<a>)), (@pat: ((std/core/types/maybe :: V -> V)<a>))
         -> std/core/types/False;
    });
  };
inline borrow "^^"  fun str/order2 // inline size: 8
  = fn(x: std/core/types/string, y: std/core/types/string){
    match ((std/core/order/(==)((std/core/string/cmp(x, y)), std/core/types/Lt))) {
      ((std/core/types/True() : std/core/types/bool ) as @pat: std/core/types/bool)
         -> std/core/types/Lt2<std/core/types/string>(x, y);
      ((@skip std/core/types/False() : std/core/types/bool ) as @pat@0: std/core/types/bool)
         -> (match ((std/core/string/(==)(x, y))) {
          ((std/core/types/True() : std/core/types/bool ) as @pat@1: std/core/types/bool)
             -> std/core/types/Eq2<std/core/types/string>(x);
          ((@skip std/core/types/False() : std/core/types/bool ) as @pat@2: std/core/types/bool)
             -> std/core/types/Gt2<std/core/types/string>(y, x);
        });
    };
  };
 fun string/is-prefix-of // inline size: 2
  = fn(s1: std/core/types/string, s2: std/core/types/string){
    val mb@10002[1,0,1,0] : (std/core/types/maybe :: V -> V)<std/core/sslice/sslice>
          = std/core/sslice/starts-with(s2, s1);
    match (mb@10002) {
      ((std/core/types/Just((@pat@0: std/core/sslice/sslice) : std/core/sslice/sslice) : (std/core/types/maybe :: V -> V)<std/core/sslice/sslice> ) as @pat: ((std/core/types/maybe :: V -> V)<std/core/sslice/sslice>))
         -> std/core/types/True;
      ((@skip std/core/types/Nothing() : (std/core/types/maybe :: V -> V)<std/core/sslice/sslice> ) as @pat@1: ((std/core/types/maybe :: V -> V)<std/core/sslice/sslice>))
         -> std/core/types/False;
    };
  };
 fun list/maximum-by // inline size: 1
  = forall<a,(e :: E)> fn<(e :: E)>(l0: (std/core/types/list :: V -> V)<a>, cmp0: (a, a) -> (e :: E) std/core/types/order){
    std/core-extras/#list/@lift-maximum-by@2803<a,(e :: E)>(l0, (std/core/types/Nothing<a>), cmp0);
  };
 fun split-by // inline size: 4
  = fn(s: std/core/types/string, pred: (std/core/types/char) -> std/core/types/bool){
    val sl[1,0,1,0] : std/core/sslice/sslice
      = std/core/sslice/Sslice(s, 0, (std/core/sslice/length(s)));
    val acc[1,0,1,0] : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<std/core/types/string>>
      = std/core/types/#cctx/empty<(std/core/types/list :: V -> V)<std/core/types/string>>();
    std/core-extras/@lift-split-by@2804(pred, sl, 0, acc);
  };
inline borrow "^"  fun @select-found // inline size: 0
  = forall<a,b,(e :: E),c> fn(hnd: (find :: (V, E, V) -> V)<a,(e :: E),c>){
    (match (hnd) {
      ((@skip std/core-extras/@Hnd-find((@pat@0: std/core/types/int) : std/core/types/int, (@brk-found: (forall<d> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<a,d,(find :: (V, E, V) -> V)<a>,(e :: E),c>)) : (forall<d> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<a,d,(find :: (V, E, V) -> V)<a>,(e :: E),c>)) : (find :: (V, E, V) -> V)<a,(e :: E),c> ) as @pat: ((find :: (V, E, V) -> V)<a,(e :: E),c>))
         -> @brk-found<b>;
    });
  };
inline  fun found // inline size: 5
  = forall<a,b> fn<<(std/core/types/handled :: ((E, V) -> V) -> X)<(find :: (V, E, V) -> V)<a>>>>(a: a){
    std/core/hnd/@perform1<a,b,(find :: (V, E, V) -> V)<a>,<(std/core/types/handled :: ((E, V) -> V) -> X)<(find :: (V, E, V) -> V)<a>>>>((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(find :: (V, E, V) -> V)<a>>>,(i : std/core/hnd/ev-index) -> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(find :: (V, E, V) -> V)<a>>,(i : std/core/hnd/ev-index) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(find :: (V, E, V) -> V)<a>>> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(find :: (V, E, V) -> V)<a>>>((std/core/hnd/@evv-at<(find :: (V, E, V) -> V)<a>>))((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(find :: (V, E, V) -> V)<a>>>,(i : std/core/types/int) -> std/core/types/ssize_t,(i : std/core/types/int) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(find :: (V, E, V) -> V)<a>>> std/core/types/ssize_t>(std/core/types/@make-ssize_t)(0)))), (forall<(e :: E),c> std/core-extras/@select-found<a,b,(e :: E),c>), a);
  };
 fun find // inline size: 4
  = forall<a,(e :: E)> fn<(e :: E)>(f: () -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(find :: (V, E, V) -> V)<a>>|(e :: E)> a){
    std/core-extras/@handle-find<a,a,(e :: E),a>((std/core-extras/@Hnd-find<a,(e :: E),a>(0, (forall<b> std/core/types/@open<(std/core/types/total :: E),(e :: E),(op : (a) -> (e :: E) a) -> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<a,b,(find :: (V, E, V) -> V)<a>,(e :: E),a>,(op : (a) -> (e :: E) a) -> (e :: E) (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<a,b,(find :: (V, E, V) -> V)<a>,(e :: E),a>>((std/core/hnd/clause-never1<a,b,(e :: E),(find :: (V, E, V) -> V)<a>,a>))((fn<(e :: E)>(a: a){
          a;
        }))))), (fn<(e :: E)>(@x: a){
        @x;
      }), f);
  };
inline  fun flatten // inline size: 1
  = forall<a> fn(item: (std/core/types/maybe :: V -> V)<(std/core/types/maybe :: V -> V)<a>>){
    (match (item) {
      ((std/core/types/Just((x: (std/core/types/maybe :: V -> V)<a>) : (std/core/types/maybe :: V -> V)<a>) : (std/core/types/maybe :: V -> V)<(std/core/types/maybe :: V -> V)<a>> ) as @pat: ((std/core/types/maybe :: V -> V)<(std/core/types/maybe :: V -> V)<a>>))
         -> x;
      ((@skip std/core/types/Nothing() : (std/core/types/maybe :: V -> V)<(std/core/types/maybe :: V -> V)<a>> ) as @pat@0: ((std/core/types/maybe :: V -> V)<(std/core/types/maybe :: V -> V)<a>>))
         -> std/core/types/Nothing<a>;
    });
  };
 fun expect-unjust // inline size: 4
  = forall<a> fn<<(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>>(m: (std/core/types/maybe :: V -> V)<a>, msg: std/core/types/string){
    (match (m) {
      ((std/core/types/Just((a: a) : a) : (std/core/types/maybe :: V -> V)<a> ) as @pat: ((std/core/types/maybe :: V -> V)<a>))
         -> a;
      ((@skip std/core/types/Nothing() : (std/core/types/maybe :: V -> V)<a> ) as @pat@0: ((std/core/types/maybe :: V -> V)<a>))
         -> std/core/exn/throw<a>((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(x : std/core/types/string, y : std/core/types/string) -> std/core/types/string,(x : std/core/types/string, y : std/core/types/string) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> std/core/types/string>(std/core/types/(++))("expect-unjust: ", msg)), (std/core/types/@None<std/core/exn/exception-info>));
    });
  };
borrow "^_"  fun vector-init-list // inline size: 3
  = forall<a> fn(n: std/core/types/int, xs: (std/core/types/list :: V -> V)<(std/core/types/int, a)>){
    val v[148,7,148,7] : (std/core/types/vector :: V -> V)<a>
      = std/core-extras/unsafe-vector<a>((std/core/int/ssize_t(n)));
    val _@0[155,3,155,13] : ()
      = std/core-extras/@lift-vector-init-list@2805<a>(v, xs);
    v;
  };
 fun is-space // inline size: 3
  = fn(c: std/core/types/char){
    match ((std/core/char/(==)(c, ' '))) {
      ((std/core/types/True() : std/core/types/bool ) as @pat: std/core/types/bool)
         -> std/core/types/True;
      (@pat@0: std/core/types/bool)
         -> std/core/char/(==)(c, '\x09');
    };
  };
 fun forz // inline size: 3
  = forall<(e :: E)> fn<(e :: E)>(n: std/core/types/ssize_t, action: (std/core/types/ssize_t) -> (e :: E) ()){
    val i[1,0,1,0] : std/core/types/ssize_t
          = std/core/types/@open<(std/core/types/total :: E),(e :: E),(i : std/core/types/int) -> std/core/types/ssize_t,(i : std/core/types/int) -> (e :: E) std/core/types/ssize_t>(std/core/int/ssize_t)(0);
    std/core-extras/@lift-forz@2806<(e :: E)>(action, n, i);
  };