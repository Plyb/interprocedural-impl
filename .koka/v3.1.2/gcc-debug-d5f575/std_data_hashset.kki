// This module provides an immutable bucket hashset implementation.
module interface std/data/hashset
 
//------------------------------
//#kki: import declarations
 
import std/core/types = std/core/types pub = "";
import std/core/hnd = std/core/hnd pub = "";
import std/core/exn = std/core/exn pub = "";
import std/core/bool = std/core/bool pub = "";
import std/core/order = std/core/order pub = "";
import std/core/char = std/core/char pub = "";
import std/core/int = std/core/int pub = "";
import std/core/vector = std/core/vector pub = "";
import std/core/string = std/core/string pub = "";
import std/core/sslice = std/core/sslice pub = "";
import std/core/list = std/core/list pub = "";
import std/core/maybe = std/core/maybe pub = "";
import std/core/either = std/core/either pub = "";
import std/core/tuple = std/core/tuple pub = "";
import std/core/show = std/core/show pub = "";
import std/core/debug = std/core/debug pub = "";
import std/core/delayed = std/core/delayed pub = "";
import std/core/console = std/core/console pub = "";
import std/test/test = std/test/test pub = "";
import std/test/bench = std/test/bench pub = "";
import std/core = std/core = "";
import std/num/int64 = std/num/int64 = "";
import std/test = std/test = "";
import std/num/random = std/num/random = "";
import std/core-extras = std/core-extras = "";
import std/data/hash = std/data/hash = "";
 
//------------------------------
//#kki: external imports
 
 
//------------------------------
//#kki: fixity declarations
 
 
//------------------------------
//#kki: local imported aliases
 
// An alias for pure effects: a pure function always returns the same result
// when called with the same arguments but may not terminate or raise an exception.
local alias std/core/pure[52,1,52,26] :: E = <(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/div :: X)> = 1;
 
//------------------------------
//#kki: type declarations
 
pub type hash-set[21,1,24,14] <a> :: V -> V {
  pub con Hash-set[21,12,21,19](data: (std/core/types/vector :: V -> V)<(std/core/types/list :: V -> V)<a>>, amount: std/core/types/int, seed: std/core/types/int64){8,2,8} : forall<a> (data : (std/core/types/vector :: V -> V)<(std/core/types/list :: V -> V)<a>>, amount : std/core/types/int, seed : std/core/types/int64) -> (hash-set :: V -> V)<a>;
};
 
//------------------------------
//#kki: declarations
 
// Automatically generated. Retrieves the `data` constructor field of the `:hash-set` type.
pub  fun hash-set/data[22,3,22,6] : forall<a> (^ @this : (hash-set :: V -> V)<a>) -> (std/core/types/vector :: V -> V)<(std/core/types/list :: V -> V)<a>>;
// Automatically generated. Retrieves the `amount` constructor field of the `:hash-set` type.
pub  fun hash-set/amount[23,3,23,8] : forall<a> (^ @this : (hash-set :: V -> V)<a>) -> std/core/types/int;
// Automatically generated. Retrieves the `seed` constructor field of the `:hash-set` type.
pub  fun hash-set/seed[24,3,24,6] : forall<a> (^ @this : (hash-set :: V -> V)<a>) -> std/core/types/int64;
pub  fun hash-set/@copy[21,12,21,19] : forall<a> (@this : (hash-set :: V -> V)<a>, data : (std/core/types/@optional :: V -> V)<(std/core/types/vector :: V -> V)<(std/core/types/list :: V -> V)<a>>>, amount : (std/core/types/@optional :: V -> V)<std/core/types/int>, seed : (std/core/types/@optional :: V -> V)<std/core/types/int64>) -> (hash-set :: V -> V)<a>;
val int-hash[16,5,16,12] : (std/core/types/int, std/core/types/int64) -> std/core/types/int;
val char-hash[17,5,17,13] : (std/core/types/char, std/core/types/int64) -> std/core/types/int;
val bool-hash[18,5,18,13] : (std/core/types/bool, std/core/types/int64) -> std/core/types/int;
val string-hash[19,5,19,15] : (std/core/types/string, std/core/types/int64) -> std/core/types/int;
// Creates a hash-set with a specified inital `capacity`.
// If zero then the hash-set will set capacity to 1.
// The seed is initialized from the thread id.
pub  fun thread/hash-set[29,9,29,23] : forall<a> (capacity : (std/core/types/@optional :: V -> V)<std/core/types/int>) -> (hash-set :: V -> V)<a>;
// monadic lift
 fun random/@mlift-hash-set@10229[1,0,1,0] : forall<a> (capacity : (std/core/types/@optional :: V -> V)<std/core/types/int>, @y-x10097 : std/core/types/int64) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(std/num/random/random :: (E, V) -> V)>> (hash-set :: V -> V)<a>;
// Creates a hash-set with a specified inital `capacity`.
// If zero then the hash-set will set capacity to 1.
// Random effect is needed to initalize the seed.
pub  fun random/hash-set[35,9,35,23] : forall<a> (capacity : (std/core/types/@optional :: V -> V)<std/core/types/int>) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(std/num/random/random :: (E, V) -> V)>> (hash-set :: V -> V)<a>;
// Creates a hash-set with a specified inital `capacity` and a user defined `seed`.
// If zero then the hash-set will set capacity to 1.
pub  fun hash-set-seeded[40,9,40,23] : forall<a> (seed : std/core/types/int64, capacity : (std/core/types/@optional :: V -> V)<std/core/types/int>) -> (hash-set :: V -> V)<a>;
// Fetches the amount of items in the hash-set
pub  fun length[167,9,167,14] : forall<a> (hs : (hash-set :: V -> V)<a>) -> std/core/types/int;
// This helper function either clears out a vector if it is unique or creates a new vector if it isn't unique.
 fun helper/resize[84,5,84,17] : forall<a> (v : (std/core/types/vector :: V -> V)<(std/core/types/list :: V -> V)<a>>) -> (std/core/types/vector :: V -> V)<(std/core/types/list :: V -> V)<a>>;
// Checks if a value is in the hash-set `hs` and returns `True` if found and `False` if not found.
pub  fun contains[159,9,159,16] : forall<a> (hs : (hash-set :: V -> V)<a>, value : a, ?hash : (a, std/core/types/int64) -> std/core/types/int, ?(==) : (a, a) -> std/core/types/bool) -> std/core/types/bool;
// Removes all buckets from the hash-set, effectively clearing the hash-set.
pub  fun clear[171,9,171,13] : forall<a> (hs : (hash-set :: V -> V)<a>) -> (hash-set :: V -> V)<a>;
// Invoke a function `f` for each key-value of the hash-set.
pub  fun foreach[197,9,197,15] : forall<(e :: E),a> (hs : (hash-set :: V -> V)<a>, f : (a) -> (e :: E) ()) -> (e :: E) ();
// This helper will use `buckets` to allow for a `div`-less use of `unsafe-set` to set values in vector `v`.
 fun helper/rehash[109,5,109,17] : forall<a> (v : (std/core/types/vector :: V -> V)<(std/core/types/list :: V -> V)<a>>, buckets : (std/core/types/list :: V -> V)<a>, seed : std/core/types/int64, ?hash : (a, std/core/types/int64) -> std/core/types/int) -> (std/core/types/vector :: V -> V)<(std/core/types/list :: V -> V)<a>>;
pub  fun rehash[95,9,95,14] : forall<a> (v : (std/core/types/vector :: V -> V)<(std/core/types/list :: V -> V)<a>>, buckets : (std/core/types/vector :: V -> V)<(std/core/types/list :: V -> V)<a>>, seed : std/core/types/int64, ?hash : (a, std/core/types/int64) -> std/core/types/int) -> (std/core/types/vector :: V -> V)<(std/core/types/list :: V -> V)<a>>;
// Resizes a hash-set with `new-capacity` being the new capacity of the hashset. 
// If `new-capacity` is smaller than the capacity of the hash-set then there will be more hash collisions.
pub  fun resize[66,9,66,14] : forall<a> (hs : (hash-set :: V -> V)<a>, new-capacity : std/core/types/int, ?hash : (a, std/core/types/int64) -> std/core/types/int) -> (hash-set :: V -> V)<a>;
// Internal function that dictates when to resize the hash-set. This can be overridden with implicits.
pub  fun when-resize[120,9,120,19] : (table-size : std/core/types/int, item-count : std/core/types/int) -> std/core/types/bool;
// Internal function that determines the new size of a hash-set when inserting. This can be overridden with implicits.
pub  fun resizer[127,9,127,15] : (table-size : std/core/types/int, item-count : std/core/types/int) -> std/core/types/int;
// Inserts a `value` into the hash-set.
pub  fun insert[131,9,131,14] : forall<a> (hs : (hash-set :: V -> V)<a>, value : a, ?hash : (a, std/core/types/int64) -> std/core/types/int, ?(==) : (a, a) -> std/core/types/bool, ?when-resize : (std/core/types/int, std/core/types/int) -> std/core/types/bool, ?resizer : (std/core/types/int, std/core/types/int) -> std/core/types/int) -> (hash-set :: V -> V)<a>;
 fun from-list-helper[57,5,57,20] : forall<a> (hs : (hash-set :: V -> V)<a>, l : (std/core/types/list :: V -> V)<a>, ?hash : (a, std/core/types/int64) -> std/core/types/int, ?(==) : (a, a) -> std/core/types/bool) -> (hash-set :: V -> V)<a>;
// monadic lift
 fun random/list/@mlift-hash-set@10230[1,0,1,0] : forall<a> (xs : (std/core/types/list :: V -> V)<a>, ?(==) : (a, a) -> std/core/types/bool, ?hash : (a, std/core/types/int64) -> std/core/types/int, @y-x10100 : (hash-set :: V -> V)<a>) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(std/num/random/random :: (E, V) -> V)>> (hash-set :: V -> V)<a>;
// Creates a hash-set from a list `xs`. This hash-set has the same capacity as the length of the list `xs`.
// Random effect is needed to initalize the seed.
pub  fun random/list/hash-set[50,9,50,28] : forall<a> (xs : (std/core/types/list :: V -> V)<a>, ?hash : (a, std/core/types/int64) -> std/core/types/int, ?(==) : (a, a) -> std/core/types/bool) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(std/num/random/random :: (E, V) -> V)>> (hash-set :: V -> V)<a>;
// Creates a hash-set from a list `xs`. This hash-set has the same capacity as the length of the list `xs`.
// The seed is initialized from the thread id.
pub  fun thread/list/hash-set[45,9,45,28] : forall<a> (xs : (std/core/types/list :: V -> V)<a>, ?hash : (a, std/core/types/int64) -> std/core/types/int, ?(==) : (a, a) -> std/core/types/bool) -> (hash-set :: V -> V)<a>;
// Creates a hash-set from a list `xs` and with a `seed`. This hash-set has the same capacity as the length of the list `xs`.
pub  fun list/hash-set-seeded[54,9,54,28] : forall<a> (xs : (std/core/types/list :: V -> V)<a>, seed : std/core/types/int64, ?hash : (a, std/core/types/int64) -> std/core/types/int, ?(==) : (a, a) -> std/core/types/bool) -> (hash-set :: V -> V)<a>;
// Removes a value from the hash-set with a given `value`.
pub  fun remove[147,9,147,14] : forall<a> (hs : (hash-set :: V -> V)<a>, value : a, ?hash : (a, std/core/types/int64) -> std/core/types/int, ?(==) : (a, a) -> std/core/types/bool) -> (hash-set :: V -> V)<a>;
// monadic lift
 fun effect/@mlift-map@10231[1,0,1,0] : forall<a,b,(e :: E)> (hs : (hash-set :: V -> V)<a>, new-data : (std/core/types/vector :: V -> V)<(std/core/types/list :: V -> V)<b>>) -> (e :: E) (hash-set :: V -> V)<b>;
// Applies a function `f` to each key-value of the hash-set via a tuple.
pub  fun effect/map[183,9,183,18] : forall<a,b,(e :: E)> (hs : (hash-set :: V -> V)<a>, f : (a) -> (e :: E) b) -> (e :: E) (hash-set :: V -> V)<b>;
// Applies a function `f` to each key-value of the hash-set via a tuple.
pub  fun unique/map[189,9,189,18] : forall<a,b> (hs : (hash-set :: V -> V)<a>, f : (a) -> b) -> (hash-set :: V -> V)<b>;
// monadic lift
 fun @mlift-test-hash-set@10232[1,0,1,0] : forall<(h :: H)> (@y-x10136 : (hash-set :: V -> V)<std/core/types/int>) -> <(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(std/test/test/test :: (E, V) -> V)>,(std/core/console/console :: X),(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(std/test/test/test-scope :: (E, V) -> V)>> std/core/types/int;
// monadic lift
 fun @mlift-test-hash-set@10233[1,0,1,0] : forall<(h :: H)> (hs@3@0 : (std/core/types/local-var :: (H, V) -> V)<(h :: H),(hash-set :: V -> V)<std/core/types/int>>, i@2 : std/core/types/int, @y-x10133 : (hash-set :: V -> V)<std/core/types/int>) -> <(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(std/test/test/test :: (E, V) -> V)>,(std/core/console/console :: X),(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(std/test/test/test-scope :: (E, V) -> V)>> ();
// monadic lift
 fun @mlift-test-hash-set@10234[1,0,1,0] : forall<(h :: H)> (hs@3@0 : (std/core/types/local-var :: (H, V) -> V)<(h :: H),(hash-set :: V -> V)<std/core/types/int>>, wild_@8 : ()) -> <(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(std/test/test/test :: (E, V) -> V)>,(std/core/console/console :: X),(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(std/test/test/test-scope :: (E, V) -> V)>> std/core/types/int;
// monadic lift
 fun @mlift-test-hash-set@10235[1,0,1,0] : forall<(h :: H)> (hs@3@0 : (std/core/types/local-var :: (H, V) -> V)<(h :: H),(hash-set :: V -> V)<std/core/types/int>>, wild_@7 : ()) -> <(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(std/test/test/test :: (E, V) -> V)>,(std/core/console/console :: X),(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(std/test/test/test-scope :: (E, V) -> V)>> std/core/types/int;
// monadic lift
 fun @mlift-test-hash-set@10236[1,0,1,0] : forall<(h :: H)> (hs@3@0 : (std/core/types/local-var :: (H, V) -> V)<(h :: H),(hash-set :: V -> V)<std/core/types/int>>, @y-x10131 : (hash-set :: V -> V)<std/core/types/int>) -> <(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(std/test/test/test :: (E, V) -> V)>,(std/core/console/console :: X),(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(std/test/test/test-scope :: (E, V) -> V)>> std/core/types/int;
// monadic lift
 fun @mlift-test-hash-set@10237[1,0,1,0] : forall<(h :: H)> (hs@3@0 : (std/core/types/local-var :: (H, V) -> V)<(h :: H),(hash-set :: V -> V)<std/core/types/int>>, i@1 : std/core/types/int, @y-x10128 : (hash-set :: V -> V)<std/core/types/int>) -> <(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(std/test/test/test :: (E, V) -> V)>,(std/core/console/console :: X),(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(std/test/test/test-scope :: (E, V) -> V)>> ();
// monadic lift
 fun @mlift-test-hash-set@10238[1,0,1,0] : forall<(h :: H)> (hs@3@0 : (std/core/types/local-var :: (H, V) -> V)<(h :: H),(hash-set :: V -> V)<std/core/types/int>>, wild_@6 : ()) -> <(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(std/test/test/test :: (E, V) -> V)>,(std/core/console/console :: X),(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(std/test/test/test-scope :: (E, V) -> V)>> ();
// monadic lift
 fun @mlift-test-hash-set@10239[1,0,1,0] : forall<(h :: H)> (@y-x10122 : (hash-set :: V -> V)<std/core/types/int>) -> <(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(std/test/test/test :: (E, V) -> V)>,(std/core/console/console :: X),(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(std/test/test/test-scope :: (E, V) -> V)>> std/core/types/int;
// monadic lift
 fun @mlift-test-hash-set@10240[1,0,1,0] : forall<(h :: H)> (hs@2 : (std/core/types/local-var :: (H, V) -> V)<(h :: H),(hash-set :: V -> V)<std/core/types/int>>, wild_@4 : ()) -> <(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(std/test/test/test :: (E, V) -> V)>,(std/core/console/console :: X),(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(std/test/test/test-scope :: (E, V) -> V)>> std/core/types/int;
// monadic lift
 fun @mlift-test-hash-set@10241[1,0,1,0] : forall<(h :: H)> (hs@2 : (std/core/types/local-var :: (H, V) -> V)<(h :: H),(hash-set :: V -> V)<std/core/types/int>>, @y-x10120 : (hash-set :: V -> V)<std/core/types/int>) -> <(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(std/test/test/test :: (E, V) -> V)>,(std/core/console/console :: X),(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(std/test/test/test-scope :: (E, V) -> V)>> std/core/types/int;
// monadic lift
 fun @mlift-test-hash-set@10242[1,0,1,0] : forall<(h :: H)> (hs@2 : (std/core/types/local-var :: (H, V) -> V)<(h :: H),(hash-set :: V -> V)<std/core/types/int>>, i@0 : std/core/types/int, @y-x10117 : (hash-set :: V -> V)<std/core/types/int>) -> <(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(std/test/test/test :: (E, V) -> V)>,(std/core/console/console :: X),(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(std/test/test/test-scope :: (E, V) -> V)>> ();
// monadic lift
 fun @mlift-test-hash-set@10243[1,0,1,0] : forall<(h :: H)> (hs@2 : (std/core/types/local-var :: (H, V) -> V)<(h :: H),(hash-set :: V -> V)<std/core/types/int>>, wild_@3 : ()) -> <(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(std/test/test/test :: (E, V) -> V)>,(std/core/console/console :: X),(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(std/test/test/test-scope :: (E, V) -> V)>> ();
// monadic lift
 fun @mlift-test-hash-set@10244[1,0,1,0] : (wild_@5 : ()) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(std/test/test/test-scope :: (E, V) -> V)>,(std/core/console/console :: X),(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> ();
// monadic lift
 fun @mlift-test-hash-set@10245[1,0,1,0] : forall<(h :: H)> (hs@1@0 : (std/core/types/local-var :: (H, V) -> V)<(h :: H),(hash-set :: V -> V)<std/core/types/int>>, i : std/core/types/int, @y-x10109 : (hash-set :: V -> V)<std/core/types/int>) -> <(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(std/test/test/test :: (E, V) -> V)>,(std/core/console/console :: X),(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(std/test/test/test-scope :: (E, V) -> V)>> ();
// monadic lift
 fun @mlift-test-hash-set@10246[1,0,1,0] : forall<(h :: H)> (wild_@1 : ()) -> <(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(std/test/test/test :: (E, V) -> V)>,(std/core/console/console :: X),(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(std/test/test/test-scope :: (E, V) -> V)>> std/core/types/bool;
// monadic lift
 fun @mlift-test-hash-set@10247[1,0,1,0] : (wild_@2 : ()) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(std/test/test/test-scope :: (E, V) -> V)>,(std/core/console/console :: X),(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> ();
// monadic lift
 fun @mlift-test-hash-set@10248[1,0,1,0] : (wild_@0 : ()) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(std/test/test/test-scope :: (E, V) -> V)>,(std/core/console/console :: X),(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> ();
// monadic lift
 fun @mlift-test-hash-set@10249[1,0,1,0] : (wild_ : ()) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(std/test/test/test-scope :: (E, V) -> V)>,(std/core/console/console :: X),(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> ();
 fun test-hash-set[204,5,204,17] : () -> <(std/core/pure :: E),(std/core/console/console :: X)> ();
 
//------------------------------
//#kki: external declarations
 
 
//------------------------------
//#kki: inline definitions
 
//.inline-section
specialize "_*_*"  fun contains // inline size: 1
  = forall<a> fn(hs: (hash-set :: V -> V)<a>, value: a, @implicit/hash: (a, std/core/types/int64) -> std/core/types/int, @implicit/(==): (a, a) -> std/core/types/bool){
    val the-hash[160,7,160,14] : std/core/types/int
      = @implicit/hash(value, (match (hs) {
          ((@skip std/data/hashset/Hash-set((@pat@0: (std/core/types/vector :: V -> V)<(std/core/types/list :: V -> V)<a>>) : (std/core/types/vector :: V -> V)<(std/core/types/list :: V -> V)<a>>, (@pat@1: std/core/types/int) : std/core/types/int, (@x: std/core/types/int64) : std/core/types/int64) : (hash-set :: V -> V)<a> ) as @pat: ((hash-set :: V -> V)<a>))
             -> @x;
        }));
    val position[161,7,161,14] : std/core/types/int
      = std/core/int/(%)(the-hash, (std/core/int/#ssize_t/int((std/core/vector/lengthz<(std/core/types/list :: V -> V)<a>>((match (hs) {
          ((@skip std/data/hashset/Hash-set((@x@0: (std/core/types/vector :: V -> V)<(std/core/types/list :: V -> V)<a>>) : (std/core/types/vector :: V -> V)<(std/core/types/list :: V -> V)<a>>, (@pat@0@0: std/core/types/int) : std/core/types/int, (@pat@1@0: std/core/types/int64) : std/core/types/int64) : (hash-set :: V -> V)<a> ) as @pat@2: ((hash-set :: V -> V)<a>))
             -> @x@0;
        }))))));
    (match ((std/core/list/filter<a,(std/core/types/total :: E)>((std/core-extras/unsafe-idx<(std/core/types/list :: V -> V)<a>>((match (hs) {
          ((@skip std/data/hashset/Hash-set((@x@1: (std/core/types/vector :: V -> V)<(std/core/types/list :: V -> V)<a>>) : (std/core/types/vector :: V -> V)<(std/core/types/list :: V -> V)<a>>, (@pat@0@1: std/core/types/int) : std/core/types/int, (@pat@1@1: std/core/types/int64) : std/core/types/int64) : (hash-set :: V -> V)<a> ) as @pat@3: ((hash-set :: V -> V)<a>))
             -> @x@1;
        }), (std/core/int/ssize_t(position)))), (fn(x: a){
        (@implicit/(==)(x, value));
      })))) {
      ((std/core/types/Cons((@pat@0@2: a) : a, (@pat@1@2: (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a> ) as @pat@4: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/True;
      ((@skip std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@2@0: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/False;
    });
  };
specialize "**"  fun foreach // inline size: 1
  = forall<(e :: E),a> fn<(e :: E)>(hs: (hash-set :: V -> V)<a>, f: (a) -> (e :: E) ()){
    std/core/for<(e :: E)>((std/core/types/@open<(std/core/types/total :: E),(e :: E),(v : (std/core/types/vector :: V -> V)<(std/core/types/list :: V -> V)<a>>) -> std/core/types/int,(v : (std/core/types/vector :: V -> V)<(std/core/types/list :: V -> V)<a>>) -> (e :: E) std/core/types/int>((fn(v: (std/core/types/vector :: V -> V)<(std/core/types/list :: V -> V)<a>>){
        (std/core/int/#ssize_t/int((std/core/vector/lengthz<(std/core/types/list :: V -> V)<a>>(v))));
      }))((std/core/types/@open<(std/core/types/total :: E),(e :: E),((hash-set :: V -> V)<a>) -> (std/core/types/vector :: V -> V)<(std/core/types/list :: V -> V)<a>>,((hash-set :: V -> V)<a>) -> (e :: E) (std/core/types/vector :: V -> V)<(std/core/types/list :: V -> V)<a>>>((fn(@this: (hash-set :: V -> V)<a>){
        (match (@this) {
          ((@skip std/data/hashset/Hash-set((@x: (std/core/types/vector :: V -> V)<(std/core/types/list :: V -> V)<a>>) : (std/core/types/vector :: V -> V)<(std/core/types/list :: V -> V)<a>>, (@pat@0: std/core/types/int) : std/core/types/int, (@pat@1: std/core/types/int64) : std/core/types/int64) : (hash-set :: V -> V)<a> ) as @pat: ((hash-set :: V -> V)<a>))
             -> @x;
        });
      }))(hs)))), (fn<(e :: E)>(i: std/core/types/int){
        (std/core/list/foreach<a,(e :: E)>((std/core/types/@open<(std/core/types/total :: E),(e :: E),(v : (std/core/types/vector :: V -> V)<(std/core/types/list :: V -> V)<a>>, index : std/core/types/ssize_t) -> (std/core/types/list :: V -> V)<a>,(v : (std/core/types/vector :: V -> V)<(std/core/types/list :: V -> V)<a>>, index : std/core/types/ssize_t) -> (e :: E) (std/core/types/list :: V -> V)<a>>((std/core-extras/unsafe-idx<(std/core/types/list :: V -> V)<a>>))((std/core/types/@open<(std/core/types/total :: E),(e :: E),((hash-set :: V -> V)<a>) -> (std/core/types/vector :: V -> V)<(std/core/types/list :: V -> V)<a>>,((hash-set :: V -> V)<a>) -> (e :: E) (std/core/types/vector :: V -> V)<(std/core/types/list :: V -> V)<a>>>((fn(@this@0: (hash-set :: V -> V)<a>){
              (match (@this@0) {
                ((@skip std/data/hashset/Hash-set((@x@0: (std/core/types/vector :: V -> V)<(std/core/types/list :: V -> V)<a>>) : (std/core/types/vector :: V -> V)<(std/core/types/list :: V -> V)<a>>, (@pat@0@0: std/core/types/int) : std/core/types/int, (@pat@1@0: std/core/types/int64) : std/core/types/int64) : (hash-set :: V -> V)<a> ) as @pat@2: ((hash-set :: V -> V)<a>))
                   -> @x@0;
              });
            }))(hs)), (std/core/types/@open<(std/core/types/total :: E),(e :: E),(i : std/core/types/int) -> std/core/types/ssize_t,(i : std/core/types/int) -> (e :: E) std/core/types/ssize_t>(std/core/int/ssize_t)(i)))), f));
      }));
  };
specialize "___*"  fun from-list-helper // inline size: 1
  = forall<a> fn(hs: (hash-set :: V -> V)<a>, l: (std/core/types/list :: V -> V)<a>, @implicit/hash: (a, std/core/types/int64) -> std/core/types/int, @implicit/(==): (a, a) -> std/core/types/bool){
    (match (l) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat: ((std/core/types/list :: V -> V)<a>))
         -> hs;
      ((@skip std/core/types/Cons((x: a) : a, (xs: (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a> ) as @pat@0: ((std/core/types/list :: V -> V)<a>))
         -> std/data/hashset/from-list-helper<a>((std/data/hashset/insert<a>(hs, x, @implicit/hash, @implicit/(==), std/data/hashset/when-resize, std/data/hashset/resizer)), xs, @implicit/hash, @implicit/(==));
    });
  };
specialize "_*_*__"  fun insert // inline size: 1
  = forall<a> fn(hs: (hash-set :: V -> V)<a>, value: a, @implicit/hash: (a, std/core/types/int64) -> std/core/types/int, @implicit/(==): (a, a) -> std/core/types/bool, @implicit/when-resize: (std/core/types/int, std/core/types/int) -> std/core/types/bool, @implicit/resizer: (std/core/types/int, std/core/types/int) -> std/core/types/int){
    val the-hash[132,7,132,14] : std/core/types/int
      = @implicit/hash(value, (match (hs) {
          ((@skip std/data/hashset/Hash-set((@pat@0: (std/core/types/vector :: V -> V)<(std/core/types/list :: V -> V)<a>>) : (std/core/types/vector :: V -> V)<(std/core/types/list :: V -> V)<a>>, (@pat@1: std/core/types/int) : std/core/types/int, (@x: std/core/types/int64) : std/core/types/int64) : (hash-set :: V -> V)<a> ) as @pat: ((hash-set :: V -> V)<a>))
             -> @x;
        }));
    val position[133,7,133,14] : std/core/types/int
      = std/core/int/(%)(the-hash, (std/core/int/#ssize_t/int((std/core/vector/lengthz<(std/core/types/list :: V -> V)<a>>((match (hs) {
          ((@skip std/data/hashset/Hash-set((@x@0: (std/core/types/vector :: V -> V)<(std/core/types/list :: V -> V)<a>>) : (std/core/types/vector :: V -> V)<(std/core/types/list :: V -> V)<a>>, (@pat@0@0: std/core/types/int) : std/core/types/int, (@pat@1@0: std/core/types/int64) : std/core/types/int64) : (hash-set :: V -> V)<a> ) as @pat@2: ((hash-set :: V -> V)<a>))
             -> @x@0;
        }))))));
    val new-hs[134,7,134,12] : (hash-set :: V -> V)<a>
      = (match (hs) {
        ((@skip std/data/hashset/Hash-set((data: (std/core/types/vector :: V -> V)<(std/core/types/list :: V -> V)<a>>) : (std/core/types/vector :: V -> V)<(std/core/types/list :: V -> V)<a>>, (amount: std/core/types/int) : std/core/types/int, (seed: std/core/types/int64) : std/core/types/int64) : (hash-set :: V -> V)<a> ) as @pat@3: ((hash-set :: V -> V)<a>))
           -> val xs@10031[1,0,1,0] : (std/core/types/list :: V -> V)<a>
                = std/core-extras/unsafe-idx<(std/core/types/list :: V -> V)<a>>(data, (std/core/int/ssize_t(position)));
              val old-bucket-size[136,11,136,25] : std/core/types/int
                = std/core/list/@lift-length@4947<a>(xs@10031, 0);
              val bucket[137,11,137,16] : (std/core/types/list :: V -> V)<a>
                = std/core/types/Cons<a>(value, (std/core/list/filter<a,(std/core/types/total :: E)>((std/core-extras/unsafe-idx<(std/core/types/list :: V -> V)<a>>(data, (std/core/int/ssize_t(position)))), (fn(x: a){
                      val b@10032[1,0,1,0] : std/core/types/bool
                            = (@implicit/(==)(x, value));
                      (match (b@10032) {
                        ((std/core/types/True() : std/core/types/bool ) as @pat@4: std/core/types/bool)
                           -> std/core/types/False;
                        ((@skip std/core/types/False() : std/core/types/bool ) as @pat@0@1: std/core/types/bool)
                           -> std/core/types/True;
                      });
                    }))));
              val new-data[138,11,138,18] : (std/core/types/vector :: V -> V)<(std/core/types/list :: V -> V)<a>>
                = std/core-extras/unsafe-set<(std/core/types/list :: V -> V)<a>>(data, position, bucket);
              val xs@0@10033[1,0,1,0] : (std/core/types/list :: V -> V)<a>
                = std/core-extras/unsafe-idx<(std/core/types/list :: V -> V)<a>>(new-data, (std/core/int/ssize_t(position)));
              val new-amount[139,11,139,20] : std/core/types/int
                = (match ((std/core/int/(<)(old-bucket-size, (std/core/list/@lift-length@4947<a>(xs@0@10033, 0))))) {
                  ((std/core/types/True() : std/core/types/bool ) as @pat@0@2: std/core/types/bool)
                     -> std/core/int/int-add(amount, 1);
                  ((@skip std/core/types/False() : std/core/types/bool ) as @pat@1@1: std/core/types/bool)
                     -> amount;
                });
          std/data/hashset/Hash-set<a>(new-data, new-amount, seed);
      });
    (match ((@implicit/when-resize((std/core/int/#ssize_t/int((std/core/vector/lengthz<(std/core/types/list :: V -> V)<a>>((match (new-hs) {
        ((@skip std/data/hashset/Hash-set((@x@1: (std/core/types/vector :: V -> V)<(std/core/types/list :: V -> V)<a>>) : (std/core/types/vector :: V -> V)<(std/core/types/list :: V -> V)<a>>, (@pat@0@3: std/core/types/int) : std/core/types/int, (@pat@1@2: std/core/types/int64) : std/core/types/int64) : (hash-set :: V -> V)<a> ) as @pat@5: ((hash-set :: V -> V)<a>))
           -> @x@1;
      }))))), (match (new-hs) {
        ((@skip std/data/hashset/Hash-set((@pat@0@4: (std/core/types/vector :: V -> V)<(std/core/types/list :: V -> V)<a>>) : (std/core/types/vector :: V -> V)<(std/core/types/list :: V -> V)<a>>, (@x@2: std/core/types/int) : std/core/types/int, (@pat@1@3: std/core/types/int64) : std/core/types/int64) : (hash-set :: V -> V)<a> ) as @pat@6: ((hash-set :: V -> V)<a>))
           -> @x@2;
      })))) {
      ((std/core/types/True() : std/core/types/bool ) as @pat@2@0: std/core/types/bool)
         -> std/data/hashset/resize<a>(new-hs, (@implicit/resizer((std/core/int/#ssize_t/int((std/core/vector/lengthz<(std/core/types/list :: V -> V)<a>>((match (new-hs) {
              ((@skip std/data/hashset/Hash-set((@x@3: (std/core/types/vector :: V -> V)<(std/core/types/list :: V -> V)<a>>) : (std/core/types/vector :: V -> V)<(std/core/types/list :: V -> V)<a>>, (@pat@0@5: std/core/types/int) : std/core/types/int, (@pat@1@4: std/core/types/int64) : std/core/types/int64) : (hash-set :: V -> V)<a> ) as @pat@7: ((hash-set :: V -> V)<a>))
                 -> @x@3;
            }))))), (match (new-hs) {
              ((@skip std/data/hashset/Hash-set((@pat@0@6: (std/core/types/vector :: V -> V)<(std/core/types/list :: V -> V)<a>>) : (std/core/types/vector :: V -> V)<(std/core/types/list :: V -> V)<a>>, (@x@4: std/core/types/int) : std/core/types/int, (@pat@1@5: std/core/types/int64) : std/core/types/int64) : (hash-set :: V -> V)<a> ) as @pat@8: ((hash-set :: V -> V)<a>))
                 -> @x@4;
            }))), @implicit/hash);
      ((@skip std/core/types/False() : std/core/types/bool ) as @pat@3@0: std/core/types/bool)
         -> new-hs;
    });
  };
specialize "****"  fun rehash // inline size: 1
  = forall<a> fn(v: (std/core/types/vector :: V -> V)<(std/core/types/list :: V -> V)<a>>, buckets: (std/core/types/vector :: V -> V)<(std/core/types/list :: V -> V)<a>>, seed: std/core/types/int64, @implicit/hash: (a, std/core/types/int64) -> std/core/types/int){
    (match ((std/core-extras/is-vec-unique<(std/core/types/list :: V -> V)<a>>(v))) {
      ((std/core/types/True() : std/core/types/bool ) as @pat: std/core/types/bool)
         -> val _[97,5,97,19] : ()
                  = std/core/vector/foreach<(std/core/types/list :: V -> V)<a>,(std/core/types/total :: E)>(buckets, (fn(bucket: (std/core/types/list :: V -> V)<a>){
                      (std/core/list/foreach<a,(std/core/types/total :: E)>(bucket, (fn(entry: a){
                          val the-hash[99,13,99,20] : std/core/types/int
                            = (@implicit/hash(entry, seed));
                          val position[100,13,100,20] : std/core/types/int
                            = (std/core/int/(%)(the-hash, (std/core/int/#ssize_t/int((std/core/vector/lengthz<(std/core/types/list :: V -> V)<a>>(v))))));
                          (match ((std/core/vector/at<(std/core/types/list :: V -> V)<a>>(v, position))) {
                            ((std/core/types/Nothing() : (std/core/types/maybe :: V -> V)<(std/core/types/list :: V -> V)<a>> ) as @pat@0: ((std/core/types/maybe :: V -> V)<(std/core/types/list :: V -> V)<a>>))
                               -> std/core/types/Unit;
                            ((@skip std/core/types/Just((xs: (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a>) : (std/core/types/maybe :: V -> V)<(std/core/types/list :: V -> V)<a>> ) as @pat@1: ((std/core/types/maybe :: V -> V)<(std/core/types/list :: V -> V)<a>>))
                               -> std/core-extras/unsafe-assign<(std/core/types/list :: V -> V)<a>>(v, (std/core/int/ssize_t(position)), (std/core/types/Cons<a>(entry, xs)));
                          });
                        })));
                    }));
        v;
      ((@skip std/core/types/False() : std/core/types/bool ) as @pat@2: std/core/types/bool)
         -> std/data/hashset/#helper/rehash<a>(v, (std/core/list/flatmap<(std/core/types/list :: V -> V)<a>,a,(std/core/types/total :: E)>((std/core/vector/vlist<(std/core/types/list :: V -> V)<a>>(buckets, (std/core/types/@None<(std/core/types/list :: V -> V)<(std/core/types/list :: V -> V)<a>>>))), (fn(x: (std/core/types/list :: V -> V)<a>){
              x;
            }))), seed, @implicit/hash);
    });
  };
specialize "_*_*"  fun remove // inline size: 1
  = forall<a> fn(hs: (hash-set :: V -> V)<a>, value: a, @implicit/hash: (a, std/core/types/int64) -> std/core/types/int, @implicit/(==): (a, a) -> std/core/types/bool){
    val the-hash[148,7,148,14] : std/core/types/int
      = @implicit/hash(value, (match (hs) {
          ((@skip std/data/hashset/Hash-set((@pat@0: (std/core/types/vector :: V -> V)<(std/core/types/list :: V -> V)<a>>) : (std/core/types/vector :: V -> V)<(std/core/types/list :: V -> V)<a>>, (@pat@1: std/core/types/int) : std/core/types/int, (@x: std/core/types/int64) : std/core/types/int64) : (hash-set :: V -> V)<a> ) as @pat: ((hash-set :: V -> V)<a>))
             -> @x;
        }));
    val position[149,7,149,14] : std/core/types/int
      = std/core/int/(%)(the-hash, (std/core/int/#ssize_t/int((std/core/vector/lengthz<(std/core/types/list :: V -> V)<a>>((match (hs) {
          ((@skip std/data/hashset/Hash-set((@x@0: (std/core/types/vector :: V -> V)<(std/core/types/list :: V -> V)<a>>) : (std/core/types/vector :: V -> V)<(std/core/types/list :: V -> V)<a>>, (@pat@0@0: std/core/types/int) : std/core/types/int, (@pat@1@0: std/core/types/int64) : std/core/types/int64) : (hash-set :: V -> V)<a> ) as @pat@2: ((hash-set :: V -> V)<a>))
             -> @x@0;
        }))))));
    (match (hs) {
      ((@skip std/data/hashset/Hash-set((data: (std/core/types/vector :: V -> V)<(std/core/types/list :: V -> V)<a>>) : (std/core/types/vector :: V -> V)<(std/core/types/list :: V -> V)<a>>, (amount: std/core/types/int) : std/core/types/int, (seed: std/core/types/int64) : std/core/types/int64) : (hash-set :: V -> V)<a> ) as @pat@3: ((hash-set :: V -> V)<a>))
         -> val xs@10054[1,0,1,0] : (std/core/types/list :: V -> V)<a>
              = std/core-extras/unsafe-idx<(std/core/types/list :: V -> V)<a>>(data, (std/core/int/ssize_t(position)));
            val old-bucket-size[152,11,152,25] : std/core/types/int
              = std/core/list/@lift-length@4947<a>(xs@10054, 0);
            val bucket[153,11,153,16] : (std/core/types/list :: V -> V)<a>
              = std/core/list/filter<a,(std/core/types/total :: E)>((std/core-extras/unsafe-idx<(std/core/types/list :: V -> V)<a>>(data, (std/core/int/ssize_t(position)))), (fn(x: a){
                  val b@10055[1,0,1,0] : std/core/types/bool
                        = (@implicit/(==)(x, value));
                  (match (b@10055) {
                    ((std/core/types/True() : std/core/types/bool ) as @pat@4: std/core/types/bool)
                       -> std/core/types/False;
                    ((@skip std/core/types/False() : std/core/types/bool ) as @pat@0@1: std/core/types/bool)
                       -> std/core/types/True;
                  });
                }));
            val new-data[154,11,154,18] : (std/core/types/vector :: V -> V)<(std/core/types/list :: V -> V)<a>>
              = std/core-extras/unsafe-set<(std/core/types/list :: V -> V)<a>>(data, position, bucket);
            val xs@0@10056[1,0,1,0] : (std/core/types/list :: V -> V)<a>
              = std/core-extras/unsafe-idx<(std/core/types/list :: V -> V)<a>>(new-data, (std/core/int/ssize_t(position)));
            val new-amount[155,11,155,20] : std/core/types/int
              = (match ((std/core/int/(>)(old-bucket-size, (std/core/list/@lift-length@4947<a>(xs@0@10056, 0))))) {
                ((std/core/types/True() : std/core/types/bool ) as @pat@0@2: std/core/types/bool)
                   -> std/core/int/int-sub(amount, 1);
                ((@skip std/core/types/False() : std/core/types/bool ) as @pat@1@1: std/core/types/bool)
                   -> amount;
              });
        std/data/hashset/Hash-set<a>(data, (std/core/int/int-sub(amount, 1)), seed);
    });
  };
specialize "__*"  fun resize // inline size: 1
  = forall<a> fn(hs: (hash-set :: V -> V)<a>, new-capacity: std/core/types/int, @implicit/hash: (a, std/core/types/int64) -> std/core/types/int){
    val buckets[67,7,67,13] : forall<b> (std/core/types/vector :: V -> V)<(std/core/types/list :: V -> V)<b>>
          = forall<b> val n@10023[1,0,1,0] : std/core/types/int
                            = std/core/int/#ssize_t/int((std/core/vector/lengthz<(std/core/types/list :: V -> V)<a>>((match (hs) {
                              ((@skip std/data/hashset/Hash-set((@x: (std/core/types/vector :: V -> V)<(std/core/types/list :: V -> V)<a>>) : (std/core/types/vector :: V -> V)<(std/core/types/list :: V -> V)<a>>, (@pat@0: std/core/types/int) : std/core/types/int, (@pat@1: std/core/types/int64) : std/core/types/int64) : (hash-set :: V -> V)<a> ) as @pat: ((hash-set :: V -> V)<a>))
                                 -> @x;
                            }))));
          std/core/vector/vector-alloc<(std/core/types/list :: V -> V)<b>,(std/core/types/total :: E)>((std/core/int/ssize_t(n@10023)), (std/core/types/Nil<b>));
    (match (hs) {
      ((@skip std/data/hashset/Hash-set((data: (std/core/types/vector :: V -> V)<(std/core/types/list :: V -> V)<a>>) : (std/core/types/vector :: V -> V)<(std/core/types/list :: V -> V)<a>>, (size: std/core/types/int) : std/core/types/int, (seed: std/core/types/int64) : std/core/types/int64) : (hash-set :: V -> V)<a> ) as @pat@2: ((hash-set :: V -> V)<a>))
         -> val _@0[70,7,70,24] : ()
              = std/core/for<(std/core/types/total :: E)>((std/core/int/#ssize_t/int((std/core/vector/lengthz<(std/core/types/list :: V -> V)<a>>(data)))), (fn(i: std/core/types/int){
                  (match ((std/core/vector/at<(std/core/types/list :: V -> V)<a>>(data, i))) {
                    ((std/core/types/Nothing() : (std/core/types/maybe :: V -> V)<(std/core/types/list :: V -> V)<a>> ) as @pat@0@0: ((std/core/types/maybe :: V -> V)<(std/core/types/list :: V -> V)<a>>))
                       -> std/core/types/Unit;
                    ((@skip std/core/types/Just((x: (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a>) : (std/core/types/maybe :: V -> V)<(std/core/types/list :: V -> V)<a>> ) as @pat@1@0: ((std/core/types/maybe :: V -> V)<(std/core/types/list :: V -> V)<a>>))
                       -> val _[74,13,74,40] : ()
                                = std/core-extras/drop-at<(std/core/types/list :: V -> V)<_b>>((buckets<_b>), (std/core/int/ssize_t(i)));
                      std/core-extras/unsafe-assign<(std/core/types/list :: V -> V)<a>>((buckets<a>), (std/core/int/ssize_t(i)), x);
                  });
                }));
            val new-data[79,11,79,18] : (std/core/types/vector :: V -> V)<(std/core/types/list :: V -> V)<a>>
              = std/core-extras/realloc<(std/core/types/list :: V -> V)<a>>(data, (std/core/int/ssize_t(new-capacity)));
        std/data/hashset/Hash-set<a>((std/data/hashset/rehash<a>((std/data/hashset/#helper/resize<a>(new-data)), (buckets<a>), seed, @implicit/hash)), size, seed);
    });
  };
specialize "**"  fun effect/map // inline size: 1
  = forall<a,b,(e :: E)> fn<(e :: E)>(hs: (hash-set :: V -> V)<a>, f: (a) -> (e :: E) b){
    val new-data[184,7,184,14] : (std/core/types/vector :: V -> V)<(std/core/types/list :: V -> V)<b>>
          = std/core/vector/map<(std/core/types/list :: V -> V)<a>,(std/core/types/list :: V -> V)<b>,(e :: E)>((std/core/types/@open<(std/core/types/total :: E),(e :: E),((hash-set :: V -> V)<a>) -> (std/core/types/vector :: V -> V)<(std/core/types/list :: V -> V)<a>>,((hash-set :: V -> V)<a>) -> (e :: E) (std/core/types/vector :: V -> V)<(std/core/types/list :: V -> V)<a>>>((fn(@this: (hash-set :: V -> V)<a>){
              (match (@this) {
                ((@skip std/data/hashset/Hash-set((@x: (std/core/types/vector :: V -> V)<(std/core/types/list :: V -> V)<a>>) : (std/core/types/vector :: V -> V)<(std/core/types/list :: V -> V)<a>>, (@pat@0: std/core/types/int) : std/core/types/int, (@pat@1: std/core/types/int64) : std/core/types/int64) : (hash-set :: V -> V)<a> ) as @pat: ((hash-set :: V -> V)<a>))
                   -> @x;
              });
            }))(hs)), (fn<(e :: E)>(buckets: (std/core/types/list :: V -> V)<a>){
              (std/core/list/map<a,b,(e :: E)>(buckets, f));
            }));
    std/data/hashset/Hash-set<b>(new-data, (std/core/types/@open<(std/core/types/total :: E),(e :: E),((hash-set :: V -> V)<a>) -> std/core/types/int,((hash-set :: V -> V)<a>) -> (e :: E) std/core/types/int>((fn(@this@0: (hash-set :: V -> V)<a>){
        (match (@this@0) {
          ((@skip std/data/hashset/Hash-set((@pat@0@0: (std/core/types/vector :: V -> V)<(std/core/types/list :: V -> V)<a>>) : (std/core/types/vector :: V -> V)<(std/core/types/list :: V -> V)<a>>, (@x@0: std/core/types/int) : std/core/types/int, (@pat@1@0: std/core/types/int64) : std/core/types/int64) : (hash-set :: V -> V)<a> ) as @pat@2: ((hash-set :: V -> V)<a>))
             -> @x@0;
        });
      }))(hs)), (std/core/types/@open<(std/core/types/total :: E),(e :: E),((hash-set :: V -> V)<a>) -> std/core/types/int64,((hash-set :: V -> V)<a>) -> (e :: E) std/core/types/int64>((fn(@this@1: (hash-set :: V -> V)<a>){
        (match (@this@1) {
          ((@skip std/data/hashset/Hash-set((@pat@0@1: (std/core/types/vector :: V -> V)<(std/core/types/list :: V -> V)<a>>) : (std/core/types/vector :: V -> V)<(std/core/types/list :: V -> V)<a>>, (@pat@1@1: std/core/types/int) : std/core/types/int, (@x@1: std/core/types/int64) : std/core/types/int64) : (hash-set :: V -> V)<a> ) as @pat@3: ((hash-set :: V -> V)<a>))
             -> @x@1;
        });
      }))(hs)));
  };
recursive specialize "___*"  fun helper/rehash // inline size: 10
  = forall<a> fn(v: (std/core/types/vector :: V -> V)<(std/core/types/list :: V -> V)<a>>, buckets: (std/core/types/list :: V -> V)<a>, seed: std/core/types/int64, @implicit/hash: (a, std/core/types/int64) -> std/core/types/int){
    (match (buckets) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat: ((std/core/types/list :: V -> V)<a>))
         -> v;
      ((@skip std/core/types/Cons((value: a) : a, (xs: (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a> ) as @pat@0: ((std/core/types/list :: V -> V)<a>))
         -> val the-hash[113,11,113,18] : std/core/types/int
              = @implicit/hash(value, seed);
            val position[114,11,114,18] : std/core/types/int
              = std/core/int/(%)(the-hash, (std/core/int/#ssize_t/int((std/core/vector/lengthz<(std/core/types/list :: V -> V)<a>>(v)))));
            val new-v[115,11,115,15] : (std/core/types/vector :: V -> V)<(std/core/types/list :: V -> V)<a>>
              = std/core-extras/unsafe-set<(std/core/types/list :: V -> V)<a>>(v, position, (std/core/types/Cons<a>(value, (std/core-extras/unsafe-idx<(std/core/types/list :: V -> V)<a>>(v, (std/core/int/ssize_t(position)))))));
        std/data/hashset/#helper/rehash<a>(new-v, xs, seed, @implicit/hash);
    });
  };
specialize "*"  fun helper/resize // inline size: 1
  = forall<a> fn(v: (std/core/types/vector :: V -> V)<(std/core/types/list :: V -> V)<a>>){
    (match ((std/core-extras/is-vec-unique<(std/core/types/list :: V -> V)<a>>(v))) {
      ((std/core/types/True() : std/core/types/bool ) as @pat: std/core/types/bool)
         -> val _@0[87,5,87,19] : ()
                  = std/core/for<(std/core/types/total :: E)>((std/core/int/#ssize_t/int((std/core/vector/lengthz<(std/core/types/list :: V -> V)<a>>(v)))), (fn(i: std/core/types/int){
                      val _[88,7,88,28] : ()
                            = (std/core-extras/drop-at<(std/core/types/list :: V -> V)<a>>(v, (std/core/int/ssize_t(i))));
                      (std/core-extras/unsafe-assign<(std/core/types/list :: V -> V)<a>>(v, (std/core/int/ssize_t(i)), (std/core/types/Nil<a>)));
                    }));
        v;
      ((@skip std/core/types/False() : std/core/types/bool ) as @pat@0: std/core/types/bool)
         -> val n@10009[1,0,1,0] : std/core/types/int
                  = std/core/int/#ssize_t/int((std/core/vector/lengthz<(std/core/types/list :: V -> V)<a>>(v)));
        std/core/vector/vector-alloc<(std/core/types/list :: V -> V)<a>,(std/core/types/total :: E)>((std/core/int/ssize_t(n@10009)), (std/core/types/Nil<a>));
    });
  };
specialize "___*"  fun list/hash-set-seeded // inline size: 1
  = forall<a> fn(xs: (std/core/types/list :: V -> V)<a>, seed: std/core/types/int64, @implicit/hash: (a, std/core/types/int64) -> std/core/types/int, @implicit/(==): (a, a) -> std/core/types/bool){
    val capacity@10047[1,0,1,0] : (std/core/types/@optional :: V -> V)<std/core/types/int>
      = std/core/types/@Optional<std/core/types/int>((std/core/list/@lift-length@4947<a>(xs, 0)));
    val n@10049[1,0,1,0] : std/core/types/int
      = (match ((std/core/int/(>)((match (capacity@10047) {
          ((std/core/types/@Optional((@uniq-capacity@391: std/core/types/int) : std/core/types/int) : (std/core/types/@optional :: V -> V)<std/core/types/int> ) as @pat: ((std/core/types/@optional :: V -> V)<std/core/types/int>))
             -> @uniq-capacity@391;
          ((@skip std/core/types/@None() : (std/core/types/@optional :: V -> V)<std/core/types/int> ) as @pat@0: ((std/core/types/@optional :: V -> V)<std/core/types/int>))
             -> 1;
        }), 0))) {
        ((std/core/types/True() : std/core/types/bool ) as @pat@1: std/core/types/bool)
           -> (match (capacity@10047) {
            ((std/core/types/@Optional((@uniq-capacity@391: std/core/types/int) : std/core/types/int) : (std/core/types/@optional :: V -> V)<std/core/types/int> ) as @pat: ((std/core/types/@optional :: V -> V)<std/core/types/int>))
               -> @uniq-capacity@391;
            ((@skip std/core/types/@None() : (std/core/types/@optional :: V -> V)<std/core/types/int> ) as @pat@0: ((std/core/types/@optional :: V -> V)<std/core/types/int>))
               -> 1;
          });
        ((@skip std/core/types/False() : std/core/types/bool ) as @pat@2: std/core/types/bool)
           -> 1;
      });
    std/data/hashset/from-list-helper<a>((std/data/hashset/Hash-set<a>((std/core/vector/vector-alloc<(std/core/types/list :: V -> V)<a>,(std/core/types/total :: E)>((std/core/int/ssize_t(n@10049)), (std/core/types/Nil<a>))), 0, seed)), xs, @implicit/hash, @implicit/(==));
  };
specialize "__*"  fun thread/list/hash-set // inline size: 1
  = forall<a> fn(xs: (std/core/types/list :: V -> V)<a>, @implicit/hash: (a, std/core/types/int64) -> std/core/types/int, @implicit/(==): (a, a) -> std/core/types/bool){
    val capacity@10042[1,0,1,0] : (std/core/types/@optional :: V -> V)<std/core/types/int>
      = std/core/types/@Optional<std/core/types/int>((std/core/list/@lift-length@4947<a>(xs, 0)));
    val n@10044[1,0,1,0] : std/core/types/int
      = (match ((std/core/int/(>)((match (capacity@10042) {
          ((std/core/types/@Optional((@uniq-capacity@275: std/core/types/int) : std/core/types/int) : (std/core/types/@optional :: V -> V)<std/core/types/int> ) as @pat: ((std/core/types/@optional :: V -> V)<std/core/types/int>))
             -> @uniq-capacity@275;
          ((@skip std/core/types/@None() : (std/core/types/@optional :: V -> V)<std/core/types/int> ) as @pat@0: ((std/core/types/@optional :: V -> V)<std/core/types/int>))
             -> 1;
        }), 0))) {
        ((std/core/types/True() : std/core/types/bool ) as @pat@1: std/core/types/bool)
           -> (match (capacity@10042) {
            ((std/core/types/@Optional((@uniq-capacity@275: std/core/types/int) : std/core/types/int) : (std/core/types/@optional :: V -> V)<std/core/types/int> ) as @pat: ((std/core/types/@optional :: V -> V)<std/core/types/int>))
               -> @uniq-capacity@275;
            ((@skip std/core/types/@None() : (std/core/types/@optional :: V -> V)<std/core/types/int> ) as @pat@0: ((std/core/types/@optional :: V -> V)<std/core/types/int>))
               -> 1;
          });
        ((@skip std/core/types/False() : std/core/types/bool ) as @pat@2: std/core/types/bool)
           -> 1;
      });
    std/data/hashset/from-list-helper<a>((std/data/hashset/Hash-set<a>((std/core/vector/vector-alloc<(std/core/types/list :: V -> V)<a>,(std/core/types/total :: E)>((std/core/int/ssize_t(n@10044)), (std/core/types/Nil<a>))), 0, std/data/hash/#thread/seed)), xs, @implicit/hash, @implicit/(==));
  };
specialize "_*"  fun unique/map // inline size: 1
  = forall<a,b> fn(hs: (hash-set :: V -> V)<a>, f: (a) -> b){
    (match (hs) {
      ((@skip std/data/hashset/Hash-set((data: (std/core/types/vector :: V -> V)<(std/core/types/list :: V -> V)<a>>) : (std/core/types/vector :: V -> V)<(std/core/types/list :: V -> V)<a>>, (amount: std/core/types/int) : std/core/types/int, (seed: std/core/types/int64) : std/core/types/int64) : (hash-set :: V -> V)<a> ) as @pat: ((hash-set :: V -> V)<a>))
         -> val new-data[192,11,192,18] : (std/core/types/vector :: V -> V)<(std/core/types/list :: V -> V)<b>>
                  = std/core-extras/#unique/map<(std/core/types/list :: V -> V)<a>,(std/core/types/list :: V -> V)<b>>(data, (fn(bucket: (std/core/types/list :: V -> V)<a>){
                      (std/core/list/map<a,b,(std/core/types/total :: E)>(bucket, f));
                    }));
        std/data/hashset/Hash-set<b>(new-data, amount, seed);
    });
  };
inline borrow "^"  fun hash-set/data // inline size: 0
  = forall<a> fn(@this: (hash-set :: V -> V)<a>){
    (match (@this) {
      ((@skip std/data/hashset/Hash-set((@x: (std/core/types/vector :: V -> V)<(std/core/types/list :: V -> V)<a>>) : (std/core/types/vector :: V -> V)<(std/core/types/list :: V -> V)<a>>, (@pat@0: std/core/types/int) : std/core/types/int, (@pat@1: std/core/types/int64) : std/core/types/int64) : (hash-set :: V -> V)<a> ) as @pat: ((hash-set :: V -> V)<a>))
         -> @x;
    });
  };
inline borrow "^"  fun hash-set/amount // inline size: 0
  = forall<a> fn(@this: (hash-set :: V -> V)<a>){
    (match (@this) {
      ((@skip std/data/hashset/Hash-set((@pat@0: (std/core/types/vector :: V -> V)<(std/core/types/list :: V -> V)<a>>) : (std/core/types/vector :: V -> V)<(std/core/types/list :: V -> V)<a>>, (@x: std/core/types/int) : std/core/types/int, (@pat@1: std/core/types/int64) : std/core/types/int64) : (hash-set :: V -> V)<a> ) as @pat: ((hash-set :: V -> V)<a>))
         -> @x;
    });
  };
inline borrow "^"  fun hash-set/seed // inline size: 0
  = forall<a> fn(@this: (hash-set :: V -> V)<a>){
    (match (@this) {
      ((@skip std/data/hashset/Hash-set((@pat@0: (std/core/types/vector :: V -> V)<(std/core/types/list :: V -> V)<a>>) : (std/core/types/vector :: V -> V)<(std/core/types/list :: V -> V)<a>>, (@pat@1: std/core/types/int) : std/core/types/int, (@x: std/core/types/int64) : std/core/types/int64) : (hash-set :: V -> V)<a> ) as @pat: ((hash-set :: V -> V)<a>))
         -> @x;
    });
  };
 fun hash-set/@copy // inline size: 4
  = forall<a> fn(@this: (hash-set :: V -> V)<a>, data: (std/core/types/@optional :: V -> V)<(std/core/types/vector :: V -> V)<(std/core/types/list :: V -> V)<a>>>, amount: (std/core/types/@optional :: V -> V)<std/core/types/int>, seed: (std/core/types/@optional :: V -> V)<std/core/types/int64>){
    std/data/hashset/Hash-set<a>((match (data) {
        ((std/core/types/@Optional((@uniq-data@216: (std/core/types/vector :: V -> V)<(std/core/types/list :: V -> V)<a>>) : (std/core/types/vector :: V -> V)<(std/core/types/list :: V -> V)<a>>) : (std/core/types/@optional :: V -> V)<(std/core/types/vector :: V -> V)<(std/core/types/list :: V -> V)<a>>> ) as @pat: ((std/core/types/@optional :: V -> V)<(std/core/types/vector :: V -> V)<(std/core/types/list :: V -> V)<a>>>))
           -> @uniq-data@216;
        ((@skip std/core/types/@None() : (std/core/types/@optional :: V -> V)<(std/core/types/vector :: V -> V)<(std/core/types/list :: V -> V)<a>>> ) as @pat@0: ((std/core/types/@optional :: V -> V)<(std/core/types/vector :: V -> V)<(std/core/types/list :: V -> V)<a>>>))
           -> (match (@this) {
            ((@skip std/data/hashset/Hash-set((@x: (std/core/types/vector :: V -> V)<(std/core/types/list :: V -> V)<a>>) : (std/core/types/vector :: V -> V)<(std/core/types/list :: V -> V)<a>>, (@pat@0@0: std/core/types/int) : std/core/types/int, (@pat@1@0: std/core/types/int64) : std/core/types/int64) : (hash-set :: V -> V)<a> ) as @pat@1: ((hash-set :: V -> V)<a>))
               -> @x;
          });
      }), (match (amount) {
        ((std/core/types/@Optional((@uniq-amount@226: std/core/types/int) : std/core/types/int) : (std/core/types/@optional :: V -> V)<std/core/types/int> ) as @pat@1@1: ((std/core/types/@optional :: V -> V)<std/core/types/int>))
           -> @uniq-amount@226;
        ((@skip std/core/types/@None() : (std/core/types/@optional :: V -> V)<std/core/types/int> ) as @pat@2: ((std/core/types/@optional :: V -> V)<std/core/types/int>))
           -> (match (@this) {
            ((@skip std/data/hashset/Hash-set((@pat@0@1: (std/core/types/vector :: V -> V)<(std/core/types/list :: V -> V)<a>>) : (std/core/types/vector :: V -> V)<(std/core/types/list :: V -> V)<a>>, (@x@0: std/core/types/int) : std/core/types/int, (@pat@1@2: std/core/types/int64) : std/core/types/int64) : (hash-set :: V -> V)<a> ) as @pat@3: ((hash-set :: V -> V)<a>))
               -> @x@0;
          });
      }), (match (seed) {
        ((std/core/types/@Optional((@uniq-seed@236: std/core/types/int64) : std/core/types/int64) : (std/core/types/@optional :: V -> V)<std/core/types/int64> ) as @pat@3@0: ((std/core/types/@optional :: V -> V)<std/core/types/int64>))
           -> @uniq-seed@236;
        ((@skip std/core/types/@None() : (std/core/types/@optional :: V -> V)<std/core/types/int64> ) as @pat@4: ((std/core/types/@optional :: V -> V)<std/core/types/int64>))
           -> (match (@this) {
            ((@skip std/data/hashset/Hash-set((@pat@0@2: (std/core/types/vector :: V -> V)<(std/core/types/list :: V -> V)<a>>) : (std/core/types/vector :: V -> V)<(std/core/types/list :: V -> V)<a>>, (@pat@1@3: std/core/types/int) : std/core/types/int, (@x@1: std/core/types/int64) : std/core/types/int64) : (hash-set :: V -> V)<a> ) as @pat@5: ((hash-set :: V -> V)<a>))
               -> @x@1;
          });
      }));
  };
inline val int-hash // inline size: 0
  = std/data/hash/#int/hash;
inline val char-hash // inline size: 0
  = std/data/hash/#char/hash;
inline val bool-hash // inline size: 0
  = std/data/hash/#bool/hash;
inline val string-hash // inline size: 0
  = std/data/hash/#string/hash;
inline  fun length // inline size: 0
  = forall<a> fn(hs: (hash-set :: V -> V)<a>){
    (match (hs) {
      ((@skip std/data/hashset/Hash-set((@pat@0: (std/core/types/vector :: V -> V)<(std/core/types/list :: V -> V)<a>>) : (std/core/types/vector :: V -> V)<(std/core/types/list :: V -> V)<a>>, (@x: std/core/types/int) : std/core/types/int, (@pat@1: std/core/types/int64) : std/core/types/int64) : (hash-set :: V -> V)<a> ) as @pat: ((hash-set :: V -> V)<a>))
         -> @x;
    });
  };
 fun when-resize // inline size: 3
  = fn(table-size: std/core/types/int, item-count: std/core/types/int){
    match ((std/core/int/(<=)((std/core/int/(*)(2, table-size)), item-count))) {
      ((std/core/types/True() : std/core/types/bool ) as @pat: std/core/types/bool)
         -> std/core/types/True;
      ((@skip std/core/types/False() : std/core/types/bool ) as @pat@0: std/core/types/bool)
         -> std/core/types/False;
    };
  };
 fun resizer // inline size: 1
  = fn(table-size: std/core/types/int, item-count: std/core/types/int){
    std/core/int/(*)(item-count, 2);
  };
 fun unique/map // inline size: 3
  = forall<a,b> fn(hs: (hash-set :: V -> V)<a>, f: (a) -> b){
    (match (hs) {
      ((@skip std/data/hashset/Hash-set((data: (std/core/types/vector :: V -> V)<(std/core/types/list :: V -> V)<a>>) : (std/core/types/vector :: V -> V)<(std/core/types/list :: V -> V)<a>>, (amount: std/core/types/int) : std/core/types/int, (seed: std/core/types/int64) : std/core/types/int64) : (hash-set :: V -> V)<a> ) as @pat: ((hash-set :: V -> V)<a>))
         -> val new-data[192,11,192,18] : (std/core/types/vector :: V -> V)<(std/core/types/list :: V -> V)<b>>
                  = std/core-extras/#unique/map<(std/core/types/list :: V -> V)<a>,(std/core/types/list :: V -> V)<b>>(data, (fn(bucket: (std/core/types/list :: V -> V)<a>){
                      (std/core/list/map<a,b,(std/core/types/total :: E)>(bucket, f));
                    }));
        std/data/hashset/Hash-set<b>(new-data, amount, seed);
    });
  };